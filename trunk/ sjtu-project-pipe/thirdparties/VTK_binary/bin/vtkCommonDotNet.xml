<?xml version="1.0"?>
<doc>
    <assembly>
        "vtkCommonDotNet"
    </assembly>
    <members>
        <member name="M:vtk.vtkAssemblyPaths.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAssemblyPaths.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPaths.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyPaths.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyPaths.GetMTime">
            <summary>
                <para>Override the standard GetMTime() to check for the modified times of the paths.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPaths.GetNextItem">
            <summary>
                <para>Get the next path in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPaths.IsItemPresent(vtk.vtkAssemblyPath)">
            <summary>
                <para>Determine whether a particular path is present. Returns its position in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPaths.RemoveItem(vtk.vtkAssemblyPath)">
            <summary>
                <para>Remove a path from the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPaths.AddItem(vtk.vtkAssemblyPath)">
            <summary>
                <para>Add a path to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollectionIterator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollectionIterator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollectionIterator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataArrayCollectionIterator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollectionIterator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollectionIterator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollectionIterator.GetDataArray">
            <summary>
                <para>Get the item at the current iterator position.  Valid only when IsDoneWithTraversal() returns 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollectionIterator.SetCollection(vtk.vtkDataArrayCollection)">
            <summary>
                <para>Set the collection over which to iterate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollectionIterator.SetCollection(vtk.vtkCollection)">
            <summary>
                <para>Set the collection over which to iterate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLogLookupTable.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLogLookupTable.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLogLookupTable.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLogLookupTable.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLogLookupTable.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLogLookupTable.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCriticalSection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCriticalSection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCriticalSection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCriticalSection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCriticalSection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCriticalSection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCriticalSection.Unlock">
            <summary>
                <para>Unlock the vtkCriticalSection</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCriticalSection.Lock">
            <summary>
                <para>Lock the vtkCriticalSection</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLongArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLongArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLongArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLongArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLongArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLongArray.InsertNextValue(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.InsertValue(System.Int32,System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.SetValue(System.Int32,System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.InsertNextTupleValue(System.Int32!System.Runtime.CompilerServices.IsLong[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.InsertTupleValue(System.Int32,System.Int32!System.Runtime.CompilerServices.IsLong[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.SetTupleValue(System.Int32,System.Int32!System.Runtime.CompilerServices.IsLong[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.GetTupleValue(System.Int32,System.Int32!System.Runtime.CompilerServices.IsLong[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkBitArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkBitArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkBitArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkBitArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkBitArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkBitArray.SetVoidArray(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                <para>This method lets the user specify data to be held by the array.  The  array argument is a pointer to the data.  size is the size of  the array supplied by the user.  Set save to 1 to keep the class from deleting the array when it cleans up or reallocates memory. The class uses the actual array provided; it does not copy the data  from the suppled array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.SetArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
                <para>This method lets the user specify data to be held by the array.  The  array argument is a pointer to the data.  size is the size of  the array supplied by the user.  Set save to 1 to keep the class from deleting the array when it cleans up or reallocates memory. The class uses the actual array provided; it does not copy the data  from the suppled array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.DeepCopy(vtk.vtkDataArray)">
            <summary>
                <para>Deep copy of another bit array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.GetVoidPointer(System.Int32)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.WriteVoidPointer(System.Int32,System.Int32)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.InsertComponent(System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Insert the data component at ith tuple and jth component location.  Note that memory allocation is performed as necessary to hold the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.InsertNextValue(System.Int32)">
            <summary>
                <para>Insets values and checks to make sure there is enough memory</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.InsertValue(System.Int32,System.Int32)">
            <summary>
                <para>Insets values and checks to make sure there is enough memory</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.SetValue(System.Int32,System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Fast method based setting of values without memory checks. First use SetNumberOfValues then use SetValue to actually set them. Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.GetValue(System.Int32)">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.Resize(System.Int32)">
            <summary>
                <para>Resize the array while conserving the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.Squeeze">
            <summary>
                <para>Free any unneeded memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.SetComponent(System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Set the data component at the ith tuple and jth component location. Note that i is less then NumberOfTuples and j is less then  NumberOfComponents. Make sure enough memory has been allocated (use  SetNumberOfTuples() and  SetNumberOfComponents()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.InsertNextTuple(System.Double[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.InsertNextTuple(System.Single[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.InsertTuple(System.Int32,System.Double[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.InsertTuple(System.Int32,System.Single[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.SetTuple(System.Int32,System.Double[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.SetTuple(System.Int32,System.Single[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.GetTuple(System.Int32,System.Double[])">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.SetNumberOfTuples(System.Int32)">
            <summary>
                <para>Set the number of n-tuples in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.GetDataTypeSize">
            <summary>
                <para>Set the number of n-tuples in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.Initialize">
            <summary>
                <para>Release storage and reset array to initial state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBitArray.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate memory for this array. Delete old storage only if necessary. Note that ext is no longer used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt32Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt32Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt32Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeUInt32Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeUInt32Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt32Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadric.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuadric.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuadric.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuadric.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuadric.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuadric.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricMobius.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Du, Dv are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>The Mobius strip.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.GetDimension">
            <summary>
                <para>The Mobius strip.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.GetRadius">
            <summary>
                <para>Set/Get the radius of the Mobius strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricMobius.SetRadius(System.Double)">
            <summary>
                <para>Set/Get the radius of the Mobius strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkIdListCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkIdListCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkIdListCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkIdListCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkIdListCollection.GetItem(System.Int32)">
            <summary>
                <para>Get the ith dataset in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdListCollection.GetNextItem">
            <summary>
                <para>Get the next dataset in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdListCollection.AddItem(vtk.vtkIdList)">
            <summary>
                <para>Add a dataset to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTransformCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTransformCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTransformCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTransformCollection.GetNextItem">
            <summary>
                <para>Get the next Transform in the list. Return NULL when the end of the list is reached.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformCollection.AddItem(vtk.vtkTransform)">
            <summary>
                <para>Add a Transform to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta45.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta45.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta45.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRungeKutta45.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta45.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta45.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta45.ComputeNextStep(System.Double[],System.Double[],System.Double[],System.Double,System.Double@,System.Double@,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delTActual (xnext). Possibly delTActual != delT. This may occur because this solver supports adaptive stepsize control. It tries  to change to stepsize such that the (estimated) error of the integration is less than maxError. The solver will not set the stepsize smaller than minStep or larger than maxStep (note that maxStep and minStep should both be positive, whereas delT can be negative). Also note that delT is an in/out argument. vtkRungeKutta45 will modify delT to reflect the best (estimated) size for the next integration step. An estimated value for the error is returned (by reference) in error. This is the norm of the error vector if there are more than one function to be integrated. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta45.ComputeNextStep(System.Double[],System.Double[],System.Double,System.Double@,System.Double@,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delTActual (xnext). Possibly delTActual != delT. This may occur because this solver supports adaptive stepsize control. It tries  to change to stepsize such that the (estimated) error of the integration is less than maxError. The solver will not set the stepsize smaller than minStep or larger than maxStep (note that maxStep and minStep should both be positive, whereas delT can be negative). Also note that delT is an in/out argument. vtkRungeKutta45 will modify delT to reflect the best (estimated) size for the next integration step. An estimated value for the error is returned (by reference) in error. This is the norm of the error vector if there are more than one function to be integrated. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta45.ComputeNextStep(System.Double[],System.Double[],System.Double[],System.Double,System.Double@,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delTActual (xnext). Possibly delTActual != delT. This may occur because this solver supports adaptive stepsize control. It tries  to change to stepsize such that the (estimated) error of the integration is less than maxError. The solver will not set the stepsize smaller than minStep or larger than maxStep (note that maxStep and minStep should both be positive, whereas delT can be negative). Also note that delT is an in/out argument. vtkRungeKutta45 will modify delT to reflect the best (estimated) size for the next integration step. An estimated value for the error is returned (by reference) in error. This is the norm of the error vector if there are more than one function to be integrated. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta45.ComputeNextStep(System.Double[],System.Double[],System.Double,System.Double@,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delTActual (xnext). Possibly delTActual != delT. This may occur because this solver supports adaptive stepsize control. It tries  to change to stepsize such that the (estimated) error of the integration is less than maxError. The solver will not set the stepsize smaller than minStep or larger than maxStep (note that maxStep and minStep should both be positive, whereas delT can be negative). Also note that delT is an in/out argument. vtkRungeKutta45 will modify delT to reflect the best (estimated) size for the next integration step. An estimated value for the error is returned (by reference) in error. This is the norm of the error vector if there are more than one function to be integrated. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OutputWindow.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OutputWindow.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OutputWindow.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWin32OutputWindow.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWin32OutputWindow.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OutputWindow.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OutputWindow.DisplayText(System.String)">
            <summary>
                <para>New lines are converted to carriage return new lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTransform.MultiplyPoint(System.Double[],System.Double[])">
            <summary>
                <para>Use this method only if you wish to compute the transformation in homogeneous (x,y,z,w) coordinates, otherwise use TransformPoint(). This method calls this-&gt;GetMatrix()-&gt;MultiplyPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.MultiplyPoint(System.Single[],System.Single[])">
            <summary>
                <para>Use this method only if you wish to compute the transformation in homogeneous (x,y,z,w) coordinates, otherwise use TransformPoint(). This method calls this-&gt;GetMatrix()-&gt;MultiplyPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetMTime">
            <summary>
                <para>Override GetMTime to account for input and concatenation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.MakeTransform">
            <summary>
                <para>Make a new transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetInverse">
            <summary>
                <para>Make a new transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.CircuitCheck(vtk.vtkAbstractTransform)">
            <summary>
                <para>Check for self-reference.  Will return true if concatenating with the specified transform, setting it to be our inverse, or setting it to be our input will create a circular reference. CircuitCheck is automatically called by SetInput(), SetInverse(), and Concatenate(vtkXTransform *).  Avoid using this function, it is experimental.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Pop">
            <summary>
                <para>Deletes the transformation on the top of the stack and sets the top  to the next transformation on the stack.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Push">
            <summary>
                <para>Pushes the current transformation onto the transformation stack.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetInverseFlag">
            <summary>
                <para>Get the inverse flag of the transformation.  This controls whether it is the Input or the inverse of the Input that is used as the base transformation.  The InverseFlag is flipped every time Inverse() is called.  The InverseFlag is off when a transform is first created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetInput">
            <summary>
                <para>Set the input for this transformation.  This will be used as the base transformation if it is set.  This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly.  Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.SetInput(vtk.vtkLinearTransform)">
            <summary>
                <para>Set the input for this transformation.  This will be used as the base transformation if it is set.  This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly.  Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetTranspose(vtk.vtkMatrix4x4)">
            <summary>
                <para>Return a matrix which is the transpose of the current transformation matrix.  This is equivalent to the inverse if and only if the  transformation is a pure rotation with no translation or scale.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetInverse(vtk.vtkMatrix4x4)">
            <summary>
                <para>Return a matrix which is the inverse of the current transformation matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetScale">
            <summary>
                <para>Return the scale factors of the current transformation matrix as  an array of three float numbers.  These scale factors are not necessarily about the x, y, and z axes unless unless the scale transformation was applied before any rotations.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetScale(System.Single[])">
            <summary>
                <para>Return the scale factors of the current transformation matrix as  an array of three float numbers.  These scale factors are not necessarily about the x, y, and z axes unless unless the scale transformation was applied before any rotations.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetScale(System.Double[])">
            <summary>
                <para>Return the scale factors of the current transformation matrix as  an array of three float numbers.  These scale factors are not necessarily about the x, y, and z axes unless unless the scale transformation was applied before any rotations.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetPosition">
            <summary>
                <para>Return the position from the current transformation matrix as an array of three floating point numbers. This is simply returning the translation  component of the 4x4 matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetPosition(System.Single[])">
            <summary>
                <para>Return the position from the current transformation matrix as an array of three floating point numbers. This is simply returning the translation  component of the 4x4 matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetPosition(System.Double[])">
            <summary>
                <para>Return the position from the current transformation matrix as an array of three floating point numbers. This is simply returning the translation  component of the 4x4 matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetOrientationWXYZ">
            <summary>
                <para>Return the wxyz angle+axis representing the current orientation. The angle is in degrees and the axis is a unit vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetOrientationWXYZ(System.Single[])">
            <summary>
                <para>Return the wxyz angle+axis representing the current orientation. The angle is in degrees and the axis is a unit vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetOrientationWXYZ(System.Double[])">
            <summary>
                <para>Return the wxyz angle+axis representing the current orientation. The angle is in degrees and the axis is a unit vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetOrientation(System.Double[],vtk.vtkMatrix4x4)">
            <summary>
                <para>Convenience function to get the x, y, z orientation angles from  a transformation matrix as an array of three floating point values.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetOrientation">
            <summary>
                <para>Get the x, y, z orientation angles from the transformation matrix as an array of three floating point values.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetOrientation(System.Single[])">
            <summary>
                <para>Get the x, y, z orientation angles from the transformation matrix as an array of three floating point values.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetOrientation(System.Double[])">
            <summary>
                <para>Get the x, y, z orientation angles from the transformation matrix as an array of three floating point values.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.GetNumberOfConcatenatedTransforms">
            <summary>
                <para>Get the total number of transformations that are linked into this one via Concatenate() operations or via SetInput().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.PostMultiply">
            <summary>
                <para>Sets the internal state of the transform to PostMultiply. All subsequent operations will occur after those already represented in the current transformation.  In homogeneous matrix notation, M = A*M where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.PreMultiply">
            <summary>
                <para>Sets the internal state of the transform to PreMultiply. All subsequent operations will occur before those already represented in the current transformation.  In homogeneous matrix notation, M = M*A where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Concatenate(vtk.vtkLinearTransform)">
            <summary>
                <para>Concatenate the specified transform with the current transformation according to PreMultiply or PostMultiply semantics. The concatenation is pipelined, meaning that if any of the transformations are changed, even after Concatenate() is called, those changes will be reflected when you call TransformPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Concatenate(System.Double[])">
            <summary>
                <para>Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Concatenate(vtk.vtkMatrix4x4)">
            <summary>
                <para>Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.SetMatrix(System.Double[])">
            <summary>
                <para>Set the current matrix directly.  This actually calls Identity(), followed by Concatenate(matrix).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.SetMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>Set the current matrix directly.  This actually calls Identity(), followed by Concatenate(matrix).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Scale(System.Single[])">
            <summary>
                <para>Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Scale(System.Double[])">
            <summary>
                <para>Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Scale(System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.RotateZ(System.Double)">
            <summary>
                <para>Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  The angle is expressed in degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.RotateY(System.Double)">
            <summary>
                <para>Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  The angle is expressed in degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.RotateX(System.Double)">
            <summary>
                <para>Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  The angle is expressed in degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.RotateWXYZ(System.Double,System.Single[])">
            <summary>
                <para>Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.RotateWXYZ(System.Double,System.Double[])">
            <summary>
                <para>Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.RotateWXYZ(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Translate(System.Single[])">
            <summary>
                <para>Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Translate(System.Double[])">
            <summary>
                <para>Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Translate(System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Inverse">
            <summary>
                <para>Invert the transformation.  This will also set a flag so that the transformation will use the inverse of its Input, if an Input has been set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransform.Identity">
            <summary>
                <para>Set the transformation to the identity transformation.  If  the transform has an Input, then the transformation will be reset so that it is the same as the Input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMath.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMath.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMath.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMath.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMath.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMath.PointIsWithinBounds(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Return true if point is within the given 3D bounds Bounds is x-min, x-max, y-min, y-max, z-min, z-max Delta is the error margin along each axis (usually a small number)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.BoundsIsWithinOtherBounds(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Return true if first 3D bounds is within the second 3D bounds Bounds is x-min, x-max, y-min, y-max, z-min, z-max Delta is the error margin along each axis (usually a small number)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.ExtentIsWithinOtherExtent(System.Int32[],System.Int32[])">
            <summary>
                <para>Return true if first 3D extent is within second 3D extent Extent is x-min, x-max, y-min, y-max, z-min, z-max</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.GetAdjustedScalarRange(vtk.vtkDataArray,System.Int32,System.Double[])">
            <summary>
                <para>Get a vtkDataArray's scalar range for a given component.  If the vtkDataArray's data type is unsigned char (VTK_UNSIGNED_CHAR) the range is adjusted to the whole data type range [0, 255.0].  Same goes for unsigned short (VTK_UNSIGNED_SHORT) but the upper bound  is also adjusted down to 4095.0 if was between ]255, 4095.0]. Return 1 on success, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.GetScalarTypeFittingRange(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Return the scalar type that is most likely to have enough precision  to store a given range of data once it has been scaled and shifted  (i.e. [range_min * scale + shift, range_max * scale + shift].  If any one of the parameters is not an integer number (decimal part != 0), the search will default to float types only (float or double) Return -1 on error or no scalar type found.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.ClampValues(System.Double[],System.Int32,System.Double[],System.Double[])">
            <summary>
                <para>Clamp some values against a range The method without 'clamped_values' will perform in-place clamping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.ClampValues(System.Double[],System.Int32,System.Double[])">
            <summary>
                <para>Clamp some values against a range The method without 'clamped_values' will perform in-place clamping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.ClampValue(System.Double,System.Double[],System.Double[])">
            <summary>
                <para>Clamp some values against a range The method without 'clamped_values' will perform in-place clamping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.ClampValue(System.Double[],System.Double[])">
            <summary>
                <para>Clamp some values against a range The method without 'clamped_values' will perform in-place clamping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.AreBoundsInitialized(System.Double[])">
            <summary>
                <para>Clamp some values against a range The method without 'clamped_values' will perform in-place clamping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.UninitializeBounds(System.Double[])">
            <summary>
                <para>Are the bounds initialized?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.XYZToRGB(System.Double[],System.Double[])">
            <summary>
                <para>Convert color from Lab to XYZ system, and vice-versa</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.LabToXYZ(System.Double[],System.Double[])">
            <summary>
                <para>Convert color from Lab to XYZ system, and vice-versa</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.HSVToRGB(System.Double,System.Double,System.Double,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Convert color in HSV format (Hue, Saturation, Value) to RGB format (Red, Green, Blue). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.HSVToRGB(System.Double[],System.Double[])">
            <summary>
                <para>Convert color in HSV format (Hue, Saturation, Value) to RGB format (Red, Green, Blue). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.HSVToRGB(System.Double,System.Double,System.Double)">
            <summary>
                <para>Convert color in HSV format (Hue, Saturation, Value) to RGB format (Red, Green, Blue). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.HSVToRGB(System.Double[])">
            <summary>
                <para>Convert color in HSV format (Hue, Saturation, Value) to RGB format (Red, Green, Blue). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.HSVToRGB(System.Single,System.Single,System.Single,System.Single[],System.Single[],System.Single[])">
            <summary>
                <para>Convert color in HSV format (Hue, Saturation, Value) to RGB format (Red, Green, Blue). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.HSVToRGB(System.Single[],System.Single[])">
            <summary>
                <para>Convert color in HSV format (Hue, Saturation, Value) to RGB format (Red, Green, Blue). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.RGBToHSV(System.Double,System.Double,System.Double,System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Convert color in RGB format (Red, Green, Blue) to HSV format (Hue, Saturation, Value). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.RGBToHSV(System.Double[],System.Double[])">
            <summary>
                <para>Convert color in RGB format (Red, Green, Blue) to HSV format (Hue, Saturation, Value). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.RGBToHSV(System.Double,System.Double,System.Double)">
            <summary>
                <para>Convert color in RGB format (Red, Green, Blue) to HSV format (Hue, Saturation, Value). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.RGBToHSV(System.Double[])">
            <summary>
                <para>Convert color in RGB format (Red, Green, Blue) to HSV format (Hue, Saturation, Value). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.RGBToHSV(System.Single,System.Single,System.Single,System.Single[],System.Single[],System.Single[])">
            <summary>
                <para>Convert color in RGB format (Red, Green, Blue) to HSV format (Hue, Saturation, Value). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.RGBToHSV(System.Single[],System.Single[])">
            <summary>
                <para>Convert color in RGB format (Red, Green, Blue) to HSV format (Hue, Saturation, Value). The input color is not modified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.SolveLinear(System.Double,System.Double,System.Double[],System.Int32[])">
            <summary>
                <para>Solves a linear equation c2*t + c3 = 0 when c2 and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Root and number of (real) roots are stored in user provided variables r2 and num_roots.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.SolveQuadratic(System.Double,System.Double,System.Double,System.Double[],System.Double[],System.Int32[])">
            <summary>
                <para>Solves A Quadratic Equation c1*t^2  + c2*t  + c3 = 0 when  c1, c2, and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Roots and number of roots are stored in user provided variables r1, r2, num_roots</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.SolveCubic(System.Double,System.Double,System.Double,System.Double,System.Double[],System.Double[],System.Double[],System.Int32[])">
            <summary>
                <para>Solves a cubic equation when c0, c1, c2, And c3 Are REAL.  Solution is motivated by Numerical Recipes In C 2nd Ed.  Roots and number of real roots are stored in user provided variables r1, r2, r3, and num_roots. Note that the function can return the following integer values describing the roots: (0)-no solution; (-1)-infinite number of solutions; (1)-one distinct real root of multiplicity 3 (stored in r1); (2)-two distinct real roots, one of multiplicity 2 (stored in r1 &amp; r2); (3)-three distinct real roots; (-2)-quadratic equation with complex conjugate solution (real part of root returned in r1, imaginary in r2); (-3)-one real root and a complex conjugate pair (real root in r1 and real part of pair in r2 and imaginary in r3).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.SolveLinear(System.Double,System.Double)">
            <summary>
                <para>Solves a linear equation c2*t  + c3 = 0 when c2 and c3 are REAL. Solution is motivated by Numerical Recipes In C 2nd Ed. Return array contains number of roots followed by roots themselves.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.SolveQuadratic(System.Double,System.Double,System.Double)">
            <summary>
                <para>Solves a quadratic equation c1*t^2 + c2*t + c3 = 0 when c1, c2, and c3 are REAL.  Solution is motivated by Numerical Recipes In C 2nd Ed. Return array contains number of (real) roots (counting multiple roots as one) followed by roots themselves. Note that roots[3] contains a return code further describing solution - see documentation for SolveCubic() for meaning of return codes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.SolveCubic(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Solves a cubic equation c0*t^3 + c1*t^2 + c2*t + c3 = 0 when c0, c1, c2, and c3 are REAL.  Solution is motivated by Numerical Recipes In C 2nd Ed.  Return array contains number of (real) roots (counting multiple roots as one) followed by roots themselves. The value in roots[4] is a integer giving further information about the roots (see return codes for int SolveCubic()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Random(System.Double,System.Double)">
            <summary>
                <para>Generate random number between (min,max).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Random">
            <summary>
                <para>Generate random numbers between 0.0 and 1.0. This is used to provide portability across different systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.RandomSeed(System.Int32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Initialize seed value. NOTE: Random() has the bad property that  the first random number returned after RandomSeed() is called  is proportional to the seed value! To help solve this, call  RandomSeed() a few times inside seed. This doesn't ruin the  repeatability of Random().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.SingularValueDecomposition3x3(System.Double[0:,0:],System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>Perform singular value decomposition on a 3x3 matrix.  This is not done using a conventional SVD algorithm, instead it is done using Orthogonalize3x3 and Diagonalize3x3.  Both output matrices U and VT will have positive determinants, and the w values will be arranged such that the three rows of VT are aligned as closely as possible with the x, y, and z axes respectively.  If the determinant of A is negative, then the three w values will be negative.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.SingularValueDecomposition3x3(System.Single[0:,0:],System.Single[0:,0:],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>Perform singular value decomposition on a 3x3 matrix.  This is not done using a conventional SVD algorithm, instead it is done using Orthogonalize3x3 and Diagonalize3x3.  Both output matrices U and VT will have positive determinants, and the w values will be arranged such that the three rows of VT are aligned as closely as possible with the x, y, and z axes respectively.  If the determinant of A is negative, then the three w values will be negative.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Diagonalize3x3(System.Double[0:,0:],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>Diagonalize a symmetric 3x3 matrix and return the eigenvalues in w and the eigenvectors in the columns of V.  The matrix V will  have a positive determinant, and the three eigenvectors will be aligned as closely as possible with the x, y, and z axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Diagonalize3x3(System.Single[0:,0:],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>Diagonalize a symmetric 3x3 matrix and return the eigenvalues in w and the eigenvectors in the columns of V.  The matrix V will  have a positive determinant, and the three eigenvectors will be aligned as closely as possible with the x, y, and z axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Orthogonalize3x3(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
                <para>Orthogonalize a 3x3 matrix and put the result in B.  If matrix A has a negative determinant, then B will be a rotation plus a flip i.e. it will have a determinant of -1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Orthogonalize3x3(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
                <para>Orthogonalize a 3x3 matrix and put the result in B.  If matrix A has a negative determinant, then B will be a rotation plus a flip i.e. it will have a determinant of -1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Matrix3x3ToQuaternion(System.Double[0:,0:],System.Double[])">
            <summary>
                <para>Convert a 3x3 matrix into a quaternion.  This will provide the best possible answer even if the matrix is not a pure rotation matrix. The method used is that of B.K.P. Horn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Matrix3x3ToQuaternion(System.Single[0:,0:],System.Single[])">
            <summary>
                <para>Convert a 3x3 matrix into a quaternion.  This will provide the best possible answer even if the matrix is not a pure rotation matrix. The method used is that of B.K.P. Horn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.QuaternionToMatrix3x3(System.Double[],System.Double[0:,0:])">
            <summary>
                <para>Convert a quaternion to a 3x3 rotation matrix.  The quaternion does not have to be normalized beforehand.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.QuaternionToMatrix3x3(System.Single[],System.Single[0:,0:])">
            <summary>
                <para>Convert a quaternion to a 3x3 rotation matrix.  The quaternion does not have to be normalized beforehand.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Determinant3x3(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Calculate the determinant of a 3x3 matrix in the form:     | a1,  b1,  c1 |     | a2,  b2,  c2 |     | a3,  b3,  c3 |</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Determinant3x3(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Compute determinant of 3x3 matrix. Three columns of matrix are input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Determinant3x3(System.Single[],System.Single[],System.Single[])">
            <summary>
                <para>Compute determinant of 3x3 matrix. Three columns of matrix are input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Determinant3x3(System.Double[0:,0:])">
            <summary>
                <para>Return the determinant of a 3x3 matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Determinant3x3(System.Single[0:,0:])">
            <summary>
                <para>Return the determinant of a 3x3 matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Identity3x3(System.Double[0:,0:])">
            <summary>
                <para>Set A to the identity matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Identity3x3(System.Single[0:,0:])">
            <summary>
                <para>Set A to the identity matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Invert3x3(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
                <para>Invert a 3x3 matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Invert3x3(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
                <para>Invert a 3x3 matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Transpose3x3(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
                <para>Transpose a 3x3 matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Transpose3x3(System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
                <para>Transpose a 3x3 matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Multiply3x3(System.Double[0:,0:],System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
                <para>Mutltiply one 3x3 matrix by another according to C = AB.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Multiply3x3(System.Single[0:,0:],System.Single[0:,0:],System.Single[0:,0:])">
            <summary>
                <para>Mutltiply one 3x3 matrix by another according to C = AB.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Multiply3x3(System.Double[0:,0:],System.Double[],System.Double[])">
            <summary>
                <para>Multiply a vector by a 3x3 matrix.  The result is placed in out.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Multiply3x3(System.Single[0:,0:],System.Single[],System.Single[])">
            <summary>
                <para>Multiply a vector by a 3x3 matrix.  The result is placed in out.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.LinearSolve3x3(System.Double[0:,0:],System.Double[],System.Double[])">
            <summary>
                <para>Solve Ay = x for y and place the result in y.  The matrix A is destroyed in the process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.LinearSolve3x3(System.Single[0:,0:],System.Single[],System.Single[])">
            <summary>
                <para>Solve Ay = x for y and place the result in y.  The matrix A is destroyed in the process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.LUSolve3x3(System.Double[0:,0:],System.Int32[],System.Double[])">
            <summary>
                <para>LU back substitution for a 3x3 matrix.  The diagonal elements are the multiplicative inverse of those in the standard LU factorization.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.LUSolve3x3(System.Single[0:,0:],System.Int32[],System.Single[])">
            <summary>
                <para>LU back substitution for a 3x3 matrix.  The diagonal elements are the multiplicative inverse of those in the standard LU factorization.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.LUFactor3x3(System.Double[0:,0:],System.Int32[])">
            <summary>
                <para>LU Factorization of a 3x3 matrix.  The diagonal elements are the multiplicative inverse of those in the standard LU factorization.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.LUFactor3x3(System.Single[0:,0:],System.Int32[])">
            <summary>
                <para>LU Factorization of a 3x3 matrix.  The diagonal elements are the multiplicative inverse of those in the standard LU factorization.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Determinant2x2(System.Double[],System.Double[])">
            <summary>
                <para>Calculate the determinant of a 2x2 matrix: | a b | | c d |</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Determinant2x2(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Calculate the determinant of a 2x2 matrix: | a b | | c d |</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Determinant2x2(System.Single[],System.Single[])">
            <summary>
                <para>Compute determinant of 2x2 matrix. Two columns of matrix are input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Normalize2D(System.Double[])">
            <summary>
                <para>Normalize (in place) a 2-vector. Returns norm of vector. Ignores z-component (double-precision version).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Normalize2D(System.Single[])">
            <summary>
                <para>Normalize (in place) a 2-vector. Returns norm of vector. Ignores z-component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Norm2D(System.Double[])">
            <summary>
                <para>Compute the norm of a 2-vector. Ignores z-component (double-precision version).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Norm2D(System.Single[])">
            <summary>
                <para>Compute the norm of a 2-vector. Ignores z-component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Dot2D(System.Double[],System.Double[])">
            <summary>
                <para>Dot product of two 2-vectors. The third (z) component is ignored (double-precision version).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Dot2D(System.Single[],System.Single[])">
            <summary>
                <para>Dot product of two 2-vectors. The third (z) component is ignored.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Distance2BetweenPoints(System.Double[],System.Double[])">
            <summary>
                <para>Compute distance squared between two points (double precision version).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Distance2BetweenPoints(System.Single[],System.Single[])">
            <summary>
                <para>Compute distance squared between two points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Perpendiculars(System.Single[],System.Single[],System.Single[],System.Double)">
            <summary>
                <para>Given a unit vector x, find two unit vectors y and z such that  x cross y = z (i.e. the vectors are perpendicular to each other). There is an infinite number of such vectors, specify an angle theta  to choose one set.  If you want only one perpendicular vector,  specify NULL for z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Perpendiculars(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
                <para>Given a unit vector x, find two unit vectors y and z such that  x cross y = z (i.e. the vectors are perpendicular to each other). There is an infinite number of such vectors, specify an angle theta  to choose one set.  If you want only one perpendicular vector,  specify NULL for z.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Normalize(System.Double[])">
            <summary>
                <para>Normalize (in place) a 3-vector. Returns norm of vector (double-precision version).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Normalize(System.Single[])">
            <summary>
                <para>Normalize (in place) a 3-vector. Returns norm of vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Norm(System.Double[])">
            <summary>
                <para>Compute the norm of 3-vector (double-precision version).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Norm(System.Single[])">
            <summary>
                <para>Compute the norm of 3-vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Norm(System.Double[],System.Int32)">
            <summary>
                <para>Compute the norm of n-vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Norm(System.Single[],System.Int32)">
            <summary>
                <para>Compute the norm of n-vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Cross(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Cross product of two 3-vectors. Result vector in z[3]. (double-precision version)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Cross(System.Single[],System.Single[],System.Single[])">
            <summary>
                <para>Cross product of two 3-vectors. Result vector in z[3].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Dot(System.Double[],System.Double[])">
            <summary>
                <para>Dot product of two 3-vectors (double-precision version).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Dot(System.Single[],System.Single[])">
            <summary>
                <para>Dot product of two 3-vectors (float version).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Round(System.Single)">
            <summary>
                <para>Rounds a float to the nearest integer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.DoubleRadiansToDegrees">
            <summary>
                <para>Useful constants. (double-precision version)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.DoublePi">
            <summary>
                <para>Useful constants. (double-precision version)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.DoubleDegreesToRadians">
            <summary>
                <para>Useful constants. (double-precision version)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.RadiansToDegrees">
            <summary>
                <para>Useful constants.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.DegreesToRadians">
            <summary>
                <para>Useful constants.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMath.Pi">
            <summary>
                <para>Useful constants.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta2.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRungeKutta2.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta2.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta2.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta2.ComputeNextStep(System.Double[],System.Double[],System.Double[],System.Double,System.Double@,System.Double@,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delT (xnext). delTActual is always equal to delT. Since this class can not provide an estimate for the error error is set to 0.   maxStep, minStep and maxError are unused. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta2.ComputeNextStep(System.Double[],System.Double[],System.Double,System.Double@,System.Double@,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delT (xnext). delTActual is always equal to delT. Since this class can not provide an estimate for the error error is set to 0.   maxStep, minStep and maxError are unused. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta2.ComputeNextStep(System.Double[],System.Double[],System.Double[],System.Double,System.Double@,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delT (xnext). delTActual is always equal to delT. Since this class can not provide an estimate for the error error is set to 0.   maxStep, minStep and maxError are unused. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta2.ComputeNextStep(System.Double[],System.Double[],System.Double,System.Double@,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delT (xnext). delTActual is always equal to delT. Since this class can not provide an estimate for the error error is set to 0.   maxStep, minStep and maxError are unused. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkObjectFactoryCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkObjectFactoryCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkObjectFactoryCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkObjectFactoryCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkObjectFactoryCollection.AddItem(vtk.vtkObjectFactory)">
            <summary>
                <para>Get the next ObjectFactory in the list. Return NULL when the end of the list is reached.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkObject.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt64Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt64Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt64Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeUInt64Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeUInt64Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt64Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.InsertNextValue(System.UInt64)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.InsertValue(System.Int32,System.UInt64)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.SetValue(System.Int32,System.UInt64)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.InsertNextTupleValue(System.UInt64[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.InsertTupleValue(System.Int32,System.UInt64[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.SetTupleValue(System.Int32,System.UInt64[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.GetTupleValue(System.Int32,System.UInt64[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongLongArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTypeInt64Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt64Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt64Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeInt64Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeInt64Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt64Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkEdgeTable.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.Reset">
            <summary>
                <para>Reset the object and prepare for reinsertion of edges. Does not delete memory like the Initialize() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.GetNextEdge(System.Int32@,System.Int32@)">
            <summary>
                <para>Traverse list of edges in table. Return the edge as (p1,p2), where p1 and p2 are point id's. Method return value is &lt;0 if list is exhausted; non-zero otherwise. The value of p1 is guaranteed to be &lt;= p2.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.InitTraversal">
            <summary>
                <para>Intialize traversal of edges in table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.GetNumberOfEdges">
            <summary>
                <para>Return the number of edges that have been inserted thus far.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.InsertUniquePoint(System.Int32,System.Int32,System.Double[],System.Int32@)">
            <summary>
                <para>Insert a unique point on the specified edge. Invoke this method only after InitPointInsertion() has been called. Return 0 if point was  already in the list, otherwise return 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.InitPointInsertion(vtk.vtkPoints,System.Int32)">
            <summary>
                <para>Initialize the point insertion process. The newPts is an object representing point coordinates into which incremental insertion methods place their data. The points are associated with the edge.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.IsEdge(System.Int32,System.Int32)">
            <summary>
                <para>Return an integer id for the edge, or an attribute id of the edge (p1,p2) if the edge has been previously defined (it depends upon which version of InsertEdge() is being used); otherwise -1. The unique integer id can be used to set and retrieve attributes to the edge.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.InsertEdge(System.Int32,System.Int32,System.IntPtr)">
            <summary>
                <para>Insert the edge (p1,p2) into the table with the attribute id specified (make sure the attributeId &gt;= 0). Note that the attributeId is ignored if the storeAttributes variable was set to 0 in the InitEdgeInsertion() method. It is the user's responsibility to check if the edge has already been inserted (use IsEdge()). Do not mix this method with the other two InsertEdge() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.InsertEdge(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Insert the edge (p1,p2) into the table with the attribute id specified (make sure the attributeId &gt;= 0). Note that the attributeId is ignored if the storeAttributes variable was set to 0 in the InitEdgeInsertion() method. It is the user's responsibility to check if the edge has already been inserted (use IsEdge()). Do not mix this method with the other two InsertEdge() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.InsertEdge(System.Int32,System.Int32)">
            <summary>
                <para>Insert the edge (p1,p2) into the table. It is the user's responsibility to check if the edge has already been inserted (use IsEdge()). If the storeAttributes flag in InitEdgeInsertion() has been set, then the method returns a unique integer id (i.e., the edge id) that can be used to set and get edge attributes. Otherwise, the method will return 1. Do not mix this method with the InsertEdge() method that follows.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.InitEdgeInsertion(System.Int32,System.Int32)">
            <summary>
                <para>Initialize the edge insertion process. Provide an estimate of the number of points in a dataset (the maximum range value of p1 or p2).  The storeAttributes variable controls whether attributes are to be stored with the edge, and what type of attributes. If storeAttributes==1, then attributes of vtkIdType can be stored. If storeAttributes==2, then attributes of type void* can be stored. In either case, additional memory will be required by the data structure to store attribute data per each edge.  This method is used in conjunction with one of the three InsertEdge() methods described below (don't mix the InsertEdge() methods---make sure that the one used is consistent with the storeAttributes flag set in InitEdgeInsertion()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEdgeTable.Initialize">
            <summary>
                <para>Free memory and return to the initially instantiated state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGeneralTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.GetMTime">
            <summary>
                <para>Override GetMTime to account for input and concatenation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.MakeTransform">
            <summary>
                <para>Make another transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.CircuitCheck(vtk.vtkAbstractTransform)">
            <summary>
                <para>Check for self-reference.  Will return true if concatenating with the specified transform, setting it to be our inverse, or setting it to be our input will create a circular reference. CircuitCheck is automatically called by SetInput(), SetInverse(), and Concatenate(vtkXTransform *).  Avoid using this function, it is experimental.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.InternalTransformDerivative(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>This will calculate the transformation as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.InternalTransformDerivative(System.Single[],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>This will calculate the transformation as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.InternalTransformPoint(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.InternalTransformPoint(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Pop">
            <summary>
                <para>Deletes the transformation on the top of the stack and sets the top  to the next transformation on the stack.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Push">
            <summary>
                <para>Pushes the current transformation onto the transformation stack.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.GetInverseFlag">
            <summary>
                <para>Get the inverse flag of the transformation.  This controls whether it is the Input or the inverse of the Input that is used as the base transformation.  The InverseFlag is flipped every time Inverse() is called.  The InverseFlag is off when a transform is first created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.GetInput">
            <summary>
                <para>Set the input for this transformation.  This will be used as the base transformation if it is set.  This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly.  Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.SetInput(vtk.vtkAbstractTransform)">
            <summary>
                <para>Set the input for this transformation.  This will be used as the base transformation if it is set.  This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly.  Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.GetNumberOfConcatenatedTransforms">
            <summary>
                <para>Get the total number of transformations that are linked into this one via Concatenate() operations or via SetInput().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.PostMultiply">
            <summary>
                <para>Sets the internal state of the transform to PostMultiply. All subsequent operations will occur after those already represented in the current transformation.  In homogeneous matrix notation, M = A*M where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.PreMultiply">
            <summary>
                <para>Sets the internal state of the transform to PreMultiply. All subsequent operations will occur before those already represented in the current transformation.  In homogeneous matrix notation, M = M*A where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Concatenate(vtk.vtkAbstractTransform)">
            <summary>
                <para>Concatenate the specified transform with the current transformation according to PreMultiply or PostMultiply semantics. The concatenation is pipelined, meaning that if any of the transformations are changed, even after Concatenate() is called, those changes will be reflected when you call TransformPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Concatenate(System.Double[])">
            <summary>
                <para>Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Concatenate(vtk.vtkMatrix4x4)">
            <summary>
                <para>Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Scale(System.Single[])">
            <summary>
                <para>Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Scale(System.Double[])">
            <summary>
                <para>Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Scale(System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.RotateZ(System.Double)">
            <summary>
                <para>Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  The angle is expressed in degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.RotateY(System.Double)">
            <summary>
                <para>Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  The angle is expressed in degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.RotateX(System.Double)">
            <summary>
                <para>Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  The angle is expressed in degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.RotateWXYZ(System.Double,System.Single[])">
            <summary>
                <para>Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.RotateWXYZ(System.Double,System.Double[])">
            <summary>
                <para>Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.RotateWXYZ(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Translate(System.Single[])">
            <summary>
                <para>Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Translate(System.Double[])">
            <summary>
                <para>Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Translate(System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Inverse">
            <summary>
                <para>Invert the transformation.  This will also set a flag so that the transformation will use the inverse of its Input, if an Input has been set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGeneralTransform.Identity">
            <summary>
                <para>Set this transformation to the identity transformation.  If  the transform has an Input, then the transformation will be reset so that it is the same as the Input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTypeInt16Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt16Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt16Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeInt16Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeInt16Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt16Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPriorityQueue.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.Reset">
            <summary>
                <para>Empty the queue but without releasing memory. This avoids the overhead of memory allocation/deletion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.GetNumberOfItems">
            <summary>
                <para>Return the number of items in this queue.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.GetPriority(System.Int32)">
            <summary>
                <para>Get the priority of an entry in the queue with specified id. Returns priority value of that id or VTK_DOUBLE_MAX if not in queue.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.DeleteId(System.Int32)">
            <summary>
                <para>Delete entry in queue with specified id. Returns priority value associated with that id; or VTK_DOUBLE_MAX if not in queue.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.Peek(System.Int32)">
            <summary>
                <para>Peek into the queue without actually removing anything. Returns the id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.Pop(System.Int32)">
            <summary>
                <para>Same as above but simplified for easier wrapping into interpreted languages.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.Insert(System.Double,System.Int32)">
            <summary>
                <para>Insert id with priority specified. The id is generally an index like a point id or cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPriorityQueue.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate initial space for priority queue.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricKlein.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricKlein.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricKlein.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricKlein.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricKlein.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricKlein.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricKlein.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricKlein.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>A Klein bottle.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricKlein.GetDimension">
            <summary>
                <para>A Klein bottle.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.SetMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>@deprecated This method is deprecated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.MakeTransform">
            <summary>
                <para>Make a new transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.GetMTime">
            <summary>
                <para>Get the MTime: this is the bit of magic that makes everything work.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.Inverse">
            <summary>
                <para>The input matrix is left as-is, but the transformation matrix is inverted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.GetInput">
            <summary>
                <para>Set the input matrix.  Any modifications to the matrix will be reflected in the transformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToLinearTransform.SetInput(vtk.vtkMatrix4x4)">
            <summary>
                <para>Set the input matrix.  Any modifications to the matrix will be reflected in the transformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInstantiator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInstantiator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInstantiator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInstantiator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInstantiator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInstantiator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInstantiator.CreateInstance(System.String)">
            <summary>
                <para>Create an instance of the class whose name is given.  If creation fails, a NULL pointer is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStringArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStringArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStringArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStringArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStringArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStringArray.GetActualMemorySize">
            <summary>
                <para>Return the memory in kilobytes consumed by this data array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The  information returned is valid only after the pipeline has  been updated.</para>
                <para>This function takes into account the size of the contents of the strings as well as the string containers themselves.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.InsertNextValue(System.String)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.InsertValue(System.Int32,System.String)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.GetElementComponentSize">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.SetValue(System.Int32,System.String)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.GetValue(System.Int32)">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate memory for this array. Delete old storage only if necessary. Note that ext is no longer used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.CopyValue(System.Int32,System.Int32,vtk.vtkAbstractArray)">
            <summary>
                <para>Copy a value from a given source array into this array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.GetValues(System.Int32,System.Int32,vtk.vtkAbstractArray)">
            <summary>
                <para>Get the values for the range of indices specified (i.e., p1-&gt;p2 inclusive). You must insure that the output array has been previously allocated with enough space to hold the data and that the type of the output array is compatible with the type of this array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.GetValues(vtk.vtkIdList,vtk.vtkAbstractArray)">
            <summary>
                <para>Given a list of indices, return an array of values.  You must insure that the output array has been previously allocated with enough space to hold the data and that the types match sufficiently to allow conversion (if necessary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.Resize(System.Int32)">
            <summary>
                <para>Resize the array while conserving the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.Squeeze">
            <summary>
                <para>Resize the array while conserving the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.GetDataTypeSize">
            <summary>
                <para>Return the size of the data type.  WARNING: This may not mean what you expect with strings.  It will return sizeof(vtkstd::string) and not take into account the data included in any particular string.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStringArray.Initialize">
            <summary>
                <para>Release storage and reset array to initial state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAbstractArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.ConvertFromContiguous(vtk.vtkDataArray,vtk.vtkIdTypeArray)">
            <summary>
                <para>This is the inverse of ConvertToContiguous(), above.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetDataTypeAsString">
            <summary>
                <para>This method is here to make backward compatibility easier.  It must return true if and only if an array contains numeric data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetName">
            <summary>
                <para>Set/get array's name</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.SetName(System.String)">
            <summary>
                <para>Set/get array's name</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetActualMemorySize">
            <summary>
                <para>Return the memory in kilobytes consumed by this data array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The  information returned is valid only after the pipeline has  been updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.SetVoidArray(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                <para>This method lets the user specify data to be held by the array.  The  array argument is a pointer to the data.  size is the size of  the array supplied by the user.  Set save to 1 to keep the class from deleting the array when it cleans up or reallocates memory. The class uses the actual array provided; it does not copy the data  from the supplied array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetMaxId">
            <summary>
                <para>This method lets the user specify data to be held by the array.  The  array argument is a pointer to the data.  size is the size of  the array supplied by the user.  Set save to 1 to keep the class from deleting the array when it cleans up or reallocates memory. The class uses the actual array provided; it does not copy the data  from the supplied array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetSize">
            <summary>
                <para>What is the maximum id currently in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.Reset">
            <summary>
                <para>Return the size of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.Resize(System.Int32)">
            <summary>
                <para>Resize the array while conserving the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.Squeeze">
            <summary>
                <para>Resize object to just fit data requirement. Reclaims extra memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.CopyValue(System.Int32,System.Int32,vtk.vtkAbstractArray)">
            <summary>
                <para>Copy an element from one array into an element on this array.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.DeepCopy(vtk.vtkAbstractArray)">
            <summary>
                <para>Deep copy of data. Implementation left to subclasses, which should support as many type conversions as possible given the data type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetVoidPointer(System.Int32)">
            <summary>
                <para>Return a void pointer. For image pipeline interface and other  special pointer manipulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetElementComponentSize">
            <summary>
                <para>Return the size, in bytes, of the lowest-level element of an array.  For vtkDataArray and subclasses this is the size of the data type.  For vtkStringArray, this is sizeof(vtkStdString::value_type), which winds up being sizeof(char).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetNumberOfElementComponents">
            <summary>
                <para>Return the number of components in a single element of the array. For vtkDataArray and its subclasses, this is the number of components in a tuple.  Arrays with variable-length elements (such as vtkStringArray and vtkCellArray) should return 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetValues(System.Int32,System.Int32,vtk.vtkAbstractArray)">
            <summary>
                <para>Get the values for the range of indices specified (i.e., p1-&gt;p2 inclusive). You must insure that the output array has been previously allocated with enough space to hold the data and that the type of the output array is compatible with the type of this array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetValues(vtk.vtkIdList,vtk.vtkAbstractArray)">
            <summary>
                <para>Given a list of indices, return an array of values.  The caller must ensure that enough room has been allocated within the output array to hold the data and that the data types match well enough to allow any necessary conversions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetDataTypeSize(System.Int32)">
            <summary>
                <para>Return the size of the underlying data type.  For a bit, 0 is returned.  XXX FIXME How will this method behave for variably-sized objects?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetDataTypeSize">
            <summary>
                <para>Return the size of the underlying data type.  For a bit, 0 is returned.  XXX FIXME How will this method behave for variably-sized objects?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.GetDataType">
            <summary>
                <para>Return the underlying data type. An integer indicating data type is  returned as specified in vtkSetGet.h.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.Initialize">
            <summary>
                <para>Release storage and reset array to initial state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractArray.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate memory for this array. Delete old storage only if necessary. Note that ext is no longer used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLongLongArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.InsertNextValue(System.Int64)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.InsertValue(System.Int32,System.Int64)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.SetValue(System.Int32,System.Int64)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.InsertNextTupleValue(System.Int64[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.InsertTupleValue(System.Int32,System.Int64[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.SetTupleValue(System.Int32,System.Int64[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.GetTupleValue(System.Int32,System.Int64[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLongLongArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCollectionIterator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.GetObject">
            <summary>
                <para>@deprecated Replaced by vtkCollectionIterator::GetCurrentObject() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.GetCurrentObject">
            <summary>
                <para>Get the item at the current iterator position.  Valid only when IsDoneWithTraversal() returns 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.IsDoneWithTraversal">
            <summary>
                <para>Test whether the iterator is currently positioned at a valid item. Returns 1 for yes, 0 for no.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.GoToNextItem">
            <summary>
                <para>Move the iterator to the next item in the collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.GoToFirstItem">
            <summary>
                <para>Position the iterator at the first item in the collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.InitTraversal">
            <summary>
                <para>Position the iterator at the first item in the collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.GetCollection">
            <summary>
                <para>Set/Get the collection over which to iterate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollectionIterator.SetCollection(vtk.vtkCollection)">
            <summary>
                <para>Set/Get the collection over which to iterate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMutexLock.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMutexLock.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMutexLock.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMutexLock.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMutexLock.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMutexLock.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMutexLock.Unlock">
            <summary>
                <para>Unlock the vtkMutexLock</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMutexLock.Lock">
            <summary>
                <para>Lock the vtkMutexLock</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTypeUInt8Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt8Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt8Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeUInt8Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeUInt8Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt8Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricEnneper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricEnneper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricEnneper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricEnneper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricEnneper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricEnneper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricEnneper.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uv are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEnneper.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Enneper's surface.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEnneper.GetDimension">
            <summary>
                <para>Enneper's surface.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVoidArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVoidArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVoidArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVoidArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVoidArray.DeepCopy(vtk.vtkVoidArray)">
            <summary>
                <para>Deep copy of another void array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.Squeeze">
            <summary>
                <para>Get the address of a particular data index. Performs no checks to verify that the memory has been allocated etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.Reset">
            <summary>
                <para>Resize the array to just fit the inserted memory. Reclaims extra memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.InsertNextVoidPointer(System.IntPtr)">
            <summary>
                <para>Insert (memory allocation performed) the void* pointer at the  end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.InsertVoidPointer(System.Int32,System.IntPtr)">
            <summary>
                <para>Insert (memory allocation performed) the void* into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.SetVoidPointer(System.Int32,System.IntPtr)">
            <summary>
                <para>Insert (memory allocation performed) the void* into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.GetVoidPointer(System.Int32)">
            <summary>
                <para>Set the void* pointer value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.GetNumberOfPointers">
            <summary>
                <para>Get the void* pointer at the ith location.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.SetNumberOfPointers(System.Int32)">
            <summary>
                <para>Get the number of void* pointers held in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.GetDataTypeSize">
            <summary>
                <para>Set the number of void* pointers held in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.GetDataType">
            <summary>
                <para>Return the size of the data contained in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.Initialize">
            <summary>
                <para>Release storage and reset array to initial state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVoidArray.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate memory for this array. Delete old storage only if necessary. Note that the parameter ext is no longer used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTimerLog.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTimerLog.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTimerLog.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTimerLog.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetCurrentTime">
            <summary>
                <para>@deprecated Replaced by vtkTimerLog::GetUniversalTime() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetElapsedTime">
            <summary>
                <para>Returns the difference between StartTime and EndTime as  a doubleing point value indicating the elapsed time in seconds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.StopTimer">
            <summary>
                <para>Sets EndTime to the current time. Used with GetElapsedTime().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.StartTimer">
            <summary>
                <para>Set the StartTime to the current time. Used with GetElapsedTime().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetCPUTime">
            <summary>
                <para>Returns the CPU time for this process On Win32 platforms this actually returns wall time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetUniversalTime">
            <summary>
                <para>Returns the elapsed number of seconds since January 1, 1970. This is also called Universal Coordinated Time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.CleanupLog">
            <summary>
                <para>Remove timer log.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.AllocateLog">
            <summary>
                <para>Allocate timing table with MaxEntries elements.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.ResetLog">
            <summary>
                <para>Clear the timing table.  walltime and cputime will also be set to zero when the first new event is recorded.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.MarkEvent(System.String)">
            <summary>
                <para>Record a timing event and capture wall time and cpu ticks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetEventString(System.Int32)">
            <summary>
                <para>Programatic access to events.  Indexed from 0 to num-1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetEventWallTime(System.Int32)">
            <summary>
                <para>Programatic access to events.  Indexed from 0 to num-1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetEventIndent(System.Int32)">
            <summary>
                <para>Programatic access to events.  Indexed from 0 to num-1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetNumberOfEvents">
            <summary>
                <para>Programatic access to events.  Indexed from 0 to num-1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.MarkEndEvent(System.String)">
            <summary>
                <para>I want to time events, so I am creating this interface to mark events that have a start and an end.  These events can be, nested. The standard Dumplog ignores the indents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.MarkStartEvent(System.String)">
            <summary>
                <para>I want to time events, so I am creating this interface to mark events that have a start and an end.  These events can be, nested. The standard Dumplog ignores the indents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.DumpLog(System.String)">
            <summary>
                <para>Write the timing table out to a file.  Calculate some helpful statistics (deltas and  percentages) in the process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetMaxEntries">
            <summary>
                <para>Set/Get the maximum number of entries allowed in the timer log</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.SetMaxEntries(System.Int32)">
            <summary>
                <para>Set/Get the maximum number of entries allowed in the timer log</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.LoggingOff">
            <summary>
                <para>Set/Get the maximum number of entries allowed in the timer log</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.LoggingOn">
            <summary>
                <para>This flag will turn loging of events off or on.   By default, logging is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.GetLogging">
            <summary>
                <para>This flag will turn loging of events off or on.   By default, logging is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTimerLog.SetLogging(System.Int32)">
            <summary>
                <para>This flag will turn loging of events off or on.   By default, logging is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMultiPartExtentTranslator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMultiPartExtentTranslator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMultiPartExtentTranslator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMultiPartExtentTranslator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMultiPartExtentTranslator.PieceToExtentThreadSafe(System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
                <para>These are the main methods that should be called. These methods  are responsible for converting a piece to an extent. The signatures without arguments are only thread safe when each thread accesses a different instance. The signatures with arguements are fully thread safe. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkReferenceCount.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkReferenceCount.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkReferenceCount.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkReferenceCount.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkReferenceCount.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkReferenceCount.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt16Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt16Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt16Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeUInt16Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeUInt16Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeUInt16Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the Cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Construct a terrain consisting of randomly placed hills on a surface. </para>
                <para>It is assumed that the function GenerateTheHills() has been executed to build the vectors of coordinates required to generate the point Pt. Pt represents the sum of all the amplitudes over the space.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GenerateTheHills">
            <summary>
                <para>Generate the centers of the hills, their standard deviations and  their amplitudes. This function creates a series of vectors representing the u, v coordinates of each hill, its variance in the u, v directions and the amplitude.</para>
                <para>NOTE: This function must be called whenever any of the parameters are changed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetAmplitudeScaleFactor">
            <summary>
                <para>Set/Get the scaling factor for the amplitude.  Default is 1/3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.SetAmplitudeScaleFactor(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the amplitude.  Default is 1/3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetYVarianceScaleFactor">
            <summary>
                <para>Set/Get the scaling factor for the variance in the y-direction.  Default is 1/3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.SetYVarianceScaleFactor(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the variance in the y-direction.  Default is 1/3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetXVarianceScaleFactor">
            <summary>
                <para>Set/Get the scaling factor for the variance in the x-direction.  Default is 1/3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.SetXVarianceScaleFactor(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the variance in the x-direction.  Default is 1/3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.AllowRandomGenerationOff">
            <summary>
                <para>Set/Get the random generation flag.  A value of 0 will disable the generation of random hills on the surface.  This allows a reproducible shape to be generated. Any other value means that the generation of the hills will be done randomly. Default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.AllowRandomGenerationOn">
            <summary>
                <para>Set/Get the random generation flag.  A value of 0 will disable the generation of random hills on the surface.  This allows a reproducible shape to be generated. Any other value means that the generation of the hills will be done randomly. Default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetAllowRandomGeneration">
            <summary>
                <para>Set/Get the random generation flag.  A value of 0 will disable the generation of random hills on the surface.  This allows a reproducible shape to be generated. Any other value means that the generation of the hills will be done randomly. Default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.SetAllowRandomGeneration(System.Int32)">
            <summary>
                <para>Set/Get the random generation flag.  A value of 0 will disable the generation of random hills on the surface.  This allows a reproducible shape to be generated. Any other value means that the generation of the hills will be done randomly. Default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetRandomSeed">
            <summary>
                <para>Set/Get the Seed for the random number generator,  a value of 1 will initialize the random number generator,  a negative value will initialize it with the system time. Default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.SetRandomSeed(System.Int32)">
            <summary>
                <para>Set/Get the Seed for the random number generator,  a value of 1 will initialize the random number generator,  a negative value will initialize it with the system time. Default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetHillAmplitude">
            <summary>
                <para>Set/Get the hill amplitude (height). Default is 2.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.SetHillAmplitude(System.Double)">
            <summary>
                <para>Set/Get the hill amplitude (height). Default is 2.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetHillYVariance">
            <summary>
                <para>Set/Get the hill variance in the y-direction. Default is 2.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.SetHillYVariance(System.Double)">
            <summary>
                <para>Set/Get the hill variance in the y-direction. Default is 2.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetHillXVariance">
            <summary>
                <para>Set/Get the hill variance in the x-direction. Default is 2.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.SetHillXVariance(System.Double)">
            <summary>
                <para>Set/Get the hill variance in the x-direction. Default is 2.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetNumberOfHills">
            <summary>
                <para>Set/Get the number of hills. Default is 30.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.SetNumberOfHills(System.Int32)">
            <summary>
                <para>Set/Get the number of hills. Default is 30.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRandomHills.GetDimension">
            <summary>
                <para>Construct a surface of random hills with the following parameters: MinimumU = -10, MaximumU = 10, MinimumV = -10, MaximumV = 10,  JoinU = 0, JoinV = 0, TwistU = 0, TwistV = 0; ClockwiseOrdering = 1,  DerivativesAvailable = 0, Number of hills = 30,  Variance of the hills 2.5 in both x- and y- directions,  Scaling factor for the variances 1/3 in both x- and y- directions,  Amplitude of each hill = 1,  Scaling factor for the amplitude = 1/3,  RandomSeed = 1, AllowRandomGeneration = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPlanes.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPlanes.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPlanes.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPlanes.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPlanes.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPlanes.GetPlane(System.Int32,vtk.vtkPlane)">
            <summary>
                <para>Create and return a pointer to a vtkPlane object at the ith position. Asking for a plane outside the allowable range returns NULL. This method always returns the same object.  Use GetPlane(int i, vtkPlane *plane) instead</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.GetPlane(System.Int32)">
            <summary>
                <para>Create and return a pointer to a vtkPlane object at the ith position. Asking for a plane outside the allowable range returns NULL. This method always returns the same object.  Use GetPlane(int i, vtkPlane *plane) instead</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.GetNumberOfPlanes">
            <summary>
                <para>Return the number of planes in the set of planes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.SetBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>An alternative method to specify six planes defined by a bounding box. The bounding box is a six-vector defined as (xmin,xmax,ymin,ymax,zmin,zmax). It defines six planes orthogonal to the x-y-z coordinate axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.SetBounds(System.Double[])">
            <summary>
                <para>An alternative method to specify six planes defined by a bounding box. The bounding box is a six-vector defined as (xmin,xmax,ymin,ymax,zmin,zmax). It defines six planes orthogonal to the x-y-z coordinate axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.SetFrustumPlanes(System.Double[])">
            <summary>
                <para>An alternative method to specify six planes defined by the camera view  frustrum. See vtkCamera::GetFrustumPlanes() documentation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.GetNormals">
            <summary>
                <para>Specify a list of normal vectors for the planes. There is a one-to-one correspondence between plane points and plane normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.SetNormals(vtk.vtkDataArray)">
            <summary>
                <para>Specify a list of normal vectors for the planes. There is a one-to-one correspondence between plane points and plane normals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.GetPoints">
            <summary>
                <para>Specify a list of points defining points through which the planes pass.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlanes.SetPoints(vtk.vtkPoints)">
            <summary>
                <para>Specify a list of points defining points through which the planes pass.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSphericalTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSphericalTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSphericalTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSphericalTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSphericalTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSphericalTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSphericalTransform.MakeTransform">
            <summary>
                <para>Make another transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDebugLeaks.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.SetExitError(System.Int32)">
            <summary>
                <para>Get/Set flag for exiting with an error when leaks are present. Default is on when testing and off otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.GetExitError">
            <summary>
                <para>Get/Set flag for exiting with an error when leaks are present. Default is on when testing and off otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.PromptUserOff">
            <summary>
                <para>@deprecated Turn prompt at exit on/off (this setting is deprecated  and will be ignored).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.PromptUserOn">
            <summary>
                <para>@deprecated Turn prompt at exit on/off (this setting is deprecated  and will be ignored).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.PrintCurrentLeaks">
            <summary>
                <para>Print all the values in the table.  Returns non-zero if there were leaks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.DestructClass(System.String)">
            <summary>
                <para>Call this when deleting a class of a given name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDebugLeaks.ConstructClass(System.String)">
            <summary>
                <para>Call this when creating a class of a given name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricBoy.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Boy's surface.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.GetZScale">
            <summary>
                <para>Set/Get the scale factor for the z-coordinate.  Default = 1/8, giving a nice shape.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.SetZScale(System.Double)">
            <summary>
                <para>Set/Get the scale factor for the z-coordinate.  Default = 1/8, giving a nice shape.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricBoy.GetDimension">
            <summary>
                <para>Set/Get the scale factor for the z-coordinate.  Default = 1/8, giving a nice shape.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkShortArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkShortArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkShortArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkShortArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkShortArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkShortArray.InsertNextValue(System.Int16)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.InsertValue(System.Int32,System.Int16)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.SetValue(System.Int32,System.Int16)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.InsertNextTupleValue(System.Int16[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.InsertTupleValue(System.Int32,System.Int16[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.SetTupleValue(System.Int32,System.Int16[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.GetTupleValue(System.Int32,System.Int16[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkShortArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWindow.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWindow.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWindow.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWindow.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWindow.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWindow.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWindow.GetTileViewport">
            <summary>
                <para>These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetTileViewport(System.Double[])">
            <summary>
                <para>These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetTileViewport(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetTileScale(System.Int32)">
            <summary>
                <para>These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetTileScale">
            <summary>
                <para>These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetTileScale(System.Int32[])">
            <summary>
                <para>These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetTileScale(System.Int32,System.Int32)">
            <summary>
                <para>These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.MakeCurrent">
            <summary>
                <para>Make the window current. May be overridden in subclasses to do for example a glXMakeCurrent or a wglMakeCurrent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.OffScreenRenderingOff">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.OffScreenRenderingOn">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetOffScreenRendering">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetOffScreenRendering(System.Int32)">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetDPIMaxValue">
            <summary>
                <para>Return a best estimate to the dots per inch of the display device being rendered (or printed).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetDPIMinValue">
            <summary>
                <para>Return a best estimate to the dots per inch of the display device being rendered (or printed).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetDPI(System.Int32)">
            <summary>
                <para>Return a best estimate to the dots per inch of the display device being rendered (or printed).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetDPI">
            <summary>
                <para>Return a best estimate to the dots per inch of the display device being rendered (or printed).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Get the pixel data of an image, transmitted as RGBRGBRGB. The front argument indicates if the front buffer should be used or the back  buffer. It is the caller's responsibility to delete the resulting  array. It is very important to realize that the memory in this array is organized from the bottom of the window to the top. The origin of the screen is in the lower left corner. The y axis increases as you go up the screen. So the storage of pixels is from left to right and from bottom to top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.Render">
            <summary>
                <para>Ask each viewport owned by this Window to render its image and  synchronize this process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetWindowName(System.String)">
            <summary>
                <para>Get name of rendering window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetWindowName">
            <summary>
                <para>Get name of rendering window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.DoubleBufferOff">
            <summary>
                <para>Keep track of whether double buffering is on or off</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.DoubleBufferOn">
            <summary>
                <para>Keep track of whether double buffering is on or off</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetDoubleBuffer">
            <summary>
                <para>Keep track of whether double buffering is on or off</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetDoubleBuffer(System.Int32)">
            <summary>
                <para>Keep track of whether double buffering is on or off</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.EraseOff">
            <summary>
                <para>Turn on/off erasing the screen between images. This allows multiple  exposure sequences if turned on. You will need to turn double  buffering off or make use of the SwapBuffers methods to prevent you from swapping buffers between exposures.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.EraseOn">
            <summary>
                <para>Turn on/off erasing the screen between images. This allows multiple  exposure sequences if turned on. You will need to turn double  buffering off or make use of the SwapBuffers methods to prevent you from swapping buffers between exposures.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetErase">
            <summary>
                <para>Turn on/off erasing the screen between images. This allows multiple  exposure sequences if turned on. You will need to turn double  buffering off or make use of the SwapBuffers methods to prevent you from swapping buffers between exposures.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetErase(System.Int32)">
            <summary>
                <para>Turn on/off erasing the screen between images. This allows multiple  exposure sequences if turned on. You will need to turn double  buffering off or make use of the SwapBuffers methods to prevent you from swapping buffers between exposures.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.MappedOff">
            <summary>
                <para>Keep track of whether the rendering window has been mapped to screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.MappedOn">
            <summary>
                <para>Keep track of whether the rendering window has been mapped to screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetMapped">
            <summary>
                <para>Keep track of whether the rendering window has been mapped to screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetMapped(System.Int32)">
            <summary>
                <para>Keep track of whether the rendering window has been mapped to screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetSize(System.Int32[])">
            <summary>
                <para>Set/Get the size of the window in screen coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetSize(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the size of the window in screen coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetSize">
            <summary>
                <para>Set/Get the size of the window in screen coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetPosition(System.Int32[])">
            <summary>
                <para>Set/Get the position in screen coordinates of the rendering window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetPosition(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the position in screen coordinates of the rendering window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetPosition">
            <summary>
                <para>Set/Get the position in screen coordinates of the rendering window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetParentInfo(System.String)">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetWindowInfo(System.String)">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetGenericDrawable">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetGenericContext">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetGenericParentId">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetGenericWindowId">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.GetGenericDisplayId">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetParentId(System.IntPtr)">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetWindowId(System.IntPtr)">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindow.SetDisplayId(System.IntPtr)">
            <summary>
                <para>These are window system independent methods that are used to help interface vtkWindow to native windowing systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricTorus.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the Cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>A torus.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.GetDimension">
            <summary>
                <para>A torus.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.GetCrossSectionRadius">
            <summary>
                <para>Set/Get the radius of the cross section of ring of the torus.  The default value is 0.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.SetCrossSectionRadius(System.Double)">
            <summary>
                <para>Set/Get the radius of the cross section of ring of the torus.  The default value is 0.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.GetRingRadius">
            <summary>
                <para>Set/Get the radius from the center to the middle of the ring of the torus.  The default value is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricTorus.SetRingRadius(System.Double)">
            <summary>
                <para>Set/Get the radius from the center to the middle of the ring of the torus.  The default value is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.DeepCopy(vtk.vtkStructuredVisibilityConstraint)">
            <summary>
                <para>Copies the dimensions, the visibility array  and the initialized flag.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.ShallowCopy(vtk.vtkStructuredVisibilityConstraint)">
            <summary>
                <para>Copies the dimensions, the visibility array pointer and the initialized flag.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.GetVisibilityById">
            <summary>
                <para>Set/Get the array used to store the visibility flags.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.SetVisibilityById(vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Set/Get the array used to store the visibility flags.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.Initialize(System.Int32[])">
            <summary>
                <para>Set the dimensions and set the Initialized flag to 1. Once an object is initialized, it's dimensions can not be changed anymore.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.GetDimensions">
            <summary>
                <para>Get the dimensions used to initialize the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.UnBlank(System.Int32)">
            <summary>
                <para>Sets the visibility flag of the given point/cell on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.Blank(System.Int32)">
            <summary>
                <para>Sets the visibility flag of the given point/cell off. The first time blank is called, a new visibility array is created if it doesn't exist.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredVisibilityConstraint.IsVisible(System.Int32)">
            <summary>
                <para>Returns 1 is the point/cell is visible, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.InsertNextValue(System.UInt16)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.InsertValue(System.Int32,System.UInt16)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.SetValue(System.Int32,System.UInt16)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.InsertNextTupleValue(System.UInt16[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.InsertTupleValue(System.Int32,System.UInt16[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.SetTupleValue(System.Int32,System.UInt16[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.GetTupleValue(System.Int32,System.UInt16[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedShortArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>An ellipsoid.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.GetZRadius">
            <summary>
                <para>Set/Get the scaling factor for the z-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.SetZRadius(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the z-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.GetYRadius">
            <summary>
                <para>Set/Get the scaling factor for the y-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.SetYRadius(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the y-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.GetXRadius">
            <summary>
                <para>Set/Get the scaling factor for the x-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.SetXRadius(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the x-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricEllipsoid.GetDimension">
            <summary>
                <para>Set/Get the scaling factor for the x-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeFloat32Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeFloat32Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeFloat32Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeFloat32Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeFloat32Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeFloat32Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.GetPieceAvailable(System.Int32)">
            <summary>
                <para>Get/Set whether the given piece is available.  Requesting a piece that is not available will produce errors in the pipeline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.SetPieceAvailable(System.Int32,System.Int32)">
            <summary>
                <para>Get/Set whether the given piece is available.  Requesting a piece that is not available will produce errors in the pipeline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.GetMaximumGhostLevel">
            <summary>
                <para>Set the maximum ghost level that can be requested.  This can be used by a reader to make sure an extent request does not go outside the boundaries of the piece's file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.SetMaximumGhostLevel(System.Int32)">
            <summary>
                <para>Set the maximum ghost level that can be requested.  This can be used by a reader to make sure an extent request does not go outside the boundaries of the piece's file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.GetExtentForPiece(System.Int32,System.Int32[])">
            <summary>
                <para>Get the extent table entry for the given piece.  This is only for code that is setting up the table.  Extent translation should always be done through the PieceToExtent method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.SetExtentForPiece(System.Int32,System.Int32[])">
            <summary>
                <para>Set the extent to be used for a piece.  This sets the extent table entry for the piece.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.PieceToExtentThreadSafe(System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
                <para>Not supported by this subclass of vtkExtentTranslator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.PieceToExtentByPoints">
            <summary>
                <para>Not supported by this subclass of vtkExtentTranslator.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.PieceToExtent">
            <summary>
                <para>Called to translate the current piece into an extent.  This is not thread safe.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.GetNumberOfPiecesInTable">
            <summary>
                <para>Set the real number of pieces in the extent table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTableExtentTranslator.SetNumberOfPiecesInTable(System.Int32)">
            <summary>
                <para>Set the real number of pieces in the extent table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataArraySelection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.CopySelections(vtk.vtkDataArraySelection)">
            <summary>
                <para>Copy the selections from the given vtkDataArraySelection instance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.RemoveAllArrays">
            <summary>
                <para>Remove all array entries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.GetArraySetting(System.Int32)">
            <summary>
                <para>Get whether the array at the given index is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.GetEnabledArrayIndex(System.String)">
            <summary>
                <para>Get the index of an array with the given name among those that are enabled.  Returns -1 if the array is not enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.GetArrayIndex(System.String)">
            <summary>
                <para>Get an index of the array containing name within the enabled arrays</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.GetArrayName(System.Int32)">
            <summary>
                <para>Get the name of the array entry at the given index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.GetNumberOfArraysEnabled">
            <summary>
                <para>Get the number of arrays that are enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.GetNumberOfArrays">
            <summary>
                <para>Get the number of arrays that currently have an entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.DisableAllArrays">
            <summary>
                <para>Disable all arrays that currently have an entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.EnableAllArrays">
            <summary>
                <para>Enable all arrays that currently have an entry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.ArrayExists(System.String)">
            <summary>
                <para>Return whether the array with the given name exists.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.ArrayIsEnabled(System.String)">
            <summary>
                <para>Return whether the array with the given name is enabled.  If there is no entry, the array is assumed to be disabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.DisableArray(System.String)">
            <summary>
                <para>Disable the array with the given name.  Creates a new entry if none exists.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArraySelection.EnableArray(System.String)">
            <summary>
                <para>Enable the array with the given name.  Creates a new entry if none exists.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFloatArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFloatArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFloatArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFloatArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFloatArray.InsertNextValue(System.Single)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.InsertValue(System.Int32,System.Single)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.SetValue(System.Int32,System.Single)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.InsertNextTupleValue(System.Single[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.InsertTupleValue(System.Int32,System.Single[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.SetTupleValue(System.Int32,System.Single[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.GetTupleValue(System.Int32,System.Single[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFloatArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCylindricalTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCylindricalTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCylindricalTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCylindricalTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCylindricalTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCylindricalTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCylindricalTransform.MakeTransform">
            <summary>
                <para>Make another transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWarpTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.TemplateTransformInverse(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>Do not use these methods.  They exists only as a work-around for internal templated functions (I really didn't want to make the Forward/Inverse methods public, is there a decent work around for this sort of thing?)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.TemplateTransformInverse(System.Single[],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>Do not use these methods.  They exists only as a work-around for internal templated functions (I really didn't want to make the Forward/Inverse methods public, is there a decent work around for this sort of thing?)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.TemplateTransformInverse(System.Double[],System.Double[])">
            <summary>
                <para>Do not use these methods.  They exists only as a work-around for internal templated functions (I really didn't want to make the Forward/Inverse methods public, is there a decent work around for this sort of thing?)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.TemplateTransformInverse(System.Single[],System.Single[])">
            <summary>
                <para>Do not use these methods.  They exists only as a work-around for internal templated functions (I really didn't want to make the Forward/Inverse methods public, is there a decent work around for this sort of thing?)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.TemplateTransformPoint(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>Do not use these methods.  They exists only as a work-around for internal templated functions (I really didn't want to make the Forward/Inverse methods public, is there a decent work around for this sort of thing?)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.TemplateTransformPoint(System.Single[],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>Do not use these methods.  They exists only as a work-around for internal templated functions (I really didn't want to make the Forward/Inverse methods public, is there a decent work around for this sort of thing?)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.TemplateTransformPoint(System.Double[],System.Double[])">
            <summary>
                <para>Do not use these methods.  They exists only as a work-around for internal templated functions (I really didn't want to make the Forward/Inverse methods public, is there a decent work around for this sort of thing?)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.TemplateTransformPoint(System.Single[],System.Single[])">
            <summary>
                <para>Do not use these methods.  They exists only as a work-around for internal templated functions (I really didn't want to make the Forward/Inverse methods public, is there a decent work around for this sort of thing?)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.InternalTransformDerivative(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>This will calculate the transformation, as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.InternalTransformDerivative(System.Single[],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>This will calculate the transformation, as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.InternalTransformPoint(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.InternalTransformPoint(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.GetInverseIterations">
            <summary>
                <para>Set the maximum number of iterations for the inverse transformation.  The default is 500, but usually only  2 to 5 iterations are used.  The inversion method is fairly robust, and it should converge for nearly all smooth transformations that do not fold back on themselves.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.SetInverseIterations(System.Int32)">
            <summary>
                <para>Set the maximum number of iterations for the inverse transformation.  The default is 500, but usually only  2 to 5 iterations are used.  The inversion method is fairly robust, and it should converge for nearly all smooth transformations that do not fold back on themselves.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.GetInverseTolerance">
            <summary>
                <para>Set the tolerance for inverse transformation. The default is 0.001.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.SetInverseTolerance(System.Double)">
            <summary>
                <para>Set the tolerance for inverse transformation. The default is 0.001.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.GetInverseFlag">
            <summary>
                <para>Get the inverse flag of the transformation.  This flag is set to zero when the transformation is first created, and is flipped each time Inverse() is called.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWarpTransform.Inverse">
            <summary>
                <para>Invert the transformation.  Warp transformations are usually inverted using an iterative technique such as Newton's method. The inverse transform is usually around five or six times as computationally expensive as the forward transform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtentTranslator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.GetSplitMode">
            <summary>
                <para>How should the streamer break up extents. Block mode tries to break an extent up into cube blocks.  It always chooses the largest axis to split. Slab mode first breaks up the Z axis.  If it gets to one slice, then it starts breaking up other axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetSplitModeToZSlab">
            <summary>
                <para>How should the streamer break up extents. Block mode tries to break an extent up into cube blocks.  It always chooses the largest axis to split. Slab mode first breaks up the Z axis.  If it gets to one slice, then it starts breaking up other axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetSplitModeToYSlab">
            <summary>
                <para>How should the streamer break up extents. Block mode tries to break an extent up into cube blocks.  It always chooses the largest axis to split. Slab mode first breaks up the Z axis.  If it gets to one slice, then it starts breaking up other axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetSplitModeToXSlab">
            <summary>
                <para>How should the streamer break up extents. Block mode tries to break an extent up into cube blocks.  It always chooses the largest axis to split. Slab mode first breaks up the Z axis.  If it gets to one slice, then it starts breaking up other axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetSplitModeToBlock">
            <summary>
                <para>How should the streamer break up extents. Block mode tries to break an extent up into cube blocks.  It always chooses the largest axis to split. Slab mode first breaks up the Z axis.  If it gets to one slice, then it starts breaking up other axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.PieceToExtentThreadSafe(System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
                <para>These are the main methods that should be called. These methods  are responsible for converting a piece to an extent. The signatures without arguments are only thread safe when each thread accesses a different instance. The signatures with arguements are fully thread safe. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.PieceToExtentByPoints">
            <summary>
                <para>These are the main methods that should be called. These methods  are responsible for converting a piece to an extent. The signatures without arguments are only thread safe when each thread accesses a different instance. The signatures with arguements are fully thread safe. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.PieceToExtent">
            <summary>
                <para>These are the main methods that should be called. These methods  are responsible for converting a piece to an extent. The signatures without arguments are only thread safe when each thread accesses a different instance. The signatures with arguements are fully thread safe. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.GetGhostLevel">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetGhostLevel(System.Int32)">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.GetNumberOfPieces">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetNumberOfPieces(System.Int32)">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.GetPiece">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetPiece(System.Int32)">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.GetExtent">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetExtent(System.Int32[])">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.GetWholeExtent">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetWholeExtent(System.Int32[])">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentTranslator.SetWholeExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the Piece/NumPieces. Set the WholeExtent and then call PieceToExtent. The result can be obtained from the Extent ivar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>A conic spiral surface.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.GetN">
            <summary>
                <para>Set/Get the C function coefficient (see equation below).  Default = 2.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.SetN(System.Double)">
            <summary>
                <para>Set/Get the C function coefficient (see equation below).  Default = 2.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.GetC">
            <summary>
                <para>Set/Get the B function coefficient (see equation below).  Default = 0.1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.SetC(System.Double)">
            <summary>
                <para>Set/Get the B function coefficient (see equation below).  Default = 0.1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.GetB">
            <summary>
                <para>Set/Get the A function coefficient (see equation below).  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.SetB(System.Double)">
            <summary>
                <para>Set/Get the A function coefficient (see equation below).  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.GetA">
            <summary>
                <para>Set/Get the scale factor.  Default = 0.2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.SetA(System.Double)">
            <summary>
                <para>Set/Get the scale factor.  Default = 0.2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricConicSpiral.GetDimension">
            <summary>
                <para>Set/Get the scale factor.  Default = 0.2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.SetMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>@deprecated This method is deprecated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.MakeTransform">
            <summary>
                <para>Make a new transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.GetMTime">
            <summary>
                <para>Get the MTime: this is the bit of magic that makes everything work.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrixToHomogeneousTransform.Inverse">
            <summary>
                <para>The input matrix is left as-is, but the transformation matrix is inverted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkIdList.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAssemblyNode.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.GetProp">
            <summary>
                <para>@deprecated Replaced by vtkAssemblyNode::GetViewProp() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.SetProp(vtk.vtkProp)">
            <summary>
                <para>@deprecated Replaced by vtkAssemblyNode::SetViewProp() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.GetMTime">
            <summary>
                <para>Override the standard GetMTime() to check for the modified times of the prop and matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.GetMatrix">
            <summary>
                <para>Specify a transformation matrix associated with the prop. Note: if the prop is not a type of vtkProp3D, then the transformation matrix is ignored (and expected to be NULL). Also, internal to this object the matrix is copied because the matrix is used for computation by vtkAssemblyPath.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.SetMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>Specify a transformation matrix associated with the prop. Note: if the prop is not a type of vtkProp3D, then the transformation matrix is ignored (and expected to be NULL). Also, internal to this object the matrix is copied because the matrix is used for computation by vtkAssemblyPath.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.GetViewProp">
            <summary>
                <para>Set/Get the prop that this assembly node refers to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyNode.SetViewProp(vtk.vtkProp)">
            <summary>
                <para>Set/Get the prop that this assembly node refers to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkByteSwap.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkByteSwap.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkByteSwap.SwapVoidRange(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                <para>Swaps the bytes of a buffer.  Uses an arbitrary word size, but assumes the word size is divisible by two.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap8BERange(System.IntPtr,System.Int32)">
            <summary>
                <para>Swap a block of 2-, 4-, or 8-byte segments for storage as Big Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap4BERange(System.IntPtr,System.Int32)">
            <summary>
                <para>Swap a block of 2-, 4-, or 8-byte segments for storage as Big Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap2BERange(System.IntPtr,System.Int32)">
            <summary>
                <para>Swap a block of 2-, 4-, or 8-byte segments for storage as Big Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap8BE(System.IntPtr)">
            <summary>
                <para>Swap 2, 4, or 8 bytes for storage as Big Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap4BE(System.IntPtr)">
            <summary>
                <para>Swap 2, 4, or 8 bytes for storage as Big Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap2BE(System.IntPtr)">
            <summary>
                <para>Swap 2, 4, or 8 bytes for storage as Big Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap8LERange(System.IntPtr,System.Int32)">
            <summary>
                <para>Swap a block of 2-, 4-, or 8-byte segments for storage as Little Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap4LERange(System.IntPtr,System.Int32)">
            <summary>
                <para>Swap a block of 2-, 4-, or 8-byte segments for storage as Little Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap2LERange(System.IntPtr,System.Int32)">
            <summary>
                <para>Swap a block of 2-, 4-, or 8-byte segments for storage as Little Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap8LE(System.IntPtr)">
            <summary>
                <para>Swap 2, 4, or 8 bytes for storage as Little Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap4LE(System.IntPtr)">
            <summary>
                <para>Swap 2, 4, or 8 bytes for storage as Little Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkByteSwap.Swap2LE(System.IntPtr)">
            <summary>
                <para>Swap 2, 4, or 8 bytes for storage as Little Endian.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTypeInt8Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt8Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt8Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeInt8Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeInt8Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt8Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt32Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt32Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt32Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeInt32Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeInt32Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeInt32Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.InsertNextValue(System.UInt32)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.InsertValue(System.Int32,System.UInt32)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.SetValue(System.Int32,System.UInt32)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.InsertNextTupleValue(System.UInt32[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.InsertTupleValue(System.Int32,System.UInt32[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.SetTupleValue(System.Int32,System.UInt32[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.GetTupleValue(System.Int32,System.UInt32[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedIntArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPlaneCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPlaneCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPlaneCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPlaneCollection.GetNextItem">
            <summary>
                <para>Get the next plane in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlaneCollection.AddItem(vtk.vtkPlane)">
            <summary>
                <para>Add a plane to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.DisplayTag(System.String)">
            <summary>
                <para>Put the text into the log file without processing it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.DisplayDebugText(System.String)">
            <summary>
                <para>Put the text into the log file. The text is processed to replace &amp;, &lt;, &gt; with &amp;amp, &amp;lt, and &amp;gt. Each display method outputs a different XML tag.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.DisplayGenericWarningText(System.String)">
            <summary>
                <para>Put the text into the log file. The text is processed to replace &amp;, &lt;, &gt; with &amp;amp, &amp;lt, and &amp;gt. Each display method outputs a different XML tag.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.DisplayWarningText(System.String)">
            <summary>
                <para>Put the text into the log file. The text is processed to replace &amp;, &lt;, &gt; with &amp;amp, &amp;lt, and &amp;gt. Each display method outputs a different XML tag.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.DisplayErrorText(System.String)">
            <summary>
                <para>Put the text into the log file. The text is processed to replace &amp;, &lt;, &gt; with &amp;amp, &amp;lt, and &amp;gt. Each display method outputs a different XML tag.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXMLFileOutputWindow.DisplayText(System.String)">
            <summary>
                <para>Put the text into the log file. The text is processed to replace &amp;, &lt;, &gt; with &amp;amp, &amp;lt, and &amp;gt. Each display method outputs a different XML tag.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32ProcessOutputWindow.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWin32ProcessOutputWindow.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWin32ProcessOutputWindow.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWin32ProcessOutputWindow.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWin32ProcessOutputWindow.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWin32ProcessOutputWindow.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWin32ProcessOutputWindow.DisplayText(System.String)">
            <summary>
                <para>Send text to the output window process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectBase.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkObjectBase.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVersion.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVersion.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVersion.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVersion.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVersion.GetVTKBuildVersion">
            <summary>
                <para>Return the version of vtk this object is a part of. A variety of methods are included. GetVTKSourceVersion returns a string with an identifier which timestamps a particular source tree. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkVersion.GetVTKMinorVersion">
            <summary>
                <para>Return the version of vtk this object is a part of. A variety of methods are included. GetVTKSourceVersion returns a string with an identifier which timestamps a particular source tree. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkVersion.GetVTKMajorVersion">
            <summary>
                <para>Return the version of vtk this object is a part of. A variety of methods are included. GetVTKSourceVersion returns a string with an identifier which timestamps a particular source tree. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkVersion.GetVTKVersion">
            <summary>
                <para>Return the version of vtk this object is a part of. A variety of methods are included. GetVTKSourceVersion returns a string with an identifier which timestamps a particular source tree. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataArrayCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollection.GetItem(System.Int32)">
            <summary>
                <para>Get the ith dataarray in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollection.GetNextItem">
            <summary>
                <para>Get the next dataarray in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArrayCollection.AddItem(vtk.vtkDataArray)">
            <summary>
                <para>Add a dataarray to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.PerformanceTests">
            <summary>
                <para>Conduct timing tests so that the usefulness of this class can be ascertained on whatever platform it is being used. Output can be retrieved via Print method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.SetReservedFracBits(System.Int32)">
            <summary>
                <para>Set the number of bits reserved for fractional precision that are maintained as part of the flooring process. This number affects the flooring arithmetic. It may be useful if the factional part is to be used to index into a lookup table of some sort. However, if you are only interested in knowing the fractional remainder after flooring, there doesn't appear to be any advantage to using these bits, either in terms of a lookup table, or by directly multiplying by some unit fraction, over simply subtracting the floored value from the original value. Note that since only 32 bits are used for the entire fixed point representation, increasing the number of reserved fractional bits reduces the range of integer values that can be floored to. Add one to the requested number of fractional bits, to make the conversion safe with respect to rounding mode. This is the same as the difference between QuickFloor and SafeFloor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.TestConvertFixedPointFracPart(System.Double)">
            <summary>
                <para>Wrappable method for script-testing of correct cross-platform functionality</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.TestConvertFixedPointIntPart(System.Double)">
            <summary>
                <para>Wrappable method for script-testing of correct cross-platform functionality</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.TestRound(System.Double)">
            <summary>
                <para>Wrappable method for script-testing of correct cross-platform functionality</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.TestSafeFloor(System.Double)">
            <summary>
                <para>Wrappable method for script-testing of correct cross-platform functionality</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFastNumericConversion.TestQuickFloor(System.Double)">
            <summary>
                <para>Wrappable method for script-testing of correct cross-platform functionality</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>A Figure-8 Klein bottle.  </para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.GetDimension">
            <summary>
                <para>A Figure-8 Klein bottle.  </para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.GetRadius">
            <summary>
                <para>Set/Get the radius of the bottle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFigure8Klein.SetRadius(System.Double)">
            <summary>
                <para>Set/Get the radius of the bottle.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTypeFloat64Array.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTypeFloat64Array.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTypeFloat64Array.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTypeFloat64Array.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTypeFloat64Array.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTypeFloat64Array.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDoubleArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.InsertNextValue(System.Double)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.InsertValue(System.Int32,System.Double)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.InsertNextTupleValue(System.Double[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.InsertTupleValue(System.Int32,System.Double[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.SetTupleValue(System.Int32,System.Double[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.GetTupleValue(System.Int32,System.Double[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDoubleArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSignedCharArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.InsertNextValue(System.SByte)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.InsertValue(System.Int32,System.SByte)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.SetValue(System.Int32,System.SByte)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.InsertNextTupleValue(System.SByte[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.InsertTupleValue(System.Int32,System.SByte[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.SetTupleValue(System.Int32,System.SByte[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.GetTupleValue(System.Int32,System.SByte[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSignedCharArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>A supertoroid.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.GetN2">
            <summary>
                <para>Set/Get the shape of the cross section of the ring. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.SetN2(System.Double)">
            <summary>
                <para>Set/Get the shape of the cross section of the ring. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.GetN1">
            <summary>
                <para>Set/Get the shape of the torus ring.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.SetN1(System.Double)">
            <summary>
                <para>Set/Get the shape of the torus ring.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.GetZRadius">
            <summary>
                <para>Set/Get the scaling factor for the z-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.SetZRadius(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the z-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.GetYRadius">
            <summary>
                <para>Set/Get the scaling factor for the y-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.SetYRadius(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the y-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.GetXRadius">
            <summary>
                <para>Set/Get the scaling factor for the x-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.SetXRadius(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the x-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.GetCrossSectionRadius">
            <summary>
                <para>Set/Get the radius of the cross section of ring of the supertoroid. Default = 0.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.SetCrossSectionRadius(System.Double)">
            <summary>
                <para>Set/Get the radius of the cross section of ring of the supertoroid. Default = 0.5.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.GetRingRadius">
            <summary>
                <para>Set/Get the radius from the center to the middle of the ring of the supertoroid.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.SetRingRadius(System.Double)">
            <summary>
                <para>Set/Get the radius from the center to the middle of the ring of the supertoroid.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperToroid.GetDimension">
            <summary>
                <para>Set/Get the radius from the center to the middle of the ring of the supertoroid.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDynamicLoader.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDynamicLoader.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDynamicLoader.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDynamicLoader.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDynamicLoader.LastError">
            <summary>
                <para>Return the last error produced from a calls made on this class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDynamicLoader.LibExtension">
            <summary>
                <para>Return the library extension for the given architecture</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDynamicLoader.LibPrefix">
            <summary>
                <para>Return the library prefix for the given architecture</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProperty2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProperty2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProperty2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProperty2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetDisplayLocationToForeground">
            <summary>
                <para>The DisplayLocation is either background or foreground. If it is background, then this 2D actor will be drawn behind all 3D props or foreground 2D actors. If it is background, then this 2D actor will be drawn in front of all 3D props and background 2D actors. Within 2D actors of the same DisplayLocation type, order is determined by the order in which the 2D actors were added to the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetDisplayLocationToBackground">
            <summary>
                <para>The DisplayLocation is either background or foreground. If it is background, then this 2D actor will be drawn behind all 3D props or foreground 2D actors. If it is background, then this 2D actor will be drawn in front of all 3D props and background 2D actors. Within 2D actors of the same DisplayLocation type, order is determined by the order in which the 2D actors were added to the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetDisplayLocation">
            <summary>
                <para>The DisplayLocation is either background or foreground. If it is background, then this 2D actor will be drawn behind all 3D props or foreground 2D actors. If it is background, then this 2D actor will be drawn in front of all 3D props and background 2D actors. Within 2D actors of the same DisplayLocation type, order is determined by the order in which the 2D actors were added to the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetDisplayLocationMaxValue">
            <summary>
                <para>The DisplayLocation is either background or foreground. If it is background, then this 2D actor will be drawn behind all 3D props or foreground 2D actors. If it is background, then this 2D actor will be drawn in front of all 3D props and background 2D actors. Within 2D actors of the same DisplayLocation type, order is determined by the order in which the 2D actors were added to the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetDisplayLocationMinValue">
            <summary>
                <para>The DisplayLocation is either background or foreground. If it is background, then this 2D actor will be drawn behind all 3D props or foreground 2D actors. If it is background, then this 2D actor will be drawn in front of all 3D props and background 2D actors. Within 2D actors of the same DisplayLocation type, order is determined by the order in which the 2D actors were added to the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetDisplayLocation(System.Int32)">
            <summary>
                <para>The DisplayLocation is either background or foreground. If it is background, then this 2D actor will be drawn behind all 3D props or foreground 2D actors. If it is background, then this 2D actor will be drawn in front of all 3D props and background 2D actors. Within 2D actors of the same DisplayLocation type, order is determined by the order in which the 2D actors were added to the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetLineStippleRepeatFactor">
            <summary>
                <para>Set/Get the stippling repeat factor of a Line, which specifies how many times each bit in the pattern is to be repeated. This is only implemented for OpenGL. The default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetLineStippleRepeatFactorMaxValue">
            <summary>
                <para>Set/Get the stippling repeat factor of a Line, which specifies how many times each bit in the pattern is to be repeated. This is only implemented for OpenGL. The default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetLineStippleRepeatFactorMinValue">
            <summary>
                <para>Set/Get the stippling repeat factor of a Line, which specifies how many times each bit in the pattern is to be repeated. This is only implemented for OpenGL. The default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetLineStippleRepeatFactor(System.Int32)">
            <summary>
                <para>Set/Get the stippling repeat factor of a Line, which specifies how many times each bit in the pattern is to be repeated. This is only implemented for OpenGL. The default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetLineStipplePattern">
            <summary>
                <para>Set/Get the stippling pattern of a Line, as a 16-bit binary pattern  (1 = pixel on, 0 = pixel off). This is only implemented for OpenGL. The default is 0xFFFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetLineStipplePattern(System.Int32)">
            <summary>
                <para>Set/Get the stippling pattern of a Line, as a 16-bit binary pattern  (1 = pixel on, 0 = pixel off). This is only implemented for OpenGL. The default is 0xFFFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetLineWidth">
            <summary>
                <para>Set/Get the width of a Line. The width is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetLineWidthMaxValue">
            <summary>
                <para>Set/Get the width of a Line. The width is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetLineWidthMinValue">
            <summary>
                <para>Set/Get the width of a Line. The width is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetLineWidth(System.Single)">
            <summary>
                <para>Set/Get the width of a Line. The width is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetPointSize">
            <summary>
                <para>Set/Get the diameter of a Point. The size is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetPointSizeMaxValue">
            <summary>
                <para>Set/Get the diameter of a Point. The size is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetPointSizeMinValue">
            <summary>
                <para>Set/Get the diameter of a Point. The size is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetPointSize(System.Single)">
            <summary>
                <para>Set/Get the diameter of a Point. The size is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetOpacity(System.Double)">
            <summary>
                <para>Set/Get the Opacity of this property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetOpacity">
            <summary>
                <para>Set/Get the Opacity of this property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.GetColor">
            <summary>
                <para>Set/Get the RGB color of this property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetColor(System.Double[])">
            <summary>
                <para>Set/Get the RGB color of this property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.SetColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the RGB color of this property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty2D.DeepCopy(vtk.vtkProperty2D)">
            <summary>
                <para>Assign one property to another. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkThreadMessager.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.SendMessage">
            <summary>
                <para>@deprecated Replaced by vtkThreadMessager::SendWakeMessage() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.WaitForReceiver">
            <summary>
                <para>pthreads only. If wait is enable, this will block until one thread is ready to receive a message.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.DisableWaitForReceiver">
            <summary>
                <para>pthreads only. If the wait is enabled, the thread who is to call WaitForMessage() will block until a receiver thread is ready to receive.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.EnableWaitForReceiver">
            <summary>
                <para>pthreads only. If the wait is enabled, the thread who is to call WaitForMessage() will block until a receiver thread is ready to receive.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.SendWakeMessage">
            <summary>
                <para>Send a message to all threads who are waiting via WaitForMessage().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThreadMessager.WaitForMessage">
            <summary>
                <para>Wait (block, non-busy) until another thread sends a message.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProp.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAssemblyPath.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.GetMTime">
            <summary>
                <para>Override the standard GetMTime() to check for the modified times of the nodes in this path.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.ShallowCopy(vtk.vtkAssemblyPath)">
            <summary>
                <para>Perform a shallow copy (reference counted) on the incoming path.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.DeleteLastNode">
            <summary>
                <para>Delete the last assembly node in the list. This is like a stack pop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.GetLastNode">
            <summary>
                <para>Get the last assembly node in the list. See the comments for GetNextNode() regarding the contents of the returned node.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.GetFirstNode">
            <summary>
                <para>Get the first assembly node in the list. See the comments for GetNextNode() regarding the contents of the returned node. (Note: This node corresponds to the vtkProp associated with the vtkRenderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.GetNextNode">
            <summary>
                <para>Get the next assembly node in the list. The node returned contains a pointer to a prop and a 4x4 matrix. The matrix is evaluated based on the preceding assembly hierarchy (i.e., the matrix is not necessarily as the same as the one that was added with AddNode() because of the  concatenation of matrices in the assembly hierarchy).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssemblyPath.AddNode(vtk.vtkProp,vtk.vtkMatrix4x4)">
            <summary>
                <para>Convenience method adds a prop and matrix together, creating an assembly node transparently. The matrix pointer m may be NULL. Note: that matrix is the one, if any, associated with the prop. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTensor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTensor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTensor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTensor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTensor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTensor.DeepCopy(vtk.vtkTensor)">
            <summary>
                <para>Deep copy of one tensor to another tensor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensor.AddComponent(System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Add to the value of the tensor component at location (i,j).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensor.SetComponent(System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Set the value of the tensor component (i,j).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensor.GetComponent(System.Int32,System.Int32)">
            <summary>
                <para>Get the tensor component (i,j).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTensor.Initialize">
            <summary>
                <para>Initialize tensor components to 0.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionSet.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFunctionSet.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.GetMaximumColor(System.Byte[])">
            <summary>
                <para>@deprecated For backwards compatibility: specify the color using  integers in the range [0,255].  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetMaximumColor(System.Byte[])">
            <summary>
                <para>@deprecated For backwards compatibility: specify the color using  integers in the range [0,255].  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetMaximumColor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>@deprecated For backwards compatibility: specify the color using  integers in the range [0,255].  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.GetMinimumColor(System.Byte[])">
            <summary>
                <para>@deprecated For backwards compatibility: specify the color using  integers in the range [0,255].  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetMinimumColor(System.Byte[])">
            <summary>
                <para>@deprecated For backwards compatibility: specify the color using  integers in the range [0,255].  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetMinimumColor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>@deprecated For backwards compatibility: specify the color using  integers in the range [0,255].  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.GetMaximumTableValue">
            <summary>
                <para>Set the maximum table value. All lookup table entries above the end of the ramp will be set to this color.  After you change this value, you must re-build the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetMaximumTableValue(System.Double[])">
            <summary>
                <para>Set the maximum table value. All lookup table entries above the end of the ramp will be set to this color.  After you change this value, you must re-build the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetMaximumTableValue(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the maximum table value. All lookup table entries above the end of the ramp will be set to this color.  After you change this value, you must re-build the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.GetMinimumTableValue">
            <summary>
                <para>Set the minimum table value.  All lookup table entries below the start of the ramp will be set to this color.  After you change this value, you must re-build the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetMinimumTableValue(System.Double[])">
            <summary>
                <para>Set the minimum table value.  All lookup table entries below the start of the ramp will be set to this color.  After you change this value, you must re-build the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetMinimumTableValue(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the minimum table value.  All lookup table entries below the start of the ramp will be set to this color.  After you change this value, you must re-build the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.InverseVideoOff">
            <summary>
                <para>Set inverse video on or off.  You can achieve the same effect by switching the MinimumTableValue and the MaximumTableValue.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.InverseVideoOn">
            <summary>
                <para>Set inverse video on or off.  You can achieve the same effect by switching the MinimumTableValue and the MaximumTableValue.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.GetInverseVideo">
            <summary>
                <para>Set inverse video on or off.  You can achieve the same effect by switching the MinimumTableValue and the MaximumTableValue.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetInverseVideo(System.Int32)">
            <summary>
                <para>Set inverse video on or off.  You can achieve the same effect by switching the MinimumTableValue and the MaximumTableValue.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.GetLevel">
            <summary>
                <para>Set the Level for the lookup table.  The level is the average of TableRange[0] and TableRange[1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetLevel(System.Double)">
            <summary>
                <para>Set the Level for the lookup table.  The level is the average of TableRange[0] and TableRange[1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.GetWindow">
            <summary>
                <para>Set the window for the lookup table.  The window is the difference between TableRange[0] and TableRange[1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.SetWindow(System.Double)">
            <summary>
                <para>Set the window for the lookup table.  The window is the difference between TableRange[0] and TableRange[1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowLevelLookupTable.Build">
            <summary>
                <para>Generate lookup table as a linear ramp between MinimumTableValue and MaximumTableValue.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourValues.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkContourValues.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkContourValues.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkContourValues.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkContourValues.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkContourValues.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkContourValues.GenerateValues(System.Int32,System.Double,System.Double)">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourValues.GenerateValues(System.Int32,System.Double[])">
            <summary>
                <para>Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourValues.GetNumberOfContours">
            <summary>
                <para>Return the number of contours in the</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourValues.SetNumberOfContours(System.Int32)">
            <summary>
                <para>Set the number of contours to place into the list. You only really need to use this method to reduce list size. The method SetValue() will automatically increase list size as needed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourValues.GetValues(System.Double[])">
            <summary>
                <para>Fill a supplied list with contour values. Make sure you've allocated memory of size GetNumberOfContours().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourValues.GetValue(System.Int32)">
            <summary>
                <para>Get the ith contour value. The return value will be clamped if the index i is out of range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkContourValues.SetValue(System.Int32,System.Double)">
            <summary>
                <para>Set the ith contour value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricCrossCap.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricCrossCap.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricCrossCap.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricCrossCap.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricCrossCap.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricCrossCap.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricCrossCap.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricCrossCap.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>A cross-cap.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricCrossCap.GetDimension">
            <summary>
                <para>A cross-cap.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.GetMTime">
            <summary>
                <para>Override GetMTime to account for input and concatenation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.CircuitCheck(vtk.vtkAbstractTransform)">
            <summary>
                <para>Check for self-reference.  Will return true if concatenating with the specified transform, setting it to be our inverse, or setting it to be our input will create a circular reference. CircuitCheck is automatically called by SetInput(), SetInverse(), and Concatenate(vtkXTransform *).  Avoid using this function, it is experimental.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.MakeTransform">
            <summary>
                <para>Make a new transform of the same type -- you are responsible for deleting the transform when you are done with it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Pop">
            <summary>
                <para>Deletes the transformation on the top of the stack and sets the top  to the next transformation on the stack.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Push">
            <summary>
                <para>Pushes the current transformation onto the transformation stack.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.GetInverseFlag">
            <summary>
                <para>Get the inverse flag of the transformation.  This controls whether it is the Input or the inverse of the Input that is used as the base transformation.  The InverseFlag is flipped every time Inverse() is called.  The InverseFlag is off when a transform is first created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.GetInput">
            <summary>
                <para>Set the input for this transformation.  This will be used as the base transformation if it is set.  This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly.  Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.SetInput(vtk.vtkHomogeneousTransform)">
            <summary>
                <para>Set the input for this transformation.  This will be used as the base transformation if it is set.  This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly.  Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.GetNumberOfConcatenatedTransforms">
            <summary>
                <para>Get the total number of transformations that are linked into this one via Concatenate() operations or via SetInput().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.PostMultiply">
            <summary>
                <para>Sets the internal state of the transform to PostMultiply. All subsequent operations will occur after those already represented in the current transformation.  In homogeneous matrix notation, M = A*M where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.PreMultiply">
            <summary>
                <para>Sets the internal state of the transform to PreMultiply. All subsequent operations will occur before those already represented in the current transformation.  In homogeneous matrix notation, M = M*A where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Concatenate(vtk.vtkHomogeneousTransform)">
            <summary>
                <para>Concatenate the specified transform with the current transformation according to PreMultiply or PostMultiply semantics. The concatenation is pipelined, meaning that if any of the transformations are changed, even after Concatenate() is called, those changes will be reflected when you call TransformPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Concatenate(System.Double[])">
            <summary>
                <para>Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Concatenate(vtk.vtkMatrix4x4)">
            <summary>
                <para>Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.SetMatrix(System.Double[])">
            <summary>
                <para>Set the current matrix directly.  This actually calls Identity(), followed by Concatenate(matrix).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.SetMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>Set the current matrix directly.  This actually calls Identity(), followed by Concatenate(matrix).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Scale(System.Single[])">
            <summary>
                <para>Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Scale(System.Double[])">
            <summary>
                <para>Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Scale(System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.RotateZ(System.Double)">
            <summary>
                <para>Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  The angle is expressed in degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.RotateY(System.Double)">
            <summary>
                <para>Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  The angle is expressed in degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.RotateX(System.Double)">
            <summary>
                <para>Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  The angle is expressed in degrees.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.RotateWXYZ(System.Double,System.Single[])">
            <summary>
                <para>Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.RotateWXYZ(System.Double,System.Double[])">
            <summary>
                <para>Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.RotateWXYZ(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Translate(System.Single[])">
            <summary>
                <para>Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Translate(System.Double[])">
            <summary>
                <para>Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Translate(System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.SetupCamera(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Set a view transformation matrix for the camera (this matrix does not contain any perspective) and concatenate it with the current transformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Stereo(System.Double,System.Double)">
            <summary>
                <para>Create a stereo shear matrix and concatenate it with the current transformation.  This can be applied in conjunction with either a  perspective transformation (via Frustum or Projection) or an orthographic projection.  You must specify the distance from the camera plane to the focal plane, and the angle between the distance vector and the eye.  The angle should be negative for the left eye, and positive for the right.  This method works via Oblique.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Shear(System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a shear transformation about a plane at distance z from the camera.  The values dxdz (i.e. dx/dz) and dydz specify the amount of shear in the x and y directions.  The 'zplane' specifies the distance from the camera to the plane at which the shear causes zero displacement.  Generally you want this plane to be the focal plane. This transformation can be used in combination with Ortho to create  an oblique projection.  It can also be used in combination with Perspective to provide correct stereo views when the eye is at arbitrary but known positions relative to the center of a flat viewing screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Perspective(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Create a perspective projection matrix by specifying the view angle (this angle is in the y direction), the aspect ratio, and the near  and far clipping range.  The projection matrix is concatenated  with the current transformation.  This method works via Frustum.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Frustum(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Create an perspective projection matrix and concatenate it by the current transformation.  The matrix maps a frustum with a back plane at -zfar and a front plane at -znear with extent  [xmin,xmax],[ymin,ymax] to [-1,+1], [-1,+1], [+1,-1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Ortho(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Create an orthogonal projection matrix and concatenate it by the current transformation.  The matrix maps [xmin,xmax], [ymin,ymax],  [-znear,-zfar] to [-1,+1], [-1,+1], [+1,-1]. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.AdjustZBuffer(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Perform an adjustment to the Z-Buffer range that the near and far clipping planes map to.  By default Ortho, Frustum, and Perspective map the near clipping plane to -1 and the far clipping plane to +1. In PreMultiply mode, you call this method before calling Ortho, Frustum, or Perspective.  In PostMultiply mode you can call it after.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.AdjustViewport(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Perform an adjustment to the viewport coordinates.  By default Ortho, Frustum, and Perspective provide a window of ([-1,+1],[-1,+1]). In PreMultiply mode, you call this method before calling Ortho, Frustum, or Perspective.  In PostMultiply mode you can call it after.  Note that if you must apply both AdjustZBuffer and AdjustViewport, it makes no difference which order you apply them in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Inverse">
            <summary>
                <para>Invert the transformation.  This will also set a flag so that the transformation will use the inverse of its Input, if an Input has been set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPerspectiveTransform.Identity">
            <summary>
                <para>Set this transformation to the identity transformation.  If  the transform has an Input, then the transformation will be reset so that it is the same as the Input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExtentSplitter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.PointModeOff">
            <summary>
                <para>Get/Set whether "point mode" is on.  In point mode, sub-extents are generated to ensure every point in the update request is read, but not necessarily every cell.  This can be used when point data are stored in a planar slice per piece with no cell data.  The default is OFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.PointModeOn">
            <summary>
                <para>Get/Set whether "point mode" is on.  In point mode, sub-extents are generated to ensure every point in the update request is read, but not necessarily every cell.  This can be used when point data are stored in a planar slice per piece with no cell data.  The default is OFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.SetPointMode(System.Int32)">
            <summary>
                <para>Get/Set whether "point mode" is on.  In point mode, sub-extents are generated to ensure every point in the update request is read, but not necessarily every cell.  This can be used when point data are stored in a planar slice per piece with no cell data.  The default is OFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.GetPointMode">
            <summary>
                <para>Get/Set whether "point mode" is on.  In point mode, sub-extents are generated to ensure every point in the update request is read, but not necessarily every cell.  This can be used when point data are stored in a planar slice per piece with no cell data.  The default is OFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.GetSubExtentSource(System.Int32)">
            <summary>
                <para>Get the id of the source from which the sub-extent associated with the given index should be read.  Returns -1 if no source provides the sub-extent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.GetSubExtent(System.Int32,System.Int32[])">
            <summary>
                <para>Get the sub-extent associated with the given index.  Use GetSubExtentSource to get the id of the source from which this sub-extent should be read.  Valid after a call to ComputeSubExtents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.GetSubExtent(System.Int32)">
            <summary>
                <para>Get the sub-extent associated with the given index.  Use GetSubExtentSource to get the id of the source from which this sub-extent should be read.  Valid after a call to ComputeSubExtents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.GetNumberOfSubExtents">
            <summary>
                <para>Get the number of sub-extents into which the original set of extents have been split across the available sources.  Valid after a call to ComputeSubExtents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.ComputeSubExtents">
            <summary>
                <para>Split the extents currently in the queue among the available sources.  The queue is empty when this returns.  Returns 1 if all extents could be read.  Returns 0 if any portion of any extent was not available through any source.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.AddExtent(System.Int32[])">
            <summary>
                <para>Add an extent to the queue of extents to be split among the available sources.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.AddExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Add an extent to the queue of extents to be split among the available sources.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.RemoveAllExtentSources">
            <summary>
                <para>Add/Remove a source providing the given extent.  Sources with higher priority numbers are favored.  Source id numbers and priorities must be non-negative.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.RemoveExtentSource(System.Int32)">
            <summary>
                <para>Add/Remove a source providing the given extent.  Sources with higher priority numbers are favored.  Source id numbers and priorities must be non-negative.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.AddExtentSource(System.Int32,System.Int32,System.Int32[])">
            <summary>
                <para>Add/Remove a source providing the given extent.  Sources with higher priority numbers are favored.  Source id numbers and priorities must be non-negative.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExtentSplitter.AddExtentSource(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Add/Remove a source providing the given extent.  Sources with higher priority numbers are favored.  Source id numbers and priorities must be non-negative.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFunctionSet.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFunctionSet.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFunctionSet.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFunctionSet.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFunctionSet.GetNumberOfFunctions">
            <summary>
                <para>Return the number of independent variables. Note that this is  constant for a given type of set of functions and can not be changed   at run time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionSet.FunctionValues(System.Double[],System.Double[])">
            <summary>
                <para>Evaluate functions at x_j. x and f have to point to valid double arrays of appropriate  sizes obtained with GetNumberOfFunctions() and GetNumberOfIndependentVariables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHeap.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHeap.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHeap.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHeap.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHeap.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHeap.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHeap.StringDup(System.String)">
            <summary>
                <para>Convenience method performs string duplication.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHeap.Reset">
            <summary>
                <para>This methods resets the current allocation location back to the beginning of the heap. This allows reuse of previously allocated memory which may be beneficial to performance in many cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHeap.GetNumberOfAllocations">
            <summary>
                <para>Get the number of allocations thus far.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHeap.GetNumberOfBlocks">
            <summary>
                <para>Get the number of allocations thus far.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkObjectFactory.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetLibraryPath">
            <summary>
                <para>This returns the path to a dynamically loaded factory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.Disable(System.String)">
            <summary>
                <para>Set all enable flags for the given class to 0.  This will mean that the factory will stop producing class with the given name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.HasOverride(System.String,System.String)">
            <summary>
                <para>Return 1 if this factory overrides the given class name, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.HasOverride(System.String)">
            <summary>
                <para>Return 1 if this factory overrides the given class name, 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetEnableFlag(System.String,System.String)">
            <summary>
                <para>Set and Get the Enable flag for the specific override of className. if subclassName is null, then it is ignored.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.SetEnableFlag(System.Int32,System.String,System.String)">
            <summary>
                <para>Set and Get the Enable flag for the specific override of className. if subclassName is null, then it is ignored.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetOverrideDescription(System.Int32)">
            <summary>
                <para>Return the description for a the class override at the given  index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetEnableFlag(System.Int32)">
            <summary>
                <para>Return the enable flag for the class at the given index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetClassOverrideWithName(System.Int32)">
            <summary>
                <para>Return the name of the class that will override the class at the given index</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetClassOverrideName(System.Int32)">
            <summary>
                <para>Return the name of a class override at the given index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetNumberOfOverrides">
            <summary>
                <para>Return number of overrides this factory can create.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetDescription">
            <summary>
                <para>Return a descriptive string describing the factory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetVTKSourceVersion">
            <summary>
                <para>All sub-classes of vtkObjectFactory should must return the version of  VTK they were built with.  This should be implemented with the macro VTK_SOURCE_VERSION and NOT a call to vtkVersion::GetVTKSourceVersion. As the version needs to be compiled into the file as a string constant. This is critical to determine possible incompatible dynamic factory loads.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.SetAllEnableFlags(System.Int32,System.String,System.String)">
            <summary>
                <para>Set the enable flag for a given named class subclass pair for all registered factories.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.SetAllEnableFlags(System.Int32,System.String)">
            <summary>
                <para>Set the enable flag for a given named class for all registered factories.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetOverrideInformation(System.String,vtk.vtkOverrideInformationCollection)">
            <summary>
                <para>Fill the given collection with all the overrides for the class with the given name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.HasOverrideAny(System.String)">
            <summary>
                <para>return 1 if one of the registered factories  overrides the given class name</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.GetRegisteredFactories">
            <summary>
                <para>Return the list of all registered factories.  This is NOT a copy, do not remove items from this list!</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.UnRegisterAllFactories">
            <summary>
                <para>Unregister all factories</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.UnRegisterFactory(vtk.vtkObjectFactory)">
            <summary>
                <para>Remove a factory from the list of registered factories</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.RegisterFactory(vtk.vtkObjectFactory)">
            <summary>
                <para>Register a factory so it can be used to create vtk objects</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.ReHash">
            <summary>
                <para>Re-check the VTK_AUTOLOAD_PATH for new factory libraries. This calls UnRegisterAll before re-loading</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.CreateAllInstance(System.String,vtk.vtkCollection)">
            <summary>
                <para>Create all possible instances of the named vtk object. Each registered vtkObjectFactory will be asked, and the result will be stored in the user allocated vtkCollection passed in to the function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectFactory.CreateInstance(System.String)">
            <summary>
                <para>Create and return an instance of the named vtk object. Each loaded vtkObjectFactory will be asked in the order the factory was in the VTK_AUTOLOAD_PATH.  After the first factory returns the object no other factories are asked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLookupTable.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLookupTable.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLookupTable.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLookupTable.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLookupTable.DeepCopy(vtk.vtkLookupTable)">
            <summary>
                <para>Copy the contents from another LookupTable</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.MapScalarsThroughTable2(System.IntPtr,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>map a set of scalars through the lookup table</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetTable">
            <summary>
                <para>Set/Get the internal table array that is used to map the scalars to colors.  The table array is an unsigned char array with 4 components representing RGBA.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetTable(vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Set/Get the internal table array that is used to map the scalars to colors.  The table array is an unsigned char array with 4 components representing RGBA.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetNumberOfColors">
            <summary>
                <para>Set the number of colors in the lookup table.  Use SetNumberOfTableValues() instead, it can be used both before and after the table has been built whereas SetNumberOfColors() has no effect after the table has been built.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetNumberOfColorsMaxValue">
            <summary>
                <para>Set the number of colors in the lookup table.  Use SetNumberOfTableValues() instead, it can be used both before and after the table has been built whereas SetNumberOfColors() has no effect after the table has been built.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetNumberOfColorsMinValue">
            <summary>
                <para>Set the number of colors in the lookup table.  Use SetNumberOfTableValues() instead, it can be used both before and after the table has been built whereas SetNumberOfColors() has no effect after the table has been built.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetNumberOfColors(System.Int32)">
            <summary>
                <para>Set the number of colors in the lookup table.  Use SetNumberOfTableValues() instead, it can be used both before and after the table has been built whereas SetNumberOfColors() has no effect after the table has been built.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetRange(System.Double[])">
            <summary>
                <para>Sets/Gets the range of scalars which will be mapped.  This is a duplicate of Get/SetTableRange.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetRange(System.Double,System.Double)">
            <summary>
                <para>Sets/Gets the range of scalars which will be mapped.  This is a duplicate of Get/SetTableRange.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetTableValue(System.Int32,System.Double[])">
            <summary>
                <para>Return a rgba color value for the given index into the lookup table. Color components are expressed as [0,1] double values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetTableValue(System.Int32)">
            <summary>
                <para>Return a rgba color value for the given index into the lookup table. Color components are expressed as [0,1] double values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetTableValue(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Directly load color into lookup table. Use [0,1] double values for color  component specification.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetTableValue(System.Int32,System.Double[])">
            <summary>
                <para>Directly load color into lookup table. Use [0,1] double values for color component specification. Make sure that you've either used the Build() method or used SetNumberOfTableValues() prior to using this method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetNumberOfTableValues">
            <summary>
                <para>Specify the number of values (i.e., colors) in the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetNumberOfTableValues(System.Int32)">
            <summary>
                <para>Specify the number of values (i.e., colors) in the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetIndex(System.Double)">
            <summary>
                <para>Return the table index associated with a particular value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetOpacity(System.Double)">
            <summary>
                <para>Map one value through the lookup table and return the alpha value (the opacity) as a double between 0 and 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetColor(System.Double,System.Double[])">
            <summary>
                <para>Map one value through the lookup table and return the color as an RGB array of doubles between 0 and 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetAlphaRange">
            <summary>
                <para>Set the range in alpha (using automatic generation). Alpha ranges from  [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetAlphaRange(System.Double[])">
            <summary>
                <para>Set the range in alpha (using automatic generation). Alpha ranges from  [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetAlphaRange(System.Double,System.Double)">
            <summary>
                <para>Set the range in alpha (using automatic generation). Alpha ranges from  [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetValueRange">
            <summary>
                <para>Set the range in value (using automatic generation). Value ranges  between [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetValueRange(System.Double[])">
            <summary>
                <para>Set the range in value (using automatic generation). Value ranges  between [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetValueRange(System.Double,System.Double)">
            <summary>
                <para>Set the range in value (using automatic generation). Value ranges  between [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetSaturationRange">
            <summary>
                <para>Set the range in saturation (using automatic generation). Saturation  ranges between [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetSaturationRange(System.Double[])">
            <summary>
                <para>Set the range in saturation (using automatic generation). Saturation  ranges between [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetSaturationRange(System.Double,System.Double)">
            <summary>
                <para>Set the range in saturation (using automatic generation). Saturation  ranges between [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetHueRange">
            <summary>
                <para>Set the range in hue (using automatic generation). Hue ranges  between [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetHueRange(System.Double[])">
            <summary>
                <para>Set the range in hue (using automatic generation). Hue ranges  between [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetHueRange(System.Double,System.Double)">
            <summary>
                <para>Set the range in hue (using automatic generation). Hue ranges  between [0,1].</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetTableRange">
            <summary>
                <para>Set/Get the minimum/maximum scalar values for scalar mapping. Scalar values less than minimum range value are clamped to minimum range value. Scalar values greater than maximum range value are clamped to maximum range value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetTableRange(System.Double,System.Double)">
            <summary>
                <para>Set/Get the minimum/maximum scalar values for scalar mapping. Scalar values less than minimum range value are clamped to minimum range value. Scalar values greater than maximum range value are clamped to maximum range value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetTableRange(System.Double[])">
            <summary>
                <para>Set/Get the minimum/maximum scalar values for scalar mapping. Scalar values less than minimum range value are clamped to minimum range value. Scalar values greater than maximum range value are clamped to maximum range value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetScale">
            <summary>
                <para>Set the type of scale to use, linear or logarithmic.  The default is linear.  If the scale is logarithmic, then the TableRange must not cross the value zero.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetScaleToLog10">
            <summary>
                <para>Set the type of scale to use, linear or logarithmic.  The default is linear.  If the scale is logarithmic, then the TableRange must not cross the value zero.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetScaleToLinear">
            <summary>
                <para>Set the type of scale to use, linear or logarithmic.  The default is linear.  If the scale is logarithmic, then the TableRange must not cross the value zero.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetScale(System.Int32)">
            <summary>
                <para>Set the type of scale to use, linear or logarithmic.  The default is linear.  If the scale is logarithmic, then the TableRange must not cross the value zero.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.GetRamp">
            <summary>
                <para>Set the shape of the table ramp to either linear or S-curve. The default is S-curve, which tails off gradually at either end.   The equation used for the S-curve is y = (sin((x - 1/2)*pi) + 1)/2, while the equation for the linear ramp is simply y = x.  For an S-curve greyscale ramp, you should set NumberOfTableValues to 402  (which is 256*pi/2) to provide room for the tails of the ramp. The equation for the SQRT is y = sqrt(x).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetRampToSQRT">
            <summary>
                <para>Set the shape of the table ramp to either linear or S-curve. The default is S-curve, which tails off gradually at either end.   The equation used for the S-curve is y = (sin((x - 1/2)*pi) + 1)/2, while the equation for the linear ramp is simply y = x.  For an S-curve greyscale ramp, you should set NumberOfTableValues to 402  (which is 256*pi/2) to provide room for the tails of the ramp. The equation for the SQRT is y = sqrt(x).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetRampToSCurve">
            <summary>
                <para>Set the shape of the table ramp to either linear or S-curve. The default is S-curve, which tails off gradually at either end.   The equation used for the S-curve is y = (sin((x - 1/2)*pi) + 1)/2, while the equation for the linear ramp is simply y = x.  For an S-curve greyscale ramp, you should set NumberOfTableValues to 402  (which is 256*pi/2) to provide room for the tails of the ramp. The equation for the SQRT is y = sqrt(x).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetRampToLinear">
            <summary>
                <para>Set the shape of the table ramp to either linear or S-curve. The default is S-curve, which tails off gradually at either end.   The equation used for the S-curve is y = (sin((x - 1/2)*pi) + 1)/2, while the equation for the linear ramp is simply y = x.  For an S-curve greyscale ramp, you should set NumberOfTableValues to 402  (which is 256*pi/2) to provide room for the tails of the ramp. The equation for the SQRT is y = sqrt(x).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.SetRamp(System.Int32)">
            <summary>
                <para>Set the shape of the table ramp to either linear or S-curve. The default is S-curve, which tails off gradually at either end.   The equation used for the S-curve is y = (sin((x - 1/2)*pi) + 1)/2, while the equation for the linear ramp is simply y = x.  For an S-curve greyscale ramp, you should set NumberOfTableValues to 402  (which is 256*pi/2) to provide room for the tails of the ramp. The equation for the SQRT is y = sqrt(x).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.ForceBuild">
            <summary>
                <para>Force the lookup table to regenerate from hue, saturation, value, and alpha min/max values.  Table is built from a linear ramp of each value.  ForceBuild() is useful if a lookup table has been defined manually (using SetTableValue) and then an application decides to rebuild the lookup table using the implicit process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.Build">
            <summary>
                <para>Generate lookup table from hue, saturation, value, alpha min/max values.  Table is built from linear ramp of each value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLookupTable.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate a color table of specified size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkIntArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkIntArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkIntArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkIntArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkIntArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkIntArray.InsertNextValue(System.Int32)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.InsertValue(System.Int32,System.Int32)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.SetValue(System.Int32,System.Int32)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.InsertNextTupleValue(System.Int32[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.InsertTupleValue(System.Int32,System.Int32[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.SetTupleValue(System.Int32,System.Int32[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.GetTupleValue(System.Int32,System.Int32[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIntArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGarbageCollector.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.GetGlobalDebugFlag">
            <summary>
                <para>Set/Get global garbage collection debugging flag.  When set to 1, all garbage collection checks will produce debugging information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.SetGlobalDebugFlag(System.Int32)">
            <summary>
                <para>Set/Get global garbage collection debugging flag.  When set to 1, all garbage collection checks will produce debugging information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.DeferredCollectionPop">
            <summary>
                <para>Push/Pop whether to do deferred collection.  Whenever the total number of pushes exceeds the total number of pops collection will be deferred.  Code can call the Collect method directly to force collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.DeferredCollectionPush">
            <summary>
                <para>Push/Pop whether to do deferred collection.  Whenever the total number of pushes exceeds the total number of pops collection will be deferred.  Code can call the Collect method directly to force collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.Collect(vtk.vtkObjectBase)">
            <summary>
                <para>Collect immediately using the given object as the root for a reference graph walk.  Strongly connected components in the reference graph are identified.  Those with a net reference count of zero are deleted.  When a component is deleted it may remove references to other components that are not part of the same reference loop but are held by objects in the original component. These removed references are handled as any other and their corresponding checks may be deferred.  This method does continue collecting in this case.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGarbageCollector.Collect">
            <summary>
                <para>Collect immediately using any objects whose collection was previously deferred as a root for the reference graph walk. Strongly connected components in the reference graph are identified.  Those with a net reference count of zero are deleted.  When a component is deleted it may remove references to other components that are not part of the same reference loop but are held by objects in the original component.  These removed references are handled as any other and their corresponding checks may be deferred.  This method keeps collecting until no deferred collection checks remain.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOverrideInformation.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.SetDescription(System.String)">
            <summary>
                <para>Set the class override name Set the class override with name Set the description</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.SetClassOverrideWithName(System.String)">
            <summary>
                <para>Set the class override name Set the class override with name</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.SetClassOverrideName(System.String)">
            <summary>
                <para>Set the class override name</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.GetObjectFactory">
            <summary>
                <para>Set the class override name</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.GetDescription">
            <summary>
                <para>Return the specific object factory that this override occurs in.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.GetClassOverrideWithName">
            <summary>
                <para>Return a human readable or GUI displayable description of this override.   </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformation.GetClassOverrideName">
            <summary>
                <para>Returns the name of the class that will override the class. For example, if you had a factory that provided an override for vtkVertex called vtkMyVertex, then this would return "vtkMyVertex"</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformationCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOverrideInformationCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformationCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOverrideInformationCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOverrideInformationCollection.GetNextItem">
            <summary>
                <para>Get the next OverrideInformation in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOverrideInformationCollection.AddItem(vtk.vtkOverrideInformation)">
            <summary>
                <para>Add a OverrideInformation to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPlane.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPlane.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPlane.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPlane.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPlane.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPlane.IntersectWithLine(System.Double[],System.Double[],System.Double[],System.Double[],System.Double@,System.Double[])">
            <summary>
                <para>Given a line defined by the two points p1,p2; and a plane defined by the normal n and point p0, compute an intersection. The parametric coordinate along the line is returned in t, and the coordinates of  intersection are returned in x. A zero is returned if the plane and line do not intersect between (0&lt;=t&lt;=1). If the plane and line are parallel, zero is returned and t is set to VTK_LARGE_DOUBLE.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.DistanceToPlane(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Return the distance of a point x to a plane defined by n(x-p0) = 0. The normal n[3] must be magnitude=1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Quick evaluation of plane equation n(x-origin)=0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.Push(System.Double)">
            <summary>
                <para>Translate the plane in the direction of the normal by the distance specified.  Negative values move the plane in the opposite direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.GetOrigin">
            <summary>
                <para>Set/get point through which plane passes. Plane is defined by point  and normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.SetOrigin(System.Double[])">
            <summary>
                <para>Set/get point through which plane passes. Plane is defined by point  and normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.SetOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/get point through which plane passes. Plane is defined by point  and normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.GetNormal">
            <summary>
                <para>Set/get plane normal. Plane is defined by point and normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.SetNormal(System.Double[])">
            <summary>
                <para>Set/get plane normal. Plane is defined by point and normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPlane.SetNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/get plane normal. Plane is defined by point and normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.EvaluateFunction">
            <summary>
                <para>Evaluate the function.  This is usually called internally by the minimization code, but it is provided here as a public method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetFunctionEvaluations">
            <summary>
                <para>Return the number of times that the function has been evaluated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetIterations">
            <summary>
                <para>Return the number of interations that have been performed.  This is not necessarily the same as the number of function evaluations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetMaxIterations">
            <summary>
                <para>Specify the maximum number of iterations to try before giving up.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.SetMaxIterations(System.Int32)">
            <summary>
                <para>Specify the maximum number of iterations to try before giving up.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetTolerance">
            <summary>
                <para>Specify the fractional tolerance to aim for during the minimization.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.SetTolerance(System.Double)">
            <summary>
                <para>Specify the fractional tolerance to aim for during the minimization.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetFunctionValue">
            <summary>
                <para>Get the function value resulting from the minimization.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.SetFunctionValue(System.Double)">
            <summary>
                <para>Get the function value resulting from the minimization.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.Iterate">
            <summary>
                <para>Perform one iteration of minimization.  Returns zero if the tolerance stopping criterion has been met.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.Minimize">
            <summary>
                <para>Iterate until the minimum is found to within the specified tolerance, or until the MaxIterations has been reached. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.Initialize">
            <summary>
                <para>Initialize the minimizer.  This will reset the number of parameters to zero so that the minimizer can be reused.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetNumberOfParameters">
            <summary>
                <para>Get the number of parameters that have been set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetParameterName(System.Int32)">
            <summary>
                <para>For completeness, an unchecked method to get the name for particular parameter (the result will be NULL if no name was set).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetParameterValue(System.Int32)">
            <summary>
                <para>Get the value of a parameter at the current stage of the minimization. Call this method within the function that you are minimizing in order to get the current parameter values.  It is preferable to specify parameters by name rather than by index. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetParameterValue(System.String)">
            <summary>
                <para>Get the value of a parameter at the current stage of the minimization. Call this method within the function that you are minimizing in order to get the current parameter values.  It is preferable to specify parameters by name rather than by index. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetParameterScale(System.Int32)">
            <summary>
                <para>Set the scale to use when modifying a parameter, i.e. the initial amount by which the parameter will be modified during the search for the minimum.  It is preferable to identify scalars by name rather than by number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.SetParameterScale(System.Int32,System.Double)">
            <summary>
                <para>Set the scale to use when modifying a parameter, i.e. the initial amount by which the parameter will be modified during the search for the minimum.  It is preferable to identify scalars by name rather than by number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.GetParameterScale(System.String)">
            <summary>
                <para>Set the scale to use when modifying a parameter, i.e. the initial amount by which the parameter will be modified during the search for the minimum.  It is preferable to identify scalars by name rather than by number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.SetParameterScale(System.String,System.Double)">
            <summary>
                <para>Set the scale to use when modifying a parameter, i.e. the initial amount by which the parameter will be modified during the search for the minimum.  It is preferable to identify scalars by name rather than by number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.SetParameterValue(System.Int32,System.Double)">
            <summary>
                <para>Set the initial value for the specified parameter.  Calling this function for any parameter will reset the Iterations and the FunctionEvaluations counts to zero.  You must also use SetParameterScale() to specify the step size by which the parameter will be modified during the minimization.  It is preferable to specify parameters by name, rather than by number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAmoebaMinimizer.SetParameterValue(System.String,System.Double)">
            <summary>
                <para>Set the initial value for the specified parameter.  Calling this function for any parameter will reset the Iterations and the FunctionEvaluations counts to zero.  You must also use SetParameterScale() to specify the step size by which the parameter will be modified during the minimization.  It is preferable to specify parameters by name, rather than by number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFunctionParser.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetReplacementValue">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.SetReplacementValue(System.Double)">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.ReplaceInvalidValuesOff">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.ReplaceInvalidValuesOn">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetReplaceInvalidValues">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.SetReplaceInvalidValues(System.Int32)">
            <summary>
                <para>When ReplaceInvalidValues is on, all invalid values (such as sqrt(-2), note that function parser does not handle complex numbers) will be replaced by ReplacementValue. Otherwise an error will be reported</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.RemoveAllVariables">
            <summary>
                <para>Remove all the current variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetVectorVariableName(System.Int32)">
            <summary>
                <para>Get the ith vector variable name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetScalarVariableName(System.Int32)">
            <summary>
                <para>Get the ith scalar variable name.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetNumberOfVectorVariables">
            <summary>
                <para>Get the number of vector variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetNumberOfScalarVariables">
            <summary>
                <para>Get the number of scalar variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetVectorVariableValue(System.Int32,System.Double[])">
            <summary>
                <para>Get the value of a vector variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetVectorVariableValue(System.Int32)">
            <summary>
                <para>Get the value of a vector variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetVectorVariableValue(System.String,System.Double[])">
            <summary>
                <para>Get the value of a vector variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetVectorVariableValue(System.String)">
            <summary>
                <para>Get the value of a vector variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.SetVectorVariableValue(System.Int32,System.Double[])">
            <summary>
                <para>Set the value of a vector variable.  If a variable with this name exists, then its value will be set to the new value.  If there is not already a variable with this name, variableName will be added to the list of variables, and its value will be set to the new value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.SetVectorVariableValue(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the value of a vector variable.  If a variable with this name exists, then its value will be set to the new value.  If there is not already a variable with this name, variableName will be added to the list of variables, and its value will be set to the new value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.SetVectorVariableValue(System.String,System.Double[])">
            <summary>
                <para>Set the value of a vector variable.  If a variable with this name exists, then its value will be set to the new value.  If there is not already a variable with this name, variableName will be added to the list of variables, and its value will be set to the new value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.SetVectorVariableValue(System.String,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the value of a vector variable.  If a variable with this name exists, then its value will be set to the new value.  If there is not already a variable with this name, variableName will be added to the list of variables, and its value will be set to the new value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetScalarVariableValue(System.Int32)">
            <summary>
                <para>Get the value of a scalar variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetScalarVariableValue(System.String)">
            <summary>
                <para>Get the value of a scalar variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.SetScalarVariableValue(System.Int32,System.Double)">
            <summary>
                <para>Set the value of a scalar variable.  If a variable with this name exists, then its value will be set to the new value.  If there is not already a variable with this name, variableName will be added to the list of variables, and its value will be set to the new value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.SetScalarVariableValue(System.String,System.Double)">
            <summary>
                <para>Set the value of a scalar variable.  If a variable with this name exists, then its value will be set to the new value.  If there is not already a variable with this name, variableName will be added to the list of variables, and its value will be set to the new value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetVectorResult(System.Double[])">
            <summary>
                <para>Get a vector result from evaluating the input function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetVectorResult">
            <summary>
                <para>Get a vector result from evaluating the input function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.GetScalarResult">
            <summary>
                <para>Get a scalar result from evaluating the input function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.IsVectorResult">
            <summary>
                <para>Check whether the result is a vector result.  If it isn't, then either the result is scalar or an error has occurred.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFunctionParser.IsScalarResult">
            <summary>
                <para>Check whether the result is a scalar result.  If it isn't, then either the result is a vector or an error has occurred.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.InsertNextValue(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.InsertValue(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.SetValue(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.InsertNextTupleValue(System.UInt32!System.Runtime.CompilerServices.IsLong[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.InsertTupleValue(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.SetTupleValue(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.GetTupleValue(System.Int32,System.UInt32!System.Runtime.CompilerServices.IsLong[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedLongArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMatrix4x4.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.SetElement(System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Sets the element i,j in the matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Determinant">
            <summary>
                <para>Sets the element i,j in the matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Adjoint(vtk.vtkMatrix4x4,vtk.vtkMatrix4x4)">
            <summary>
                <para>Compute the determinant of the matrix and return it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Multiply4x4(vtk.vtkMatrix4x4,vtk.vtkMatrix4x4,vtk.vtkMatrix4x4)">
            <summary>
                <para>Multiplies matrices a and b and stores the result in c.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.MultiplyDoublePoint(System.Double[])">
            <summary>
                <para>Multiplies matrices a and b and stores the result in c.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.MultiplyFloatPoint(System.Single[])">
            <summary>
                <para>For use in Java, Python or Tcl.  The default MultiplyPoint() uses a single-precision point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.MultiplyPoint(System.Single[])">
            <summary>
                <para>For use in Java, Python or Tcl.  The default MultiplyPoint() uses a single-precision point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.MultiplyPoint(System.Double[],System.Double[])">
            <summary>
                <para>For use in Java, Python or Tcl.  The default MultiplyPoint() uses a single-precision point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.MultiplyPoint(System.Single[],System.Single[])">
            <summary>
                <para>Multiply a homogeneous coordinate by this matrix, i.e. out = A*in. The in[4] and out[4] can be the same array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Transpose">
            <summary>
                <para>Multiply a homogeneous coordinate by this matrix, i.e. out = A*in. The in[4] and out[4] can be the same array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Transpose(vtk.vtkMatrix4x4,vtk.vtkMatrix4x4)">
            <summary>
                <para>Transpose the matrix and put it into out. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Invert">
            <summary>
                <para>Transpose the matrix and put it into out. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Invert(vtk.vtkMatrix4x4,vtk.vtkMatrix4x4)">
            <summary>
                <para>Matrix Inversion (adapted from Richard Carling in "Graphics Gems,"  Academic Press, 1990).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Identity">
            <summary>
                <para>Matrix Inversion (adapted from Richard Carling in "Graphics Gems,"  Academic Press, 1990).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.Zero">
            <summary>
                <para>Set equal to Identity matrix</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.DeepCopy(System.Double[])">
            <summary>
                <para>Set all of the elements to zero.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMatrix4x4.DeepCopy(vtk.vtkMatrix4x4)">
            <summary>
                <para>Non-static member function. Assigns *from* elements array</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricDini.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricDini.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricDini.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricDini.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricDini.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricDini.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricDini.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricDini.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Dini's surface.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricDini.GetB">
            <summary>
                <para>Set/Get the scale factor.  Default = 0.2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricDini.SetB(System.Double)">
            <summary>
                <para>Set/Get the scale factor.  Default = 0.2</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricDini.GetA">
            <summary>
                <para>Set/Get the scale factor.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricDini.SetA(System.Double)">
            <summary>
                <para>Set/Get the scale factor.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricDini.GetDimension">
            <summary>
                <para>Set/Get the scale factor.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkBox.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkBox.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkBox.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkBox.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkBox.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkBox.IntersectBox(System.Double[],System.Double[],System.Double[],System.Double[],System.Double@)">
            <summary>
                <para>Bounding box intersection modified from Graphics Gems Vol I. The method returns a non-zero value if the bounding box is hit. Origin[3] starts the ray, dir[3] is the vector components of the ray in the x-y-z directions, coord[3] is the location of hit, and t is the parametric coordinate along line. (Notes: the intersection ray dir[3] is NOT normalized.  Valid intersections will only occur between 0&lt;=t&lt;=1.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.GetBounds(System.Double[])">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.GetBounds(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.SetBounds(System.Double[])">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.SetBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.GetXMax">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.SetXMax(System.Double[])">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.SetXMax(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.GetXMin">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.SetXMin(System.Double[])">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkBox.SetXMin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set / get the bounding box using various methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>A superellipsoid.</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.GetN2">
            <summary>
                <para>Set/Get the "squareness" parameter in the x-y plane. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.SetN2(System.Double)">
            <summary>
                <para>Set/Get the "squareness" parameter in the x-y plane. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.GetN1">
            <summary>
                <para>Set/Get the "squareness" parameter in the z axis.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.SetN1(System.Double)">
            <summary>
                <para>Set/Get the "squareness" parameter in the z axis.  Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.GetZRadius">
            <summary>
                <para>Set/Get the scaling factor for the z-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.SetZRadius(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the z-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.GetYRadius">
            <summary>
                <para>Set/Get the scaling factor for the y-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.SetYRadius(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the y-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.GetXRadius">
            <summary>
                <para>Set/Get the scaling factor for the x-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.SetXRadius(System.Double)">
            <summary>
                <para>Set/Get the scaling factor for the x-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricSuperEllipsoid.GetDimension">
            <summary>
                <para>Set/Get the scaling factor for the x-axis. Default = 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAnimationScene.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.SetTimeMode(System.Int32)">
            <summary>
                <para>Overridden to allow change to Normalized mode only if none of the constituent cues is in Relative time mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.SetAnimationTime(System.Double)">
            <summary>
                <para>Makes the state of the scene same as the given time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.GetLoop">
            <summary>
                <para>Enable/Disable animation loop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.SetLoop(System.Int32)">
            <summary>
                <para>Enable/Disable animation loop.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.Stop">
            <summary>
                <para>Stops the animation scene that is running.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.Play">
            <summary>
                <para>Starts playing the animation scene.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.RemoveCue(vtk.vtkAnimationCue)">
            <summary>
                <para>Add/Remove an AnimationCue to/from the Scene. It's an error to add a cue twice to the Scene.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.AddCue(vtk.vtkAnimationCue)">
            <summary>
                <para>Add/Remove an AnimationCue to/from the Scene. It's an error to add a cue twice to the Scene.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.GetFrameRate">
            <summary>
                <para>Get/Set the frame rate (in frames per second). This parameter affects only in the Sequence mode. The time interval indicated to each cue on every tick is progressed by 1/frame-rate seconds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.SetFrameRate(System.Double)">
            <summary>
                <para>Get/Set the frame rate (in frames per second). This parameter affects only in the Sequence mode. The time interval indicated to each cue on every tick is progressed by 1/frame-rate seconds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.GetPlayMode">
            <summary>
                <para>Get/Set the PlayMode for running/playing the animation scene. In the Sequence mode, all the frames are generated one after the other. The time reported to each Tick of the constituent cues (during Play) is incremented by 1/frame rate, irrespective of the current time. In the RealTime mode, time indicates the instance in time. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.SetModeToRealTime">
            <summary>
                <para>Get/Set the PlayMode for running/playing the animation scene. In the Sequence mode, all the frames are generated one after the other. The time reported to each Tick of the constituent cues (during Play) is incremented by 1/frame rate, irrespective of the current time. In the RealTime mode, time indicates the instance in time. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.SetModeToSequence">
            <summary>
                <para>Get/Set the PlayMode for running/playing the animation scene. In the Sequence mode, all the frames are generated one after the other. The time reported to each Tick of the constituent cues (during Play) is incremented by 1/frame rate, irrespective of the current time. In the RealTime mode, time indicates the instance in time. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationScene.SetPlayMode(System.Int32)">
            <summary>
                <para>Get/Set the PlayMode for running/playing the animation scene. In the Sequence mode, all the frames are generated one after the other. The time reported to each Tick of the constituent cues (during Play) is incremented by 1/frame rate, irrespective of the current time. In the RealTime mode, time indicates the instance in time. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.InsertNextValue(System.Byte)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.InsertValue(System.Int32,System.Byte)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.SetValue(System.Int32,System.Byte)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.InsertNextTupleValue(System.Byte[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.InsertTupleValue(System.Int32,System.Byte[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.SetTupleValue(System.Int32,System.Byte[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.GetTupleValue(System.Int32,System.Byte[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkUnsignedCharArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkScalarsToColors.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.ConvertUnsignedCharToRGBA(vtk.vtkUnsignedCharArray,System.Int32,System.Int32)">
            <summary>
                <para>An internal method used to convert a color array to RGBA. The method instantiates a vtkUnsignedCharArray and returns it. The user is responsible for managing the memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.MapScalarsThroughTable2(System.IntPtr,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>An internal method typically not used in applications.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.MapScalarsThroughTable(vtk.vtkDataArray,System.Byte[])">
            <summary>
                <para>An internal method typically not used in applications.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.MapScalarsThroughTable(vtk.vtkDataArray,System.Byte[],System.Int32)">
            <summary>
                <para>Map a set of scalars through the lookup table in a single operation.  The output format can be set to VTK_RGBA (4 components),  VTK_RGB (3 components), VTK_LUMINANCE (1 component, greyscale), or VTK_LUMINANCE_ALPHA (2 components) If not supplied, the output format defaults to RGBA.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.GetVectorComponent">
            <summary>
                <para>If the mapper does not select which component of a vector to map to colors, you can specify it here.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.SetVectorComponent(System.Int32)">
            <summary>
                <para>If the mapper does not select which component of a vector to map to colors, you can specify it here.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.SetVectorModeToComponent">
            <summary>
                <para>Change mode that maps vectors by magnitude vs. component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.SetVectorModeToMagnitude">
            <summary>
                <para>Change mode that maps vectors by magnitude vs. component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.GetVectorMode">
            <summary>
                <para>Change mode that maps vectors by magnitude vs. component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.SetVectorMode(System.Int32)">
            <summary>
                <para>Change mode that maps vectors by magnitude vs. component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.MapScalars(vtk.vtkDataArray,System.Int32,System.Int32)">
            <summary>
                <para>An internal method maps a data array into a 4-component, unsigned char RGBA array. The color mode determines the behavior of mapping. If  VTK_COLOR_MODE_DEFAULT is set, then unsigned char data arrays are treated as colors (and converted to RGBA if necessary); otherwise,  the data is mapped through this instance of ScalarsToColors. The offset is used for data arrays with more than one component; it indicates  which component to use to do the blending. When the component argument is -1, then the this object uses its own selected technique to change a vector into a scalar to map.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.GetAlpha">
            <summary>
                <para>Specify an additional opacity (alpha) value to blend with. Values != 1 modify the resulting color consistent with the requested form of the output. This is typically used by an actor in order to blend its opacity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.SetAlpha(System.Double)">
            <summary>
                <para>Specify an additional opacity (alpha) value to blend with. Values != 1 modify the resulting color consistent with the requested form of the output. This is typically used by an actor in order to blend its opacity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.GetLuminance(System.Double)">
            <summary>
                <para>Specify an additional opacity (alpha) value to blend with. Values != 1 modify the resulting color consistent with the requested form of the output. This is typically used by an actor in order to blend its opacity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.GetOpacity(System.Double)">
            <summary>
                <para>Map one value through the lookup table and return the luminance 0.3*red + 0.59*green + 0.11*blue as a double between 0 and 1. Returns the luminance value for the specified scalar value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.GetColor(System.Double)">
            <summary>
                <para>Map one value through the lookup table and return the alpha value (the opacity) as a double between 0 and 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.GetColor(System.Double,System.Double[])">
            <summary>
                <para>Map one value through the lookup table and return the color as an RGB array of doubles between 0 and 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.SetRange(System.Double[])">
            <summary>
                <para>Map one value through the lookup table and return a color defined as a RGBA unsigned char tuple (4 bytes).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.SetRange(System.Double,System.Double)">
            <summary>
                <para>Sets/Gets the range of scalars which will be mapped.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarsToColors.Build">
            <summary>
                <para>Perform any processing required (if any) before processing  scalars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCharArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCharArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCharArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCharArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCharArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCharArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCharArray.GetPointer(System.Int32)">
            <summary>
                <para>This method lets the user specify data to be held by the array.  The array argument is a pointer to the data.  size is the size of the array supplied by the user.  Set save to 1 to keep the class from deleting the array when it cleans up or reallocates memory. The class uses the actual array provided; it does not copy the data from the suppled array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.WritePointer(System.Int32,System.Int32)">
            <summary>
                <para>Get the address of a particular data index. Performs no checks to verify that the memory has been allocated etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.InsertNextValue(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.InsertValue(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.SetValue(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.InsertNextTupleValue(System.String)">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.InsertTupleValue(System.Int32,System.String)">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.SetTupleValue(System.Int32,System.String)">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.GetTupleValue(System.Int32,System.String)">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCharArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta4.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta4.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta4.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRungeKutta4.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta4.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta4.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRungeKutta4.ComputeNextStep(System.Double[],System.Double[],System.Double[],System.Double,System.Double@,System.Double@,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delT (xnext). delTActual is always equal to delT. Since this class can not provide an estimate for the error error is set to 0.   maxStep, minStep and maxError are unused. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta4.ComputeNextStep(System.Double[],System.Double[],System.Double,System.Double@,System.Double@,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delT (xnext). delTActual is always equal to delT. Since this class can not provide an estimate for the error error is set to 0.   maxStep, minStep and maxError are unused. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta4.ComputeNextStep(System.Double[],System.Double[],System.Double[],System.Double,System.Double@,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delT (xnext). delTActual is always equal to delT. Since this class can not provide an estimate for the error error is set to 0.   maxStep, minStep and maxError are unused. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRungeKutta4.ComputeNextStep(System.Double[],System.Double[],System.Double,System.Double@,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delT (xnext). delTActual is always equal to delT. Since this class can not provide an estimate for the error error is set to 0.   maxStep, minStep and maxError are unused. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.GetFunctionSet">
            <summary>
                <para>Set / get the dataset used for the implicit function evaluation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.SetFunctionSet(vtk.vtkFunctionSet)">
            <summary>
                <para>Set / get the dataset used for the implicit function evaluation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.ComputeNextStep(System.Double[],System.Double[],System.Double[],System.Double,System.Double@,System.Double@,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delTActual (xnext). For certain concrete sub-classes delTActual != delT. This occurs when the solver supports adaptive stepsize control. If this is the case, the solver tries to change to stepsize such that the (estimated) error of the integration is less than maxError. The solver will not set the stepsize smaller than minStep or larger than maxStep. Also note that delT is an in/out argument. Adaptive solvers will modify delT to reflect the best (estimated) size for the next integration step. An estimated value for the error is returned (by reference) in error. Note that only some concrete sub-classes support this. Otherwise, the error is set to 0. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.ComputeNextStep(System.Double[],System.Double[],System.Double,System.Double@,System.Double@,System.Double,System.Double,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delTActual (xnext). For certain concrete sub-classes delTActual != delT. This occurs when the solver supports adaptive stepsize control. If this is the case, the solver tries to change to stepsize such that the (estimated) error of the integration is less than maxError. The solver will not set the stepsize smaller than minStep or larger than maxStep. Also note that delT is an in/out argument. Adaptive solvers will modify delT to reflect the best (estimated) size for the next integration step. An estimated value for the error is returned (by reference) in error. Note that only some concrete sub-classes support this. Otherwise, the error is set to 0. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.ComputeNextStep(System.Double[],System.Double[],System.Double[],System.Double,System.Double@,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delTActual (xnext). For certain concrete sub-classes delTActual != delT. This occurs when the solver supports adaptive stepsize control. If this is the case, the solver tries to change to stepsize such that the (estimated) error of the integration is less than maxError. The solver will not set the stepsize smaller than minStep or larger than maxStep. Also note that delT is an in/out argument. Adaptive solvers will modify delT to reflect the best (estimated) size for the next integration step. An estimated value for the error is returned (by reference) in error. Note that only some concrete sub-classes support this. Otherwise, the error is set to 0. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInitialValueProblemSolver.ComputeNextStep(System.Double[],System.Double[],System.Double,System.Double@,System.Double,System.Double@)">
            <summary>
                <para>Given initial values, xprev , initial time, t and a requested time  interval, delT calculate values of x at t+delTActual (xnext). For certain concrete sub-classes delTActual != delT. This occurs when the solver supports adaptive stepsize control. If this is the case, the solver tries to change to stepsize such that the (estimated) error of the integration is less than maxError. The solver will not set the stepsize smaller than minStep or larger than maxStep. Also note that delT is an in/out argument. Adaptive solvers will modify delT to reflect the best (estimated) size for the next integration step. An estimated value for the error is returned (by reference) in error. Note that only some concrete sub-classes support this. Otherwise, the error is set to 0. This method returns an error code representing the nature of the failure: OutOfDomain = 1, NotInitialized = 2, UnexpectedValue = 3</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPoints.GetBounds(System.Double[])">
            <summary>
                <para>Return the bounds of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.GetBounds">
            <summary>
                <para>Return the bounds of the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.ComputeBounds">
            <summary>
                <para>Determine (xmin,xmax, ymin,ymax, zmin,zmax) bounds of points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.GetPoints(vtk.vtkIdList,vtk.vtkPoints)">
            <summary>
                <para>Given a list of pt ids, return an array of points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetNumberOfPoints(System.Int32)">
            <summary>
                <para>Specify the number of points for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetPoint() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.InsertNextPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Insert point into next available slot. Returns id of slot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.InsertNextPoint(System.Double[])">
            <summary>
                <para>Insert point into next available slot. Returns id of slot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.InsertNextPoint(System.Single[])">
            <summary>
                <para>Insert point into next available slot. Returns id of slot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.InsertPoint(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                <para>Insert point into object. Range checking performed and memory allocated as necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.InsertPoint(System.Int32,System.Double[])">
            <summary>
                <para>Insert point into object. Range checking performed and memory allocated as necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.InsertPoint(System.Int32,System.Single[])">
            <summary>
                <para>Insert point into object. Range checking performed and memory allocated as necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetPoint(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                <para>Insert point into object. No range checking performed (fast!). Make sure you use SetNumberOfPoints() to allocate memory prior to using SetPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetPoint(System.Int32,System.Double[])">
            <summary>
                <para>Insert point into object. No range checking performed (fast!). Make sure you use SetNumberOfPoints() to allocate memory prior to using SetPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetPoint(System.Int32,System.Single[])">
            <summary>
                <para>Insert point into object. No range checking performed (fast!). Make sure you use SetNumberOfPoints() to allocate memory prior to using SetPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.GetPoint(System.Int32,System.Double[])">
            <summary>
                <para>Copy point components into user provided array v[3] for specified id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.GetPoint(System.Int32)">
            <summary>
                <para>Return a pointer to a double point x[3] for a specific id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.GetNumberOfPoints">
            <summary>
                <para>Return number of points in array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.GetActualMemorySize">
            <summary>
                <para>Return the memory in kilobytes consumed by this attribute data.  Used to support streaming and reading/writing data. The value  returned is guaranteed to be greater than or equal to the  memory required to actually represent the data represented  by this object. The information returned is valid only after the pipeline has been updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.ShallowCopy(vtk.vtkPoints)">
            <summary>
                <para>Different ways to copy data. Shallow copy does reference count (i.e., assigns pointers and updates reference count); deep copy runs through entire data array assigning values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.DeepCopy(vtk.vtkPoints)">
            <summary>
                <para>Different ways to copy data. Shallow copy does reference count (i.e., assigns pointers and updates reference count); deep copy runs through entire data array assigning values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.Reset">
            <summary>
                <para>Make object look empty but do not delete memory.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.Squeeze">
            <summary>
                <para>Reclaim any extra memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.GetVoidPointer(System.Int32)">
            <summary>
                <para>Return a void pointer. For image pipeline interface and other  special pointer manipulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToDouble">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToFloat">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToUnsignedLong">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToLong">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToUnsignedInt">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToInt">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToUnsignedShort">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToShort">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToUnsignedChar">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToChar">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataTypeToBit">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetDataType(System.Int32)">
            <summary>
                <para>Specify the underlying data type of the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.GetDataType">
            <summary>
                <para>Return the underlying data type. An integer indicating data type is  returned as specified in vtkSetGet.h.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.GetData">
            <summary>
                <para>Set/Get the underlying data array. This function must be implemented in a concrete subclass to check for consistency. (The tuple size must match the type of data. For example, 3-tuple data array can be assigned to a vector, normal, or points object, but not a tensor object, which has a  tuple dimension of 9. Scalars, on the other hand, can have tuple dimension  from 1-4, depending on the type of scalar.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.SetData(vtk.vtkDataArray)">
            <summary>
                <para>Set/Get the underlying data array. This function must be implemented in a concrete subclass to check for consistency. (The tuple size must match the type of data. For example, 3-tuple data array can be assigned to a vector, normal, or points object, but not a tensor object, which has a  tuple dimension of 9. Scalars, on the other hand, can have tuple dimension  from 1-4, depending on the type of scalar.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.Initialize">
            <summary>
                <para>Return object to instantiated state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPoints.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate initial memory size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkIdentityTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.MakeTransform">
            <summary>
                <para>Make a transform of the same type.  This will actually return the same transform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.InternalTransformDerivative(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>This will calculate the transformation as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.InternalTransformDerivative(System.Single[],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>This will calculate the transformation as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.InternalTransformVector(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.InternalTransformVector(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.InternalTransformNormal(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.InternalTransformNormal(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.InternalTransformPoint(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.InternalTransformPoint(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.TransformPointsNormalsVectors(vtk.vtkPoints,vtk.vtkPoints,vtk.vtkDataArray,vtk.vtkDataArray,vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Apply the transformation to a combination of points, normals and vectors.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.TransformVectors(vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Apply the transformation to a series of vectors, and append the results to outVrs.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.TransformNormals(vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Apply the transformation to a series of normals, and append the results to outNms.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdentityTransform.TransformPoints(vtk.vtkPoints,vtk.vtkPoints)">
            <summary>
                <para>Apply the transformation to a series of points, and append the results to outPts.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLinearTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.InternalTransformDerivative(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>This will calculate the transformation as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.InternalTransformDerivative(System.Single[],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>This will calculate the transformation as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.InternalTransformVector(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.InternalTransformVector(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.InternalTransformNormal(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.InternalTransformNormal(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.InternalTransformPoint(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.InternalTransformPoint(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.GetLinearInverse">
            <summary>
                <para>Just like GetInverse, but it includes a typecast to  vtkLinearTransform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformPointsNormalsVectors(vtk.vtkPoints,vtk.vtkPoints,vtk.vtkDataArray,vtk.vtkDataArray,vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Apply the transformation to a combination of points, normals and vectors.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformVectors(vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Apply the transformation to a series of vectors, and append the results to outVrs.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformNormals(vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Apply the transformation to a series of normals, and append the results to outNms.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformPoints(vtk.vtkPoints,vtk.vtkPoints)">
            <summary>
                <para>Apply the transformation to a series of points, and append the results to outPts.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformDoubleVector(System.Double[])">
            <summary>
                <para>Apply the transformation to a double-precision (x,y,z) vector. Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformDoubleVector(System.Double,System.Double,System.Double)">
            <summary>
                <para>Apply the transformation to a double-precision (x,y,z) vector. Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformFloatVector(System.Single[])">
            <summary>
                <para>Apply the transformation to an (x,y,z) vector. Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformFloatVector(System.Single,System.Single,System.Single)">
            <summary>
                <para>Apply the transformation to an (x,y,z) vector. Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformVector(System.Double[],System.Double[])">
            <summary>
                <para>Apply the transformation to a double-precision vector. You can use the same array to store both the input and output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformVector(System.Single[],System.Single[])">
            <summary>
                <para>Apply the transformation to a vector. You can use the same array to store both the input and output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformVector(System.Double[])">
            <summary>
                <para>Synonymous with TransformDoubleVector(x,y,z). Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformVector(System.Double,System.Double,System.Double)">
            <summary>
                <para>Synonymous with TransformDoubleVector(x,y,z). Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformDoubleNormal(System.Double[])">
            <summary>
                <para>Apply the transformation to a double-precision (x,y,z) normal. Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformDoubleNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Apply the transformation to a double-precision (x,y,z) normal. Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformFloatNormal(System.Single[])">
            <summary>
                <para>Apply the transformation to an (x,y,z) normal. Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformFloatNormal(System.Single,System.Single,System.Single)">
            <summary>
                <para>Apply the transformation to an (x,y,z) normal. Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformNormal(System.Double[])">
            <summary>
                <para>Synonymous with TransformDoubleNormal(x,y,z). Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>Synonymous with TransformDoubleNormal(x,y,z). Use this if you are programming in python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformNormal(System.Double[],System.Double[])">
            <summary>
                <para>Apply the transformation to a double-precision normal. You can use the same array to store both the input and output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLinearTransform.TransformNormal(System.Single[],System.Single[])">
            <summary>
                <para>Apply the transformation to a normal. You can use the same array to store both the input and output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.InternalTransformDerivative(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>This will calculate the transformation as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.InternalTransformDerivative(System.Single[],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>This will calculate the transformation as well as its derivative without calling Update.  Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.InternalTransformPoint(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.InternalTransformPoint(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.GetHomogeneousInverse">
            <summary>
                <para>Just like GetInverse(), but includes typecast to vtkHomogeneousTransform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.GetMatrix">
            <summary>
                <para>Get a pointer to an internal vtkMatrix4x4 that represents the transformation.  An Update() is called on the transform to ensure that the matrix is up-to-date when you get it. You should not store the matrix pointer anywhere because it might become stale.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.GetMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>Get a copy of the internal transformation matrix.  The transform is Updated first, to guarantee that the matrix is valid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.TransformPointsNormalsVectors(vtk.vtkPoints,vtk.vtkPoints,vtk.vtkDataArray,vtk.vtkDataArray,vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Apply the transformation to a combination of points, normals and vectors.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkHomogeneousTransform.TransformPoints(vtk.vtkPoints,vtk.vtkPoints)">
            <summary>
                <para>Apply the transformation to a series of points, and append the results to outPts.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAbstractTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.Identity">
            <summary>
                <para>@deprecated This method is deprecated in the base class.  It is  still valid to use it on many of the specialized classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Needs a special UnRegister() implementation to avoid circular references.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.GetMTime">
            <summary>
                <para>Override GetMTime necessary because of inverse transforms.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.CircuitCheck(vtk.vtkAbstractTransform)">
            <summary>
                <para>Check for self-reference.  Will return true if concatenating with the specified transform, setting it to be our inverse, or setting it to be our input will create a circular reference. CircuitCheck is automatically called by SetInput(), SetInverse(), and Concatenate(vtkXTransform *).  Avoid using this function, it is experimental.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.MakeTransform">
            <summary>
                <para>Make another transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.InternalTransformDerivative(System.Double[],System.Double[],System.Double[0:,0:])">
            <summary>
                <para>This will transform a point and, at the same time, calculate a 3x3 Jacobian matrix that provides the partial derivatives of the transformation at that point.  This method does not call Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.InternalTransformDerivative(System.Single[],System.Single[],System.Single[0:,0:])">
            <summary>
                <para>This will transform a point and, at the same time, calculate a 3x3 Jacobian matrix that provides the partial derivatives of the transformation at that point.  This method does not call Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.InternalTransformPoint(System.Double[],System.Double[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.InternalTransformPoint(System.Single[],System.Single[])">
            <summary>
                <para>This will calculate the transformation without calling Update. Meant for use only within other VTK classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.Update">
            <summary>
                <para>Update the transform to account for any changes which have been made.  You do not have to call this method  yourself, it is called automatically whenever the transform needs an update.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.DeepCopy(vtk.vtkAbstractTransform)">
            <summary>
                <para>Copy this transform from another of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.Inverse">
            <summary>
                <para>Invert the transformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.SetInverse(vtk.vtkAbstractTransform)">
            <summary>
                <para>Set a transformation that this transform will be the inverse of. This transform will automatically update to agree with the  inverse transform that you set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.GetInverse">
            <summary>
                <para>Get the inverse of this transform.  If you modify this transform, the returned inverse transform will automatically update.  If you want the inverse of a vtkTransform, you might want to use GetLinearInverse() instead which will type cast the result from vtkAbstractTransform to vtkLinearTransform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformPointsNormalsVectors(vtk.vtkPoints,vtk.vtkPoints,vtk.vtkDataArray,vtk.vtkDataArray,vtk.vtkDataArray,vtk.vtkDataArray)">
            <summary>
                <para>Apply the transformation to a combination of points, normals and vectors.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformPoints(vtk.vtkPoints,vtk.vtkPoints)">
            <summary>
                <para>Apply the transformation to a series of points, and append the results to outPts.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformFloatVectorAtPoint(System.Single[],System.Single[])">
            <summary>
                <para>Apply the transformation to a single-precision vector at the specified vertex.  If the transformation is a vtkLinearTransform, you can use TransformFloatVector() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformDoubleVectorAtPoint(System.Double[],System.Double[])">
            <summary>
                <para>Apply the transformation to a double-precision vector at the specified vertex.  If the transformation is a vtkLinearTransform, you can use TransformDoubleVector() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformVectorAtPoint(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Apply the transformation to a vector at the specified vertex.  If the transformation is a vtkLinearTransform, you can use TransformVector() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformVectorAtPoint(System.Single[],System.Single[],System.Single[])">
            <summary>
                <para>Apply the transformation to a vector at the specified vertex.  If the transformation is a vtkLinearTransform, you can use TransformVector() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformFloatNormalAtPoint(System.Single[],System.Single[])">
            <summary>
                <para>Apply the transformation to a single-precision normal at the specified vertex.  If the transformation is a vtkLinearTransform, you can use TransformFloatNormal() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformDoubleNormalAtPoint(System.Double[],System.Double[])">
            <summary>
                <para>Apply the transformation to a double-precision normal at the specified vertex.  If the transformation is a vtkLinearTransform, you can use TransformDoubleNormal() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformNormalAtPoint(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Apply the transformation to a normal at the specified vertex.  If the transformation is a vtkLinearTransform, you can use TransformNormal() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformNormalAtPoint(System.Single[],System.Single[],System.Single[])">
            <summary>
                <para>Apply the transformation to a normal at the specified vertex.  If the transformation is a vtkLinearTransform, you can use TransformNormal() instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformDoublePoint(System.Double[])">
            <summary>
                <para>Apply the transformation to a double-precision (x,y,z) coordinate. Use this if you are programming in Python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformDoublePoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Apply the transformation to a double-precision (x,y,z) coordinate. Use this if you are programming in Python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformFloatPoint(System.Single[])">
            <summary>
                <para>Apply the transformation to an (x,y,z) coordinate. Use this if you are programming in Python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformFloatPoint(System.Single,System.Single,System.Single)">
            <summary>
                <para>Apply the transformation to an (x,y,z) coordinate. Use this if you are programming in Python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformPoint(System.Double[])">
            <summary>
                <para>Apply the transformation to a double-precision coordinate.   Use this if you are programming in Python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Apply the transformation to a double-precision coordinate.   Use this if you are programming in Python, tcl or Java.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformPoint(System.Double[],System.Double[])">
            <summary>
                <para>Apply the transformation to a double-precision coordinate.   You can use the same array to store both the input and output point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractTransform.TransformPoint(System.Single[],System.Single[])">
            <summary>
                <para>Apply the transformation to a coordinate.  You can use the same  array to store both the input and output point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitFunction.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.EvaluateGradient(System.Double[],System.Double[])">
            <summary>
                <para>Evaluate function gradient at position x-y-z and pass back vector.  You should generally not call this method directly, you should use  FunctionGradient() instead.  This method must be implemented by  any derived class. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.EvaluateFunction(System.Double,System.Double,System.Double)">
            <summary>
                <para>Evaluate function at position x-y-z and return value.  You should generally not call this method directly, you should use  FunctionValue() instead.  This method must be implemented by  any derived class. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.EvaluateFunction(System.Double[])">
            <summary>
                <para>Evaluate function at position x-y-z and return value.  You should generally not call this method directly, you should use  FunctionValue() instead.  This method must be implemented by  any derived class. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.GetTransform">
            <summary>
                <para>Set/Get a transformation to apply to input points before executing the implicit function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.SetTransform(System.Double[])">
            <summary>
                <para>Set/Get a transformation to apply to input points before executing the implicit function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.SetTransform(vtk.vtkAbstractTransform)">
            <summary>
                <para>Set/Get a transformation to apply to input points before executing the implicit function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.FunctionGradient(System.Double,System.Double,System.Double)">
            <summary>
                <para>Evaluate function gradient at position x-y-z and pass back vector. Point x[3] is transformed through transform (if provided).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.FunctionGradient(System.Double[])">
            <summary>
                <para>Evaluate function gradient at position x-y-z and pass back vector. Point x[3] is transformed through transform (if provided).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.FunctionGradient(System.Double[],System.Double[])">
            <summary>
                <para>Evaluate function gradient at position x-y-z and pass back vector. Point x[3] is transformed through transform (if provided).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.FunctionValue(System.Double,System.Double,System.Double)">
            <summary>
                <para>Evaluate function at position x-y-z and return value. Point x[3] is transformed through transform (if provided).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.FunctionValue(System.Double[])">
            <summary>
                <para>Evaluate function at position x-y-z and return value. Point x[3] is transformed through transform (if provided).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunction.GetMTime">
            <summary>
                <para>Overload standard modified time function. If Transform is modified, then this object is modified as well.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunctionCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitFunctionCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunctionCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitFunctionCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitFunctionCollection.GetNextItem">
            <summary>
                <para>Get the next implicit function in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitFunctionCollection.AddItem(vtk.vtkImplicitFunction)">
            <summary>
                <para>Add an implicit function to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkIdList.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkIdList.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkIdList.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkIdList.IsId(System.Int32)">
            <summary>
                <para>Return -1 if id specified is not contained in the list; otherwise return the position in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.DeleteId(System.Int32)">
            <summary>
                <para>Delete specified id from list. Will remove all occurrences of id in list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.DeepCopy(vtk.vtkIdList)">
            <summary>
                <para>Copy an id list by explicitly copying the internal array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.Squeeze">
            <summary>
                <para>Free any unused memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.Reset">
            <summary>
                <para>Reset to an empty state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.InsertUniqueId(System.Int32)">
            <summary>
                <para>If id is not already in list, insert it and return location in list. Otherwise return just location in list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.InsertNextId(System.Int32)">
            <summary>
                <para>Add the id specified to the end of the list. Range checking is performed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.InsertId(System.Int32,System.Int32)">
            <summary>
                <para>Set the id at location i. Does range checking and allocates memory as necessary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.SetId(System.Int32,System.Int32)">
            <summary>
                <para>Set the id at location i. Doesn't do range checking so it's a bit faster than InsertId. Make sure you use SetNumberOfIds() to allocate memory prior to using SetId().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.SetNumberOfIds(System.Int32)">
            <summary>
                <para>Specify the number of ids for this object to hold. Does an allocation as well as setting the number of ids.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.GetId(System.Int32)">
            <summary>
                <para>Return the id at location i.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdList.GetNumberOfIds">
            <summary>
                <para>Return the number of id's in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkStructuredData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkStructuredData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkStructuredData.ComputePointId(System.Int32[],System.Int32[])">
            <summary>
                <para>Given a location in structured coordinates (i-j-k), and the dimensions of the structured dataset, return the cell id.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredData.GetCellNeighbors(System.Int32,vtk.vtkIdList,vtk.vtkIdList,System.Int32[])">
            <summary>
                <para>Get the cells using the points ptIds, exclusive of the cell cellId.  (See vtkDataSet for more info.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredData.GetPointCells(System.Int32,vtk.vtkIdList,System.Int32[])">
            <summary>
                <para>Get the cells using a point. (See vtkDataSet for more info.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredData.GetCellPoints(System.Int32,vtk.vtkIdList,System.Int32,System.Int32[])">
            <summary>
                <para>Get the points defining a cell. (See vtkDataSet for more info.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredData.GetDataDimension(System.Int32)">
            <summary>
                <para>Return the topological dimension of the data (e.g., 0, 1, 2, or 3D).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredData.SetExtent(System.Int32[],System.Int32[])">
            <summary>
                <para>Specify the dimensions of a regular, rectangular dataset. The input is the new dimensions (inDim) and the current dimensions (dim). The function  returns the dimension of the dataset (0-3D). If the dimensions are  improperly specified a -1 is returned. If the dimensions are unchanged, a value of 100 is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkStructuredData.SetDimensions(System.Int32[],System.Int32[])">
            <summary>
                <para>Specify the dimensions of a regular, rectangular dataset. The input is the new dimensions (inDim) and the current dimensions (dim). The function  returns the dimension of the dataset (0-3D). If the dimensions are  improperly specified a -1 is returned. If the dimensions are unchanged, a value of 100 is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMultiThreader.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.GetGlobalDefaultNumberOfThreads">
            <summary>
                <para>Set/Get the value which is used to initialize the NumberOfThreads in the constructor.  Initially this default is set to the number of  processors or VTK_MAX_THREADS (which ever is less).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.SetGlobalDefaultNumberOfThreads(System.Int32)">
            <summary>
                <para>Set/Get the value which is used to initialize the NumberOfThreads in the constructor.  Initially this default is set to the number of  processors or VTK_MAX_THREADS (which ever is less).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.GetGlobalMaximumNumberOfThreads">
            <summary>
                <para>Set/Get the maximum number of threads to use when multithreading. This limits and overrides any other settings for multithreading. A value of zero indicates no limit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.SetGlobalMaximumNumberOfThreads(System.Int32)">
            <summary>
                <para>Set/Get the maximum number of threads to use when multithreading. This limits and overrides any other settings for multithreading. A value of zero indicates no limit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.GetNumberOfThreads">
            <summary>
                <para>Get/Set the number of threads to create. It will be clamped to the range 1 - VTK_MAX_THREADS, so the caller of this method should check that the requested number of threads was accepted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.GetNumberOfThreadsMaxValue">
            <summary>
                <para>Get/Set the number of threads to create. It will be clamped to the range 1 - VTK_MAX_THREADS, so the caller of this method should check that the requested number of threads was accepted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.GetNumberOfThreadsMinValue">
            <summary>
                <para>Get/Set the number of threads to create. It will be clamped to the range 1 - VTK_MAX_THREADS, so the caller of this method should check that the requested number of threads was accepted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMultiThreader.SetNumberOfThreads(System.Int32)">
            <summary>
                <para>Get/Set the number of threads to create. It will be clamped to the range 1 - VTK_MAX_THREADS, so the caller of this method should check that the requested number of threads was accepted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAnimationCue.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.FinalizeWrap">
            <summary>
                <para>Called when the scene reaches the end. If the cue state is ACTIVE when this method is called, this will trigger a EndAnimationCueEvent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.Initialize">
            <summary>
                <para>Called when the playing of the scene begins. This will set the Cue to UNINITIALIZED state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.Tick(System.Double,System.Double)">
            <summary>
                <para>Indicates a tick or point in time in the animation. Triggers a Tick event if currenttime &gt;= StartTime and currenttime &lt;= EndTime. Whenever the state of the cue changes, either StartEvent or EndEvent is triggerred depending upon  whether the cue entered Active state or quit active state respectively. The current time is relative to the start of the container Scene  (when in Relative time mode) or is normalized over the span of the container Scene (when in Normalized time mode). deltatime is the time since last call to Tick. deltatime also can be in seconds relative to the start of the container Scene or normalized depending upon the cue's Time mode. For the first call to Tick after a call to Initialize(), the deltatime is 0;</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.GetEndTime">
            <summary>
                <para>Get/Set the End time for this cue. When the current time is &gt; EndTime, the Cue is in INACTIVE state. Whenever the cue leaves an ACTIVE state to enter  INACTIVE state, the EndEvent is triggered. The End time is in seconds relative to the start of the  container Scene (when in Relative time mode) or is normalized over the span of the container Scene (when in Normalized time mode).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.SetEndTime(System.Double)">
            <summary>
                <para>Get/Set the End time for this cue. When the current time is &gt; EndTime, the Cue is in INACTIVE state. Whenever the cue leaves an ACTIVE state to enter  INACTIVE state, the EndEvent is triggered. The End time is in seconds relative to the start of the  container Scene (when in Relative time mode) or is normalized over the span of the container Scene (when in Normalized time mode).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.GetStartTime">
            <summary>
                <para>Get/Set the Start time for this cue. When the current time is &gt;= StartTime, the Cue is in ACTIVE state. if Current time i &lt; StartTime, the Cue is in UNINITIALIZED state. Whenever the cue enters the ACTIVE state from an INACTIVE state, it triggers the StartEvent. The Start time is in seconds relative to the start of the  container Scene (when in Relative time mode) or is normalized over the span of the container Scene (when in Normalized time mode).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.SetStartTime(System.Double)">
            <summary>
                <para>Get/Set the Start time for this cue. When the current time is &gt;= StartTime, the Cue is in ACTIVE state. if Current time i &lt; StartTime, the Cue is in UNINITIALIZED state. Whenever the cue enters the ACTIVE state from an INACTIVE state, it triggers the StartEvent. The Start time is in seconds relative to the start of the  container Scene (when in Relative time mode) or is normalized over the span of the container Scene (when in Normalized time mode).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.SetTimeModeToNormalized">
            <summary>
                <para>Get/Set the Start time for this cue. When the current time is &gt;= StartTime, the Cue is in ACTIVE state. if Current time i &lt; StartTime, the Cue is in UNINITIALIZED state. Whenever the cue enters the ACTIVE state from an INACTIVE state, it triggers the StartEvent. The Start time is in seconds relative to the start of the  container Scene (when in Relative time mode) or is normalized over the span of the container Scene (when in Normalized time mode).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.SetTimeModeToRelative">
            <summary>
                <para>Get/Set the time mode. In Normalized mode, the start and end  times of the cue are normalized [0,1] with respect to the start and  end times of the container scene. In Relative mode the start and end time of the cue are specified in offset seconds relative to the  start time of the container scene.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.GetTimeMode">
            <summary>
                <para>Get/Set the time mode. In Normalized mode, the start and end  times of the cue are normalized [0,1] with respect to the start and  end times of the container scene. In Relative mode the start and end time of the cue are specified in offset seconds relative to the  start time of the container scene.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnimationCue.SetTimeMode(System.Int32)">
            <summary>
                <para>Get/Set the time mode. In Normalized mode, the start and end  times of the cue are normalized [0,1] with respect to the start and  end times of the container scene. In Relative mode the start and end time of the cue are specified in offset seconds relative to the  start time of the container scene.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkIdTypeArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.InsertNextValue(System.Int32)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.InsertValue(System.Int32,System.Int32)">
            <summary>
                <para>Insert data at the end of the array. Return its location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.SetNumberOfValues(System.Int32)">
            <summary>
                <para>Insert data at a specified position in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.SetValue(System.Int32,System.Int32)">
            <summary>
                <para>Specify the number of values for this object to hold. Does an allocation as well as setting the MaxId ivar. Used in conjunction with SetValue() method for fast insertion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.GetValue(System.Int32)">
            <summary>
                <para>Set the data at a particular index. Does not do range checking. Make sure you use the method SetNumberOfValues() before inserting data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.InsertNextTupleValue(System.Int32[])">
            <summary>
                <para>Get the data at a particular index.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.InsertTupleValue(System.Int32,System.Int32[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple onto the end of the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.SetTupleValue(System.Int32,System.Int32[])">
            <summary>
                <para>Insert (memory allocation performed) the tuple into the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.GetTupleValue(System.Int32,System.Int32[])">
            <summary>
                <para>Set the tuple value at the ith location in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIdTypeArray.GetDataType">
            <summary>
                <para>Copy the tuple value into a user-provided array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataArray.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataArray.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataArray.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataArray.CreateDataArray(System.Int32)">
            <summary>
                <para>Creates an array for dataType where dataType is one of VTK_BIT, VTK_CHAR, VTK_SIGNED_CHAR, VTK_UNSIGNED_CHAR, VTK_SHORT, VTK_UNSIGNED_SHORT, VTK_INT, VTK_UNSIGNED_INT, VTK_LONG, VTK_UNSIGNED_LONG, VTK_DOUBLE, VTK_DOUBLE, VTK_ID_TYPE. Note that the data array returned has be deleted by the user.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetMaxNorm">
            <summary>
                <para>Return the maximum norm for the tuples. Note that the max. is computed everytime GetMaxNorm is called.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetDataTypeMax(System.Int32)">
            <summary>
                <para>These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetDataTypeMin(System.Int32)">
            <summary>
                <para>These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetDataTypeRange(System.Int32,System.Double[])">
            <summary>
                <para>These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetDataTypeMax">
            <summary>
                <para>These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetDataTypeMin">
            <summary>
                <para>These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetDataTypeRange(System.Double[])">
            <summary>
                <para>These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetRange(System.Double[])">
            <summary>
                <para>These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetRange">
            <summary>
                <para>Return the range of the array values for the 0th component.  Range is copied into the array provided.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetRange(System.Double[],System.Int32)">
            <summary>
                <para>Return the range of the array values for the given component.  Range is copied into the array provided. If comp is equal to -1, it returns the range of the magnitude (if the number of components is equal to 1 it still returns the range of component 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetName">
            <summary>
                <para>Set/get array's name</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetName(System.String)">
            <summary>
                <para>Set/get array's name</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetLookupTable">
            <summary>
                <para>Set/get the lookup table associated with this scalar data, if any.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetLookupTable(vtk.vtkLookupTable)">
            <summary>
                <para>Set/get the lookup table associated with this scalar data, if any.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.CreateDefaultLookupTable">
            <summary>
                <para>Create default lookup table. Generally used to create one when none is available.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetActualMemorySize">
            <summary>
                <para>Return the memory in kilobytes consumed by this data array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The  information returned is valid only after the pipeline has  been updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.ExportToVoidPointer(System.IntPtr)">
            <summary>
                <para>Return the memory in kilobytes consumed by this data array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The  information returned is valid only after the pipeline has  been updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetVoidArray(System.IntPtr,System.Int32,System.Int32)">
            <summary>
                <para>This method lets the user specify data to be held by the array.  The  array argument is a pointer to the data.  size is the size of  the array supplied by the user.  Set save to 1 to keep the class from deleting the array when it cleans up or reallocates memory. The class uses the actual array provided; it does not copy the data  from the supplied array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetMaxId">
            <summary>
                <para>This method lets the user specify data to be held by the array.  The  array argument is a pointer to the data.  size is the size of  the array supplied by the user.  Set save to 1 to keep the class from deleting the array when it cleans up or reallocates memory. The class uses the actual array provided; it does not copy the data  from the supplied array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetSize">
            <summary>
                <para>What is the maximum id currently in the array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.Reset">
            <summary>
                <para>Return the size of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.Resize(System.Int32)">
            <summary>
                <para>Resize the array while conserving the data.  Returns 1 if resizing succeeded and 0 otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.Squeeze">
            <summary>
                <para>Free any unnecessary memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetVoidPointer(System.Int32)">
            <summary>
                <para>Return a void pointer. For image pipeline interface and other  special pointer manipulation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.WriteVoidPointer(System.Int32,System.Int32)">
            <summary>
                <para>Get the address of a particular data index. Make sure data is allocated for the number of items requested. Set MaxId according to the number of data values requested.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.CopyComponent(System.Int32,vtk.vtkDataArray,System.Int32)">
            <summary>
                <para>Copy a component from one data array into a component on this data array. This method copies the specified component ("fromComponent") from the specified data array ("from") to the specified component ("j") over all the tuples in this data array.  This method can be used to extract a component (column) from one data array and paste that data into a component on this data array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.FillComponent(System.Int32,System.Double)">
            <summary>
                <para>Fill a component of a data array with a specified value. This method sets the specified component to specified value for all tuples in the data array.  This methods can be used to initialize or reinitialize a single component of a multi-component array.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.DeepCopy(vtk.vtkDataArray)">
            <summary>
                <para>Deep copy of data. Copies data from different data arrays even if they are different types (using doubleing-point exchange).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkDoubleArray)">
            <summary>
                <para>Get the data as a double array in the range (tupleMin,tupleMax) and (compMin, compMax). The resulting double array consists of all data in the tuple range specified and only the component range specified. This process typically requires casting the data from native form into doubleing point values. This method is provided as a convenience for data exchange, and is not very fast.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertComponent(System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Insert the data component at ith tuple and jth component location.  Note that memory allocation is performed as necessary to hold the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetComponent(System.Int32,System.Int32,System.Double)">
            <summary>
                <para>Set the data component at the ith tuple and jth component location. Note that i is less than NumberOfTuples and j is less than  NumberOfComponents. Make sure enough memory has been allocated  (use SetNumberOfTuples() and SetNumberOfComponents()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetComponent(System.Int32,System.Int32)">
            <summary>
                <para>Return the data component at the ith tuple and jth component location. Note that i is less than NumberOfTuples and j is less than  NumberOfComponents.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertNextTuple9(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertNextTuple4(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertNextTuple3(System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertNextTuple2(System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertNextTuple1(System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertNextTuple(System.Double[])">
            <summary>
                <para>Insert the data tuple at the end of the array and return the location at which the data was inserted. Memory is allocated as necessary to hold the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertNextTuple(System.Single[])">
            <summary>
                <para>Insert the data tuple at the end of the array and return the location at which the data was inserted. Memory is allocated as necessary to hold the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertTuple9(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertTuple4(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertTuple3(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertTuple2(System.Int32,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertTuple1(System.Int32,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertTuple(System.Int32,System.Double[])">
            <summary>
                <para>Insert the data tuple at ith location. Note that memory allocation is performed as necessary to hold the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.InsertTuple(System.Int32,System.Single[])">
            <summary>
                <para>Insert the data tuple at ith location. Note that memory allocation is performed as necessary to hold the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetTuple9(System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetTuple4(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetTuple3(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetTuple2(System.Int32,System.Double,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetTuple1(System.Int32,System.Double)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetTuple(System.Int32,System.Double[])">
            <summary>
                <para>Set the data tuple at ith location. Note that range checking or memory allocation is not performed; use this method in conjunction with SetNumberOfTuples() to allocate space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetTuple(System.Int32,System.Single[])">
            <summary>
                <para>Set the data tuple at ith location. Note that range checking or memory allocation is not performed; use this method in conjunction with SetNumberOfTuples() to allocate space.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetTuples(System.Int32,System.Int32,vtk.vtkDataArray)">
            <summary>
                <para>Get the tuples for the range of points ids specified  (i.e., p1-&gt;p2 inclusive). You must insure that the output array has  been previously allocated with enough space to hold the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetTuples(vtk.vtkIdList,vtk.vtkDataArray)">
            <summary>
                <para>Given a list of point ids, return an array of tuples. You must insure that the output array has been previously  allocated with enough space to hold the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetTuple9(System.Int32)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetTuple4(System.Int32)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetTuple3(System.Int32)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetTuple2(System.Int32)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetTuple1(System.Int32)">
            <summary>
                <para>These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be  used from wrapped languages. These methods can be used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetTuple(System.Int32,System.Double[])">
            <summary>
                <para>Get the data tuple at ith location by filling in a user-provided array, Make sure that your array is large enough to hold the NumberOfComponents amount of data being returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetNumberOfTuples">
            <summary>
                <para>Get the data tuple at ith location. Return it as a pointer to an array. Note: this method is not thread-safe, and the pointer is only valid as long as another method invocation to a vtk object is not performed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetNumberOfTuples(System.Int32)">
            <summary>
                <para>Set the number of tuples (a component group) in the array. Note that  this may allocate space depending on the number of components.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetNumberOfComponents">
            <summary>
                <para>Set/Get the dimension (n) of the components. Must be &gt;= 1. Make sure that this is set before allocation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetNumberOfComponentsMaxValue">
            <summary>
                <para>Set/Get the dimension (n) of the components. Must be &gt;= 1. Make sure that this is set before allocation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetNumberOfComponentsMinValue">
            <summary>
                <para>Set/Get the dimension (n) of the components. Must be &gt;= 1. Make sure that this is set before allocation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.SetNumberOfComponents(System.Int32)">
            <summary>
                <para>Set/Get the dimension (n) of the components. Must be &gt;= 1. Make sure that this is set before allocation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetDataTypeSize(System.Int32)">
            <summary>
                <para>Return the size of the underlying data type.  For a bit, 0 is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetDataTypeSize">
            <summary>
                <para>Return the size of the underlying data type.  For a bit, 0 is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.GetDataType">
            <summary>
                <para>Return the underlying data type. An integer indicating data type is  returned as specified in vtkSetGet.h.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.Initialize">
            <summary>
                <para>Release storage and reset array to initial state.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataArray.Allocate(System.Int32,System.Int32)">
            <summary>
                <para>Allocate memory for this array. Delete old storage only if necessary. Note that ext is no longer used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDirectory.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDirectory.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDirectory.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDirectory.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDirectory.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDirectory.CreateDirectory(System.String)">
            <summary>
                <para>@deprecated Replaced by vtkDirectory::MakeDirectory() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.MakeDirectory(System.String)">
            <summary>
                <para>Create directory. Needs rework to do all the testing and to work on all platforms.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.GetCurrentWorkingDirectory(System.String,System.UInt32)">
            <summary>
                <para>Get the current working directory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.GetFile(System.Int32)">
            <summary>
                <para>Return the file at the given index, the indexing is 0 based</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.GetNumberOfFiles">
            <summary>
                <para>Return the file at the given index, the indexing is 0 based</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.Open(System.String)">
            <summary>
                <para>Open the specified directory and load the names of the files in that directory. 0 is returned if the directory can not be  opened, 1 if it is opened.   </para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Return the class name as a string.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.NewInstance">
            <summary>
                <para>Return the class name as a string.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.IsA(System.String)">
            <summary>
                <para>Return the class name as a string.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDirectory.GetClassName">
            <summary>
                <para>Return the class name as a string.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProp.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProp.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProp.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProp.PokeMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>These methods are used by subclasses to place a matrix (if any) in the prop prior to rendering. Generally used only for picking. See vtkProp3D for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.GetNumberOfPaths">
            <summary>
                <para>These methods are used by subclasses to place a matrix (if any) in the prop prior to rendering. Generally used only for picking. See vtkProp3D for more information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.GetNextPath">
            <summary>
                <para>vtkProp and its subclasses can be picked by subclasses of vtkAbstractPicker (e.g., vtkPropPicker). The following methods interface with the picking classes and return "pick paths". A pick path is a hierarchical, ordered list of props that form an assembly.  Most often, when a vtkProp is picked, its path consists of a single node (i.e., the prop). However, classes like vtkAssembly and vtkPropAssembly can return more than one path, each path being several layers deep. (See vtkAssemblyPath for more information.)  To use these methods - first invoke InitPathTraversal() followed by repeated calls to GetNextPath(). GetNextPath() returns a NULL pointer when the list is exhausted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.InitPathTraversal">
            <summary>
                <para>vtkProp and its subclasses can be picked by subclasses of vtkAbstractPicker (e.g., vtkPropPicker). The following methods interface with the picking classes and return "pick paths". A pick path is a hierarchical, ordered list of props that form an assembly.  Most often, when a vtkProp is picked, its path consists of a single node (i.e., the prop). However, classes like vtkAssembly and vtkPropAssembly can return more than one path, each path being several layers deep. (See vtkAssemblyPath for more information.)  To use these methods - first invoke InitPathTraversal() followed by repeated calls to GetNextPath(). GetNextPath() returns a NULL pointer when the list is exhausted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this vtkProp.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.GetRedrawMTime">
            <summary>
                <para>Get the bounds for this Prop as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax). in world coordinates. NULL means that the bounds are not defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.DragableOff">
            <summary>
                <para>Set/Get the value of the dragable instance variable. This determines if  an Prop, once picked, can be dragged (translated) through space. This is typically done through an interactive mouse interface. This does not affect methods such as SetPosition, which will continue to work.  It is just intended to prevent some vtkProp'ss from being dragged from within a user interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.DragableOn">
            <summary>
                <para>Set/Get the value of the dragable instance variable. This determines if  an Prop, once picked, can be dragged (translated) through space. This is typically done through an interactive mouse interface. This does not affect methods such as SetPosition, which will continue to work.  It is just intended to prevent some vtkProp'ss from being dragged from within a user interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.GetDragable">
            <summary>
                <para>Set/Get the value of the dragable instance variable. This determines if  an Prop, once picked, can be dragged (translated) through space. This is typically done through an interactive mouse interface. This does not affect methods such as SetPosition, which will continue to work.  It is just intended to prevent some vtkProp'ss from being dragged from within a user interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.SetDragable(System.Int32)">
            <summary>
                <para>Set/Get the value of the dragable instance variable. This determines if  an Prop, once picked, can be dragged (translated) through space. This is typically done through an interactive mouse interface. This does not affect methods such as SetPosition, which will continue to work.  It is just intended to prevent some vtkProp'ss from being dragged from within a user interface.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.Pick">
            <summary>
                <para>Method fires PickEvent if the prop is picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.PickableOff">
            <summary>
                <para>Set/Get the pickable instance variable.  This determines if the vtkProp can be picked (typically using the mouse). Also see dragable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.PickableOn">
            <summary>
                <para>Set/Get the pickable instance variable.  This determines if the vtkProp can be picked (typically using the mouse). Also see dragable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.GetPickable">
            <summary>
                <para>Set/Get the pickable instance variable.  This determines if the vtkProp can be picked (typically using the mouse). Also see dragable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.SetPickable(System.Int32)">
            <summary>
                <para>Set/Get the pickable instance variable.  This determines if the vtkProp can be picked (typically using the mouse). Also see dragable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.VisibilityOff">
            <summary>
                <para>Set/Get visibility of this vtkProp.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.VisibilityOn">
            <summary>
                <para>Set/Get visibility of this vtkProp.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.GetVisibility">
            <summary>
                <para>Set/Get visibility of this vtkProp.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.SetVisibility(System.Int32)">
            <summary>
                <para>Set/Get visibility of this vtkProp.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.GetVolumes(vtk.vtkPropCollection)">
            <summary>
                <para>Set/Get visibility of this vtkProp.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.GetActors2D(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp.GetActors(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPropCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPropCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPropCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPropCollection.GetNumberOfPaths">
            <summary>
                <para>Get the number of paths contained in this list. (Recall that a vtkProp can consist of multiple parts.) Used in picking and other activities to get the parts of composite entities like vtkAssembly or vtkPropAssembly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropCollection.GetLastProp">
            <summary>
                <para>Get the last Prop in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropCollection.GetNextProp">
            <summary>
                <para>Get the next Prop in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropCollection.AddItem(vtk.vtkProp)">
            <summary>
                <para>Add an Prop to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCollection.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Participate in garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Participate in garbage collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.NewIterator">
            <summary>
                <para>Get an iterator to traverse the objects in this collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.GetItemAsObject(System.Int32)">
            <summary>
                <para>Get the i'th item in the collection. NULL is returned if i is out of range</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.GetNextItemAsObject">
            <summary>
                <para>Get the next item in the collection. NULL is returned if the collection is exhausted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.InitTraversal">
            <summary>
                <para>Initialize the traversal of the collection. This means the data pointer is set at the beginning of the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.GetNumberOfItems">
            <summary>
                <para>Return the number of objects in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.IsItemPresent(vtk.vtkObject)">
            <summary>
                <para>Search for an object and return location in list. If location == 0, object was not found.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.RemoveAllItems">
            <summary>
                <para>Remove all objects from the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.RemoveItem(vtk.vtkObject)">
            <summary>
                <para>Remove an object from the list. Removes the first object found, not all occurrences. If no object found, list is unaffected.  See warning in description of RemoveItem(int).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.RemoveItem(System.Int32)">
            <summary>
                <para>Remove the i'th item in the list. Be careful if using this function during traversal of the list using  GetNextItemAsObject (or GetNextItem in derived class).  The list WILL be shortened if a valid index is given!  If this-&gt;Current is equal to the element being removed, have it point to then next element in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.ReplaceItem(System.Int32,vtk.vtkObject)">
            <summary>
                <para>Replace the i'th item in the collection with a</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCollection.AddItem(vtk.vtkObject)">
            <summary>
                <para>Add an object to the list. Does not prevent duplicate entries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricRoman.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw.</para>
                <para>uvw are the parameters with Pt being the the Cartesian point,  Duvw are the derivatives of this point with respect to u, v and w. Pt, Duvw are obtained from Evaluate().</para>
                <para>This function is only called if the ScalarMode has the value vtkParametricFunctionSource::SCALAR_FUNCTION_DEFINED</para>
                <para>If the user does not need to calculate a scalar, then the  instantiated function should return zero. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Steiner's Roman Surface</para>
                <para>This function performs the mapping \f$f(u,v) \rightarrow (x,y,x)\f$, returning it as Pt. It also returns the partial derivatives Du and Dv. \f$Pt = (x, y, z), Du = (dx/du, dy/du, dz/du), Dv = (dx/dv, dy/dv, dz/dv)\f$ . Then the normal is \f$N = Du X Dv\f$ .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.GetRadius">
            <summary>
                <para>Set/Get the radius.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.SetRadius(System.Double)">
            <summary>
                <para>Set/Get the radius.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricRoman.GetDimension">
            <summary>
                <para>Construct Steiner's Roman Surface with the following parameters: MinimumU = 0, MaximumU = Pi, MinimumV = 0, MaximumV = Pi,  JoinU = 1, JoinV = 1, TwistU = 1, TwistV = 0;  ClockwiseOrdering = 1,  DerivativesAvailable = 1, Radius = 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParametricFunction.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.DerivativesAvailableOff">
            <summary>
                <para>Set/Get the flag which determines whether derivatives are available  from the parametric function (i.e., whether the Evaluate() method  returns valid derivatives).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.DerivativesAvailableOn">
            <summary>
                <para>Set/Get the flag which determines whether derivatives are available  from the parametric function (i.e., whether the Evaluate() method  returns valid derivatives).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetDerivativesAvailable">
            <summary>
                <para>Set/Get the flag which determines whether derivatives are available  from the parametric function (i.e., whether the Evaluate() method  returns valid derivatives).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetDerivativesAvailable(System.Int32)">
            <summary>
                <para>Set/Get the flag which determines whether derivatives are available  from the parametric function (i.e., whether the Evaluate() method  returns valid derivatives).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.ClockwiseOrderingOff">
            <summary>
                <para>Set/Get the flag which determines the ordering of the the  vertices forming the triangle strips. The ordering of the  points being inserted into the triangle strip is important  because it determines the direction of the normals for the  lighting. If set, the ordering is clockwise, otherwise the ordering is anti-clockwise. Default is true (i.e. clockwise ordering).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.ClockwiseOrderingOn">
            <summary>
                <para>Set/Get the flag which determines the ordering of the the  vertices forming the triangle strips. The ordering of the  points being inserted into the triangle strip is important  because it determines the direction of the normals for the  lighting. If set, the ordering is clockwise, otherwise the ordering is anti-clockwise. Default is true (i.e. clockwise ordering).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetClockwiseOrdering">
            <summary>
                <para>Set/Get the flag which determines the ordering of the the  vertices forming the triangle strips. The ordering of the  points being inserted into the triangle strip is important  because it determines the direction of the normals for the  lighting. If set, the ordering is clockwise, otherwise the ordering is anti-clockwise. Default is true (i.e. clockwise ordering).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetClockwiseOrdering(System.Int32)">
            <summary>
                <para>Set/Get the flag which determines the ordering of the the  vertices forming the triangle strips. The ordering of the  points being inserted into the triangle strip is important  because it determines the direction of the normals for the  lighting. If set, the ordering is clockwise, otherwise the ordering is anti-clockwise. Default is true (i.e. clockwise ordering).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.TwistVOff">
            <summary>
                <para>Set/Get the flag which joins the ends of the  triangle strips with a twist. JoinV must also be set if this is set. Used when building some non-orientable surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.TwistVOn">
            <summary>
                <para>Set/Get the flag which joins the ends of the  triangle strips with a twist. JoinV must also be set if this is set. Used when building some non-orientable surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetTwistV">
            <summary>
                <para>Set/Get the flag which joins the ends of the  triangle strips with a twist. JoinV must also be set if this is set. Used when building some non-orientable surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetTwistV(System.Int32)">
            <summary>
                <para>Set/Get the flag which joins the ends of the  triangle strips with a twist. JoinV must also be set if this is set. Used when building some non-orientable surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.TwistUOff">
            <summary>
                <para>Set/Get the flag which joins the first triangle strip to  the last one with a twist. JoinU must also be set if this is set. Used when building some non-orientable surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.TwistUOn">
            <summary>
                <para>Set/Get the flag which joins the first triangle strip to  the last one with a twist. JoinU must also be set if this is set. Used when building some non-orientable surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetTwistU">
            <summary>
                <para>Set/Get the flag which joins the first triangle strip to  the last one with a twist. JoinU must also be set if this is set. Used when building some non-orientable surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetTwistU(System.Int32)">
            <summary>
                <para>Set/Get the flag which joins the first triangle strip to  the last one with a twist. JoinU must also be set if this is set. Used when building some non-orientable surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.JoinVOff">
            <summary>
                <para>Set/Get the flag which joins the the ends of the triangle strips.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.JoinVOn">
            <summary>
                <para>Set/Get the flag which joins the the ends of the triangle strips.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetJoinV">
            <summary>
                <para>Set/Get the flag which joins the the ends of the triangle strips.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetJoinV(System.Int32)">
            <summary>
                <para>Set/Get the flag which joins the the ends of the triangle strips.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.JoinUOff">
            <summary>
                <para>Set/Get the flag which joins the first triangle strip to the last one.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.JoinUOn">
            <summary>
                <para>Set/Get the flag which joins the first triangle strip to the last one.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetJoinU">
            <summary>
                <para>Set/Get the flag which joins the first triangle strip to the last one.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetJoinU(System.Int32)">
            <summary>
                <para>Set/Get the flag which joins the first triangle strip to the last one.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetMaximumW">
            <summary>
                <para>Set/Get the maximum w-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetMaximumW(System.Double)">
            <summary>
                <para>Set/Get the maximum w-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetMinimumW">
            <summary>
                <para>Set/Get the minimum w-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetMinimumW(System.Double)">
            <summary>
                <para>Set/Get the minimum w-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetMaximumV">
            <summary>
                <para>Set/Get the maximum v-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetMaximumV(System.Double)">
            <summary>
                <para>Set/Get the maximum v-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetMinimumV">
            <summary>
                <para>Set/Get the minimum v-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetMinimumV(System.Double)">
            <summary>
                <para>Set/Get the minimum v-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetMaximumU">
            <summary>
                <para>Set/Get the maximum u-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetMaximumU(System.Double)">
            <summary>
                <para>Set/Get the maximum u-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.GetMinimumU">
            <summary>
                <para>Set/Get the minimum u-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.SetMinimumU(System.Double)">
            <summary>
                <para>Set/Get the minimum u-value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.EvaluateScalar(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Calculate a user defined scalar using one or all of uvw, Pt, Duvw. This is a pure virtual function that must be instantiated in  a derived class. </para>
                <para>uvw are the parameters with Pt being the the cartesian point,  Duvw are the derivatives of this point with respect to u, v, and w. Pt, Duvw are obtained from Evaluate().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParametricFunction.Evaluate(System.Double[],System.Double[],System.Double[])">
            <summary>
                <para>Performs the mapping \$f(uvw)-&gt;(Pt,Duvw)\$f. This is a pure virtual function that must be instantiated in  a derived class. </para>
                <para>uvw are the parameters, with u corresponding to uvw[0], v to uvw[1] and w to uvw[2] respectively. Pt is the returned Cartesian point,  Duvw are the derivatives of this point with respect to u, v and w.   Note that the first three values in Duvw are Du, the next three are Dv,  and the final three are Dw. Du Dv Dw are the partial derivatives of the  function at the point Pt with respect to u, v and w respectively.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.AppendOff">
            <summary>
                <para>opened in append mode.  Otherwise, if the log file exists, it will be overwritten each time the vtkFileOutputWindow  is created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.AppendOn">
            <summary>
                <para>opened in append mode.  Otherwise, if the log file exists, it will be overwritten each time the vtkFileOutputWindow  is created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.GetAppend">
            <summary>
                <para>opened in append mode.  Otherwise, if the log file exists, it will be overwritten each time the vtkFileOutputWindow  is created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.SetAppend(System.Int32)">
            <summary>
                <para>opened in append mode.  Otherwise, if the log file exists, it will be overwritten each time the vtkFileOutputWindow  is created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.FlushOff">
            <summary>
                <para>to the log file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.FlushOn">
            <summary>
                <para>to the log file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.GetFlush">
            <summary>
                <para>to the log file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.SetFlush(System.Int32)">
            <summary>
                <para>to the log file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFileOutputWindow.GetFileName">
            <summary />
        </member>
        <member name="M:vtk.vtkFileOutputWindow.SetFileName(System.String)">
            <summary />
        </member>
        <member name="M:vtk.vtkFileOutputWindow.DisplayText(System.String)">
            <summary>
                <para>New lines are converted to carriage return new lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOutputWindow.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.SetPromptUser(System.Int32)">
            <summary>
                <para>If PromptUser is set to true then each time a line of text is displayed, the user is asked if they want to keep getting messages.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.PromptUserOff">
            <summary>
                <para>If PromptUser is set to true then each time a line of text is displayed, the user is asked if they want to keep getting messages.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.PromptUserOn">
            <summary>
                <para>If PromptUser is set to true then each time a line of text is displayed, the user is asked if they want to keep getting messages.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.DisplayGenericWarningText(System.String)">
            <summary>
                <para>Display the text. Four virtual methods exist, depending on the type of message to display. This allows redirection or reformatting of the messages. The default implementation uses DisplayText for all.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.DisplayWarningText(System.String)">
            <summary>
                <para>Display the text. Four virtual methods exist, depending on the type of message to display. This allows redirection or reformatting of the messages. The default implementation uses DisplayText for all.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.DisplayErrorText(System.String)">
            <summary>
                <para>Display the text. Four virtual methods exist, depending on the type of message to display. This allows redirection or reformatting of the messages. The default implementation uses DisplayText for all.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.DisplayText(System.String)">
            <summary>
                <para>Display the text. Four virtual methods exist, depending on the type of message to display. This allows redirection or reformatting of the messages. The default implementation uses DisplayText for all.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.SetInstance(vtk.vtkOutputWindow)">
            <summary>
                <para>Supply a user defined output window. Call -&gt;Delete() on the supplied instance after setting it.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOutputWindow.GetInstance">
            <summary>
                <para>Return the singleton instance with no reference counting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkObject.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkObject.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkObject.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkObject.AddObserver(System.UInt32!System.Runtime.CompilerServices.IsLong,vtk.vtkDotNetCallback,System.Object)">
            <summary>
Add an observer to this class.
</summary>
            <param name="eid">The event id from the VTK enum EventId</param>
            <param name="data">When registering an observer, the data member can store
any managed object, and it will be passed to the vtkDotNetCallback
when it is called.</param>
            <remarks>
The wrapper creates a vtkDotNetCommand to save a pointer to the vtkDotNetCallback.
The vtkDotNetCommand receives events and forwards them to the callback.
</remarks>
        </member>
        <member name="M:vtk.vtkObject.AddObserver(System.UInt32!System.Runtime.CompilerServices.IsLong,vtk.vtkDotNetCallback)">
            <summary>
Add an observer to this class.
</summary>
            <param name="eid">The event id from the VTK enum EventId</param>
            <remarks>
The wrapper creates a vtkDotNetCommand to save a pointer to the vtkDotNetCallback.
The vtkDotNetCommand receives events and forwards them to the callback.
</remarks>
        </member>
        <member name="M:vtk.vtkObject.HasObserver(System.String)">
            <summary>
                <para>Allow people to add/remove/invoke observers (callbacks) to any VTK object.  This is an implementation of the subject/observer design pattern. An observer is added by specifying an event to respond to and a vtkCommand to execute. It returns an unsigned long tag which can be used later to remove the event or retrieve the command. When events are invoked, the observers are called in the order they were added. If a priority value is specified, then the higher  priority commands are called first. A command may set an abort flag to stop processing of the event. (See vtkCommand.h for more information.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.HasObserver(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Allow people to add/remove/invoke observers (callbacks) to any VTK object.  This is an implementation of the subject/observer design pattern. An observer is added by specifying an event to respond to and a vtkCommand to execute. It returns an unsigned long tag which can be used later to remove the event or retrieve the command. When events are invoked, the observers are called in the order they were added. If a priority value is specified, then the higher  priority commands are called first. A command may set an abort flag to stop processing of the event. (See vtkCommand.h for more information.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.RemoveObservers(System.String)">
            <summary>
                <para>Allow people to add/remove/invoke observers (callbacks) to any VTK object.  This is an implementation of the subject/observer design pattern. An observer is added by specifying an event to respond to and a vtkCommand to execute. It returns an unsigned long tag which can be used later to remove the event or retrieve the command. When events are invoked, the observers are called in the order they were added. If a priority value is specified, then the higher  priority commands are called first. A command may set an abort flag to stop processing of the event. (See vtkCommand.h for more information.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.RemoveObservers(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Allow people to add/remove/invoke observers (callbacks) to any VTK object.  This is an implementation of the subject/observer design pattern. An observer is added by specifying an event to respond to and a vtkCommand to execute. It returns an unsigned long tag which can be used later to remove the event or retrieve the command. When events are invoked, the observers are called in the order they were added. If a priority value is specified, then the higher  priority commands are called first. A command may set an abort flag to stop processing of the event. (See vtkCommand.h for more information.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.RemoveObserver(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
                <para>Allow people to add/remove/invoke observers (callbacks) to any VTK object.  This is an implementation of the subject/observer design pattern. An observer is added by specifying an event to respond to and a vtkCommand to execute. It returns an unsigned long tag which can be used later to remove the event or retrieve the command. When events are invoked, the observers are called in the order they were added. If a priority value is specified, then the higher  priority commands are called first. A command may set an abort flag to stop processing of the event. (See vtkCommand.h for more information.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.GetGlobalWarningDisplay">
            <summary>
                <para>This is a global flag that controls whether any debug, warning or error messages are displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.GlobalWarningDisplayOff">
            <summary>
                <para>This is a global flag that controls whether any debug, warning or error messages are displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.GlobalWarningDisplayOn">
            <summary>
                <para>This is a global flag that controls whether any debug, warning or error messages are displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.SetGlobalWarningDisplay(System.Int32)">
            <summary>
                <para>This is a global flag that controls whether any debug, warning or error messages are displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.GetMTime">
            <summary>
                <para>Return this object's modified time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.Modified">
            <summary>
                <para>Update the modification time for this object. Many filters rely on the modification time to determine if they need to recompute their data. The modification time is a unique monotonically increasing unsigned long integer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.BreakOnError">
            <summary>
                <para>This method is called when vtkErrorMacro executes. It allows  the debugger to break on error.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.SetDebug(System.Byte)">
            <summary>
                <para>Set the value of the debug flag. A non-zero value turns debugging on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.GetDebug">
            <summary>
                <para>Get the value of the debug flag.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.DebugOff">
            <summary>
                <para>Turn debugging output off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObject.DebugOn">
            <summary>
                <para>Turn debugging output on.</para>
            </summary>
        </member>
        <member name="T:vtk.vtkDotNetCallback">
            <summary>Delegates of type vtkDotNetCallback can receive messages
from the native vtkDotNetCommand class. Use this delegate with
vtk.vtkObject.AddObserver.
</summary>
            <param name="caller">The class which sent the message.</param>
            <param name="eventId">The type of event, defined by a C++ enum EventId.</param>
            <param name="clientData">The message returns to the delegate an optional
parameter to AddObserver.</param>
            <param name="callData">A void* pointer passed in from the caller.</param>
        </member>
        <member name="M:vtk.vtkObjectBase.SetNativePointer(System.IntPtr)">
            <summary>
This method allows a derived class to set the instance
contained by this wrapper.
</summary>
        </member>
        <member name="M:vtk.vtkObjectBase.GetNativeConstPointer">
            <summary>
Returns a pointer to the instance contained by this wrapper.
</summary>
        </member>
        <member name="M:vtk.vtkObjectBase.GetNativePointer">
            <summary>
Returns a pointer to the instance contained by this wrapper.
Will be null if the instance is const.
</summary>
        </member>
        <member name="M:vtk.vtkObjectBase.SetReferenceCount(System.Int32)">
            <summary>
                <para>Sets the reference count. (This is very dangerous, use with care.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectBase.GetReferenceCount">
            <summary>
                <para>Sets the reference count. (This is very dangerous, use with care.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectBase.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>Decrease the reference count (release by another object). This has the same effect as invoking Delete() (i.e., it reduces the reference count by 1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectBase.Register(vtk.vtkObjectBase)">
            <summary>
                <para>Increase the reference count (mark as used by another object).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectBase.FastDelete">
            <summary>
                <para>Delete a reference to this object.  This version will not invoke garbage collection and can potentially leak the object if it is part of a reference loop.  Use this method only when it is known that the object has another reference and would not be collected if a full garbage collection check were done.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectBase.IsA(System.String)">
            <summary>
                <para>Return 1 if this class is the same type of (or a subclass of) the named class. Returns 0 otherwise. This method works in combination with vtkTypeRevisionMacro found in vtkSetGet.h.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectBase.IsTypeOf(System.String)">
            <summary>
                <para>Return 1 if this class type is the same type of (or a subclass of) the named class. Returns 0 otherwise. This method works in combination with vtkTypeRevisionMacro found in vtkSetGet.h.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkObjectBase.GetClassName">
            <summary>
                <para>Return the class name as a string. This method is defined in all subclasses of vtkObjectBase with the vtkTypeRevisionMacro found in vtkSetGet.h.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDotNetUtil.vtkGetDataRoot">
            <summary>This method finds the location of VTK demonstration data either
from the VTK_DATA_ROOT environment variable or from compile-time
specification.
</summary>
        </member>
        <member name="T:vtk.vtkDotNetUtil">
            <summary>Helper for VTK .NET wrappers.
</summary>
        </member>
    </members>
</doc>