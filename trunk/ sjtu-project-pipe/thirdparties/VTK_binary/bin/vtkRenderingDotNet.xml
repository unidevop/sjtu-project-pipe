<?xml version="1.0"?>
<doc>
    <assembly>
        "vtkRenderingDotNet"
    </assembly>
    <members>
        <member name="M:vtk.vtkCullerCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCullerCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAssembly.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAssembly.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.GetMTime">
            <summary>
                <para>Return MTime also considering the renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.GetTolerance">
            <summary>
                <para>Set/Get a tolerance to use to determine whether a point is visible. A tolerance is usually required because the conversion from world space to display space during rendering introduces numerical round-off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.GetToleranceMaxValue">
            <summary>
                <para>Set/Get a tolerance to use to determine whether a point is visible. A tolerance is usually required because the conversion from world space to display space during rendering introduces numerical round-off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.GetToleranceMinValue">
            <summary>
                <para>Set/Get a tolerance to use to determine whether a point is visible. A tolerance is usually required because the conversion from world space to display space during rendering introduces numerical round-off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SetTolerance(System.Double)">
            <summary>
                <para>Set/Get a tolerance to use to determine whether a point is visible. A tolerance is usually required because the conversion from world space to display space during rendering introduces numerical round-off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SelectInvisibleOff">
            <summary>
                <para>Set/Get the flag which enables inverse selection; i.e., invisible points are selected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SelectInvisibleOn">
            <summary>
                <para>Set/Get the flag which enables inverse selection; i.e., invisible points are selected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.GetSelectInvisible">
            <summary>
                <para>Set/Get the flag which enables inverse selection; i.e., invisible points are selected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SetSelectInvisible(System.Int32)">
            <summary>
                <para>Set/Get the flag which enables inverse selection; i.e., invisible points are selected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.GetSelection">
            <summary>
                <para>Specify the selection window in display coordinates. You must specify a rectangular region using (xmin,xmax,ymin,ymax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SetSelection(System.Int32[])">
            <summary>
                <para>Specify the selection window in display coordinates. You must specify a rectangular region using (xmin,xmax,ymin,ymax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SetSelection(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Specify the selection window in display coordinates. You must specify a rectangular region using (xmin,xmax,ymin,ymax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SelectionWindowOff">
            <summary>
                <para>Set/Get the flag which enables selection in a rectangular display region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SelectionWindowOn">
            <summary>
                <para>Set/Get the flag which enables selection in a rectangular display region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.GetSelectionWindow">
            <summary>
                <para>Set/Get the flag which enables selection in a rectangular display region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SetSelectionWindow(System.Int32)">
            <summary>
                <para>Set/Get the flag which enables selection in a rectangular display region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.GetRenderer">
            <summary>
                <para>Set/Get the flag which enables selection in a rectangular display region.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkSelectVisiblePoints.SetRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Specify the renderer in which the visibility computation is to be performed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLActor.Render(vtk.vtkRenderer,vtk.vtkMapper)">
            <summary>
                <para>Actual actor render method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTexture.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.LatLongLinesOff">
            <summary>
                <para>Turn on/off the latitude/longitude lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.LatLongLinesOn">
            <summary>
                <para>Turn on/off the latitude/longitude lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.GetLatLongLines">
            <summary>
                <para>Turn on/off the latitude/longitude lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.SetLatLongLines(System.Int32)">
            <summary>
                <para>Turn on/off the latitude/longitude lines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.OnChar">
            <summary>
                <para>Override the "fly-to" (f keypress) for images.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.OnRightButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.OnRightButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.OnMiddleButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.OnMiddleButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.OnLeftButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.OnLeftButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTerrain.OnMouseMove">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapperCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMapperCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRendererSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRendererSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRendererSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRendererSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRendererSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRendererSource.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.DepthValuesInScalarsOff">
            <summary>
                <para>A boolean value to control whether to grab z-buffer  (i.e., depth values) along with the image data. The z-buffer data is placed in the scalars as a fourth Z component (shift and scaled to map the full 0..255 range).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.DepthValuesInScalarsOn">
            <summary>
                <para>A boolean value to control whether to grab z-buffer  (i.e., depth values) along with the image data. The z-buffer data is placed in the scalars as a fourth Z component (shift and scaled to map the full 0..255 range).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.GetDepthValuesInScalars">
            <summary>
                <para>A boolean value to control whether to grab z-buffer  (i.e., depth values) along with the image data. The z-buffer data is placed in the scalars as a fourth Z component (shift and scaled to map the full 0..255 range).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.SetDepthValuesInScalars(System.Int32)">
            <summary>
                <para>A boolean value to control whether to grab z-buffer  (i.e., depth values) along with the image data. The z-buffer data is placed in the scalars as a fourth Z component (shift and scaled to map the full 0..255 range).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.DepthValuesOff">
            <summary>
                <para>A boolean value to control whether to grab z-buffer  (i.e., depth values) along with the image data. The z-buffer data is placed into a field data attributes named "ZBuffer" .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.DepthValuesOn">
            <summary>
                <para>A boolean value to control whether to grab z-buffer  (i.e., depth values) along with the image data. The z-buffer data is placed into a field data attributes named "ZBuffer" .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.GetDepthValues">
            <summary>
                <para>A boolean value to control whether to grab z-buffer  (i.e., depth values) along with the image data. The z-buffer data is placed into a field data attributes named "ZBuffer" .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.SetDepthValues(System.Int32)">
            <summary>
                <para>A boolean value to control whether to grab z-buffer  (i.e., depth values) along with the image data. The z-buffer data is placed into a field data attributes named "ZBuffer" .</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.RenderFlagOff">
            <summary>
                <para>If this flag is on, the Executing causes a render first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.RenderFlagOn">
            <summary>
                <para>If this flag is on, the Executing causes a render first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.GetRenderFlag">
            <summary>
                <para>If this flag is on, the Executing causes a render first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.SetRenderFlag(System.Int32)">
            <summary>
                <para>If this flag is on, the Executing causes a render first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.WholeWindowOff">
            <summary>
                <para>Use the entire RenderWindow as a data source or just the Renderer. The default is zero, just the Renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.WholeWindowOn">
            <summary>
                <para>Use the entire RenderWindow as a data source or just the Renderer. The default is zero, just the Renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.GetWholeWindow">
            <summary>
                <para>Use the entire RenderWindow as a data source or just the Renderer. The default is zero, just the Renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.SetWholeWindow(System.Int32)">
            <summary>
                <para>Use the entire RenderWindow as a data source or just the Renderer. The default is zero, just the Renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.GetInput">
            <summary>
                <para>Returns which renderer is being used as the source for the pixel data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.SetInput(vtk.vtkRenderer)">
            <summary>
                <para>Indicates what renderer to get the pixel data from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererSource.GetMTime">
            <summary>
                <para>Return the MTime also considering the Renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOOGLExporter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOOGLExporter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOOGLExporter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOOGLExporter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOOGLExporter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOOGLExporter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOOGLExporter.GetFileName">
            <summary>
                <para>Specify the name of the Geomview file to write.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOOGLExporter.SetFileName(System.String)">
            <summary>
                <para>Specify the name of the Geomview file to write.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.GetInputString">
            <summary>
                <para>Set/Get the string to read from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.SetInputString(System.String)">
            <summary>
                <para>Set/Get the string to read from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.ReadFromInputStringOff">
            <summary>
                <para>Enable reading from an InputString as compared to the default behavior, which is to read from a file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.ReadFromInputStringOn">
            <summary>
                <para>Enable reading from an InputString as compared to the default behavior, which is to read from a file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.GetReadFromInputString">
            <summary>
                <para>Enable reading from an InputString as compared to the default behavior, which is to read from a file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.SetReadFromInputString(System.Int32)">
            <summary>
                <para>Enable reading from an InputString as compared to the default behavior, which is to read from a file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.Rewind">
            <summary>
                <para>Rewind to the beginning of the file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.Stop">
            <summary>
                <para>Invoke this method to stop recording/playing events.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.Play">
            <summary>
                <para>Invoke this method to begin playing events from the current position. The events will be played back from the filename indicated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.Record">
            <summary>
                <para>Invoke this method to begin recording events. The events will be recorded to the filename indicated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.GetFileName">
            <summary>
                <para>Set/Get the name of a file events should be written to/from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorEventRecorder.SetFileName(System.String)">
            <summary>
                <para>Set/Get the name of a file events should be written to/from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRendererCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractVolumeMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractVolumeMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLight.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLight.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWorldPointPicker.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWorldPointPicker.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWorldPointPicker.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWorldPointPicker.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWorldPointPicker.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWorldPointPicker.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWorldPointPicker.Pick(System.Double[],vtk.vtkRenderer)">
            <summary>
                <para>Perform the pick. (This method overload's the superclass.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWorldPointPicker.Pick(System.Double,System.Double,System.Double,vtk.vtkRenderer)">
            <summary>
                <para>Perform the pick. (This method overload's the superclass.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropPicker.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPropPicker.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPropPicker.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPropPicker.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPropPicker.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPropPicker.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPropPicker.Pick(System.Double[],vtk.vtkRenderer)">
            <summary>
                <para>Overide superclasses' Pick() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropPicker.Pick(System.Double,System.Double,System.Double,vtk.vtkRenderer)">
            <summary>
                <para>Overide superclasses' Pick() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropPicker.PickProp(System.Double,System.Double,vtk.vtkRenderer,vtk.vtkPropCollection)">
            <summary>
                <para>Perform a pick from the user-provided list of vtkProps and not from the list of vtkProps that the render maintains.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPropPicker.PickProp(System.Double,System.Double,vtk.vtkRenderer)">
            <summary>
                <para>Perform the pick and set the PickedProp ivar. If something is picked, a 1 is returned, otherwise 0 is returned.  Use the GetViewProp() method to get the instance of vtkProp that was picked.  Props are picked from the renderers list of pickable Props.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackball.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackball.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackball.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackball.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackball.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackball.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTextMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTextMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTesting.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTesting.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTesting.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTesting.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTesting.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTesting.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTesting.GetBorderOffset">
            <summary>
                <para>Number of pixels added as borders to avoid problems with window decorations added by some window managers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.SetBorderOffset(System.Int32)">
            <summary>
                <para>Number of pixels added as borders to avoid problems with window decorations added by some window managers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.IsInteractiveModeSpecified">
            <summary>
                <para>Is the interactive mode specified?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.IsValidImageSpecified">
            <summary>
                <para>Is a valid image specified on the command line areguments?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.SetTempDirectory(System.String)">
            <summary>
                <para>Get some paramters from the command line arguments, env, or defaults</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.GetTempDirectory">
            <summary>
                <para>Get some paramters from the command line arguments, env, or defaults</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.SetDataRoot(System.String)">
            <summary>
                <para>Get some paramters from the command line arguments, env, or defaults</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.GetDataRoot">
            <summary>
                <para>Get some paramters from the command line arguments, env, or defaults</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.AddArgument(System.String)">
            <summary>
                <para>Pass the command line arguments into this class to be processed. Many of the Get methods such as GetValidImage and GetBaselineRoot rely on the arguments to be passed in prior to retrieving these values. Just call AddArgument for each argument that was passed into the command line</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.GetImageDifference">
            <summary>
                <para>Get the image difference.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.GetValidImageFileName">
            <summary>
                <para>Set/Get the name of the valid image file</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.SetValidImageFileName(System.String)">
            <summary>
                <para>Set/Get the name of the valid image file</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.GetRenderWindow">
            <summary>
                <para>Set and get the render window that will be used for regression testing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.SetRenderWindow(vtk.vtkRenderWindow)">
            <summary>
                <para>Set and get the render window that will be used for regression testing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.RegressionTest(vtk.vtkImageData,System.Double)">
            <summary>
                <para>Compare the image with the valid image.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.RegressionTest(System.Double)">
            <summary>
                <para>Perform the test and return result. At the same time the output will be written cout</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.GetFrontBuffer">
            <summary>
                <para>Use front buffer for tests. By default use back buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.FrontBufferOff">
            <summary>
                <para>Use front buffer for tests. By default use back buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.FrontBufferOn">
            <summary>
                <para>Use front buffer for tests. By default use back buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.GetFrontBufferMaxValue">
            <summary>
                <para>Use front buffer for tests. By default use back buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.GetFrontBufferMinValue">
            <summary>
                <para>Use front buffer for tests. By default use back buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTesting.SetFrontBuffer(System.Int32)">
            <summary>
                <para>Use front buffer for tests. By default use back buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.OnRightButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.OnRightButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.OnMiddleButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.OnMiddleButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.OnLeftButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.OnLeftButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickActor.OnMouseMove">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper2D.RenderOverlay(vtk.vtkViewport,vtk.vtkActor2D)">
            <summary>
                <para>Actually draw the poly data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper.Draw(vtk.vtkRenderer,vtk.vtkActor)">
            <summary>
                <para>Draw method for OpenGL.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this mapper. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLPolyDataMapper.RenderPiece(vtk.vtkRenderer,vtk.vtkActor)">
            <summary>
                <para>Implement superclass render method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAxisActor2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of an axis actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetFontSize(vtk.vtkViewport,vtk.vtkTextMapper,System.Int32[],System.Double,System.Int32[])">
            <summary>
                <para>General method to computes font size from a representative size on the  viewport (given by size[2]). The method returns the font size (in points) and the string height/width (in pixels). It also sets the font size of the instance of vtkTextMapper provided. The factor is used when you're trying to create text of different size-factor (it is usually = 1 but you can adjust the font size by making factor larger or smaller).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.ComputeRange(System.Double[],System.Double[],System.Int32,System.Int32@,System.Double@)">
            <summary>
                <para>This method computes the range of the axis given an input range.  It also computes the number of tick marks given a suggested number. (The number of tick marks includes end ticks as well.) The number of tick marks computed (in conjunction with the output range) will yield "nice" tick values. For example, if the input range is (0.25,96.7) and the number of ticks requested is 10, the output range will be (0,100) with the number of computed ticks to 11 to yield tick values of (0,10,20,...,100).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Draw the axis. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.RenderOverlay(vtk.vtkViewport)">
            <summary>
                <para>Draw the axis. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetLabelFactor">
            <summary>
                <para>Set/Get the factor that controls the relative size of the axis labels to the axis title.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetLabelFactorMaxValue">
            <summary>
                <para>Set/Get the factor that controls the relative size of the axis labels to the axis title.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetLabelFactorMinValue">
            <summary>
                <para>Set/Get the factor that controls the relative size of the axis labels to the axis title.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetLabelFactor(System.Double)">
            <summary>
                <para>Set/Get the factor that controls the relative size of the axis labels to the axis title.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetFontFactor">
            <summary>
                <para>Set/Get the factor that controls the overall size of the fonts used to label and title the axes. This ivar used in conjunction with the LabelFactor can be used to control font sizes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetFontFactorMaxValue">
            <summary>
                <para>Set/Get the factor that controls the overall size of the fonts used to label and title the axes. This ivar used in conjunction with the LabelFactor can be used to control font sizes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetFontFactorMinValue">
            <summary>
                <para>Set/Get the factor that controls the overall size of the fonts used to label and title the axes. This ivar used in conjunction with the LabelFactor can be used to control font sizes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetFontFactor(System.Double)">
            <summary>
                <para>Set/Get the factor that controls the overall size of the fonts used to label and title the axes. This ivar used in conjunction with the LabelFactor can be used to control font sizes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.TitleVisibilityOff">
            <summary>
                <para>Set/Get visibility of the axis title.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.TitleVisibilityOn">
            <summary>
                <para>Set/Get visibility of the axis title.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTitleVisibility">
            <summary>
                <para>Set/Get visibility of the axis title.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetTitleVisibility(System.Int32)">
            <summary>
                <para>Set/Get visibility of the axis title.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.LabelVisibilityOff">
            <summary>
                <para>Set/Get visibility of the axis labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.LabelVisibilityOn">
            <summary>
                <para>Set/Get visibility of the axis labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetLabelVisibility">
            <summary>
                <para>Set/Get visibility of the axis labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetLabelVisibility(System.Int32)">
            <summary>
                <para>Set/Get visibility of the axis labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.TickVisibilityOff">
            <summary>
                <para>Set/Get visibility of the axis tick marks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.TickVisibilityOn">
            <summary>
                <para>Set/Get visibility of the axis tick marks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTickVisibility">
            <summary>
                <para>Set/Get visibility of the axis tick marks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetTickVisibility(System.Int32)">
            <summary>
                <para>Set/Get visibility of the axis tick marks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.AxisVisibilityOff">
            <summary>
                <para>Set/Get visibility of the axis line.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.AxisVisibilityOn">
            <summary>
                <para>Set/Get visibility of the axis line.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetAxisVisibility">
            <summary>
                <para>Set/Get visibility of the axis line.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetAxisVisibility(System.Int32)">
            <summary>
                <para>Set/Get visibility of the axis line.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTickOffset">
            <summary>
                <para>Set/Get the offset of the labels (expressed in pixels or display coordinates). The offset is the distance of labels from tick marks or other objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTickOffsetMaxValue">
            <summary>
                <para>Set/Get the offset of the labels (expressed in pixels or display coordinates). The offset is the distance of labels from tick marks or other objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTickOffsetMinValue">
            <summary>
                <para>Set/Get the offset of the labels (expressed in pixels or display coordinates). The offset is the distance of labels from tick marks or other objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetTickOffset(System.Int32)">
            <summary>
                <para>Set/Get the offset of the labels (expressed in pixels or display coordinates). The offset is the distance of labels from tick marks or other objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTickLength">
            <summary>
                <para>Set/Get the length of the tick marks (expressed in pixels or display coordinates). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTickLengthMaxValue">
            <summary>
                <para>Set/Get the length of the tick marks (expressed in pixels or display coordinates). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTickLengthMinValue">
            <summary>
                <para>Set/Get the length of the tick marks (expressed in pixels or display coordinates). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetTickLength(System.Int32)">
            <summary>
                <para>Set/Get the length of the tick marks (expressed in pixels or display coordinates). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetLabelTextProperty">
            <summary>
                <para>Set/Get the labels text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetLabelTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the labels text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTitleTextProperty">
            <summary>
                <para>Set/Get the title text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetTitleTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the title text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetTitle">
            <summary>
                <para>Set/Get the title of the scalar bar actor,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetTitle(System.String)">
            <summary>
                <para>Set/Get the title of the scalar bar actor,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetAdjustedNumberOfLabels">
            <summary>
                <para>Set/Get the title of the scalar bar actor,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetAdjustedRange(System.Double[])">
            <summary>
                <para>Set/Get the flag that controls whether the labels and ticks are adjusted for "nice" numerical values to make it easier to read  the labels. The adjustment is based in the Range instance variable. Call GetAdjustedRange and GetAdjustedNumberOfLabels to get the adjusted range and number of labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetAdjustedRange(System.Double@,System.Double@)">
            <summary>
                <para>Set/Get the flag that controls whether the labels and ticks are adjusted for "nice" numerical values to make it easier to read  the labels. The adjustment is based in the Range instance variable. Call GetAdjustedRange and GetAdjustedNumberOfLabels to get the adjusted range and number of labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.AdjustLabelsOff">
            <summary>
                <para>Set/Get the flag that controls whether the labels and ticks are adjusted for "nice" numerical values to make it easier to read  the labels. The adjustment is based in the Range instance variable. Call GetAdjustedRange and GetAdjustedNumberOfLabels to get the adjusted range and number of labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.AdjustLabelsOn">
            <summary>
                <para>Set/Get the flag that controls whether the labels and ticks are adjusted for "nice" numerical values to make it easier to read  the labels. The adjustment is based in the Range instance variable. Call GetAdjustedRange and GetAdjustedNumberOfLabels to get the adjusted range and number of labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetAdjustLabels">
            <summary>
                <para>Set/Get the flag that controls whether the labels and ticks are adjusted for "nice" numerical values to make it easier to read  the labels. The adjustment is based in the Range instance variable. Call GetAdjustedRange and GetAdjustedNumberOfLabels to get the adjusted range and number of labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetAdjustLabels(System.Int32)">
            <summary>
                <para>Set/Get the flag that controls whether the labels and ticks are adjusted for "nice" numerical values to make it easier to read  the labels. The adjustment is based in the Range instance variable. Call GetAdjustedRange and GetAdjustedNumberOfLabels to get the adjusted range and number of labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetLabelFormat">
            <summary>
                <para>Set/Get the format with which to print the labels on the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetLabelFormat(System.String)">
            <summary>
                <para>Set/Get the format with which to print the labels on the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetNumberOfLabels">
            <summary>
                <para>Set/Get the number of annotation labels to show.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetNumberOfLabelsMaxValue">
            <summary>
                <para>Set/Get the number of annotation labels to show.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetNumberOfLabelsMinValue">
            <summary>
                <para>Set/Get the number of annotation labels to show.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetNumberOfLabels(System.Int32)">
            <summary>
                <para>Set/Get the number of annotation labels to show.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetRange">
            <summary>
                <para>Specify the (min,max) axis range. This will be used in the generation of labels, if labels are visible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetRange(System.Double[])">
            <summary>
                <para>Specify the (min,max) axis range. This will be used in the generation of labels, if labels are visible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetRange(System.Double,System.Double)">
            <summary>
                <para>Specify the (min,max) axis range. This will be used in the generation of labels, if labels are visible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetPoint2(System.Double,System.Double)">
            <summary>
                <para>Specify the position of the second point defining the axis. Note that the order from Point1 to Point2 controls which side the tick marks are drawn on (ticks are drawn on the right, if visible). Note: backward compatibility only, use vtkActor2D's Position2 instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetPoint2(System.Double[])">
            <summary>
                <para>Specify the position of the second point defining the axis. Note that the order from Point1 to Point2 controls which side the tick marks are drawn on (ticks are drawn on the right, if visible). Note: backward compatibility only, use vtkActor2D's Position2 instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetPoint2Coordinate">
            <summary>
                <para>Specify the position of the second point defining the axis. Note that the order from Point1 to Point2 controls which side the tick marks are drawn on (ticks are drawn on the right, if visible). Note: backward compatibility only, use vtkActor2D's Position2 instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetPoint1(System.Double,System.Double)">
            <summary>
                <para>Specify the position of the first point defining the axis. Note: backward compatibility only, use vtkActor2D's Position instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.SetPoint1(System.Double[])">
            <summary>
                <para>Specify the position of the first point defining the axis. Note: backward compatibility only, use vtkActor2D's Position instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxisActor2D.GetPoint1Coordinate">
            <summary>
                <para>Specify the position of the first point defining the axis. Note: backward compatibility only, use vtkActor2D's Position instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTextProperty.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVolume.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVolume.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCamera.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCamera.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkActorCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkActorCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExporter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExporter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointPicker.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPointPicker.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPointPicker.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPointPicker.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPointPicker.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPointPicker.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPointPicker.GetPointId">
            <summary>
                <para>Get the id of the picked point. If PointId = -1, nothing was picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.ExitCallback">
            <summary>
                <para>These methods correspond to the the Exit, User and Pick callbacks. They allow for the Style to invoke them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.DestroyTimer">
            <summary>
                <para>Win32 timer methods</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.CreateTimer(System.Int32)">
            <summary>
                <para>Win32 timer methods</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.TerminateApp">
            <summary>
                <para>Win32 specific application terminate, calls ClassExitMethod then calls PostQuitMessage(0) to terminate the application. An application can Specify ExitMethod for alternative behavior (i.e. suppression of keyboard exit)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.InstallMessageProcOff">
            <summary>
                <para>By default the interactor installs a MessageProc callback which intercepts windows messages to the window and controls interactions. MFC or BCB programs can prevent this and instead directly route any mouse/key messages into the event bindings by setting InstallMessgeProc to false.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.InstallMessageProcOn">
            <summary>
                <para>By default the interactor installs a MessageProc callback which intercepts windows messages to the window and controls interactions. MFC or BCB programs can prevent this and instead directly route any mouse/key messages into the event bindings by setting InstallMessgeProc to false.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.GetInstallMessageProc">
            <summary>
                <para>By default the interactor installs a MessageProc callback which intercepts windows messages to the window and controls interactions. MFC or BCB programs can prevent this and instead directly route any mouse/key messages into the event bindings by setting InstallMessgeProc to false.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.SetInstallMessageProc(System.Int32)">
            <summary>
                <para>By default the interactor installs a MessageProc callback which intercepts windows messages to the window and controls interactions. MFC or BCB programs can prevent this and instead directly route any mouse/key messages into the event bindings by setting InstallMessgeProc to false.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.Start">
            <summary>
                <para>This will start up the event loop and never return. If you call this method it will loop processing events until the application is exited.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.Disable">
            <summary>
                <para>Enable/Disable interactions.  By default interactors are enabled when initialized.  Initialize() must be called prior to enabling/disabling interaction. These methods are used when a window/widget is being shared by multiple renderers and interactors.  This allows a "modal" display where one interactor is active when its data is to be displayed and all other interactors associated with the widget are disabled when their data is not displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.Enable">
            <summary>
                <para>Enable/Disable interactions.  By default interactors are enabled when initialized.  Initialize() must be called prior to enabling/disabling interaction. These methods are used when a window/widget is being shared by multiple renderers and interactors.  This allows a "modal" display where one interactor is active when its data is to be displayed and all other interactors associated with the widget are disabled when their data is not displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32RenderWindowInteractor.Initialize">
            <summary>
                <para>Initialize the event handler</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.EndReverseFly">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.StartReverseFly">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.EndForwardFly">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.StartForwardFly">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.ReverseFly">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.ForwardFly">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnTimer">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnKeyUp">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnKeyDown">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnChar">
            <summary>
                <para>Concrete implementation of Keyboard event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnRightButtonUp">
            <summary>
                <para>Concrete implementation of Mouse event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnRightButtonDown">
            <summary>
                <para>Concrete implementation of Mouse event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnMiddleButtonUp">
            <summary>
                <para>Concrete implementation of Mouse event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnMiddleButtonDown">
            <summary>
                <para>Concrete implementation of Mouse event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnLeftButtonUp">
            <summary>
                <para>Concrete implementation of Mouse event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnLeftButtonDown">
            <summary>
                <para>Concrete implementation of Mouse event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.OnMouseMove">
            <summary>
                <para>Concrete implementation of Mouse event bindings for flight</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.RestoreUpVectorOff">
            <summary>
                <para>When flying, apply a restorative force to the "Up" vector. This is activated when the current 'up' is close to the actual 'up' (as defined in DefaultUpVector). This prevents excessive twisting forces when viewing from arbitrary angles, but keep the horizon level when the user is flying over terrain.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.RestoreUpVectorOn">
            <summary>
                <para>When flying, apply a restorative force to the "Up" vector. This is activated when the current 'up' is close to the actual 'up' (as defined in DefaultUpVector). This prevents excessive twisting forces when viewing from arbitrary angles, but keep the horizon level when the user is flying over terrain.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.GetRestoreUpVector">
            <summary>
                <para>When flying, apply a restorative force to the "Up" vector. This is activated when the current 'up' is close to the actual 'up' (as defined in DefaultUpVector). This prevents excessive twisting forces when viewing from arbitrary angles, but keep the horizon level when the user is flying over terrain.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.SetRestoreUpVector(System.Int32)">
            <summary>
                <para>When flying, apply a restorative force to the "Up" vector. This is activated when the current 'up' is close to the actual 'up' (as defined in DefaultUpVector). This prevents excessive twisting forces when viewing from arbitrary angles, but keep the horizon level when the user is flying over terrain.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.DisableMotionOff">
            <summary>
                <para>Disable motion (temporarily - for viewing etc)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.DisableMotionOn">
            <summary>
                <para>Disable motion (temporarily - for viewing etc)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.GetDisableMotion">
            <summary>
                <para>Disable motion (temporarily - for viewing etc)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.SetDisableMotion(System.Int32)">
            <summary>
                <para>Disable motion (temporarily - for viewing etc)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.GetAngleAccelerationFactor">
            <summary>
                <para>Set angular acceleration when shift key is applied : default 5</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.SetAngleAccelerationFactor(System.Double)">
            <summary>
                <para>Set angular acceleration when shift key is applied : default 5</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.GetAngleStepSize">
            <summary>
                <para>Set the basic angular unit for turning : default 1 degree</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.SetAngleStepSize(System.Double)">
            <summary>
                <para>Set the basic angular unit for turning : default 1 degree</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.GetMotionAccelerationFactor">
            <summary>
                <para>Set acceleration factor when shift key is applied : default 10</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.SetMotionAccelerationFactor(System.Double)">
            <summary>
                <para>Set acceleration factor when shift key is applied : default 10</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.GetMotionStepSize">
            <summary>
                <para>Set the basic unit step size : by default 1/250 of bounding diagonal</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.SetMotionStepSize(System.Double)">
            <summary>
                <para>Set the basic unit step size : by default 1/250 of bounding diagonal</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleFlight.JumpTo(System.Double[],System.Double[])">
            <summary>
                <para>Move the Eye/Camera to a specific location (no intermediate steps are taken</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetMTime">
            <summary>
                <para>Override GetMTime() because we depend on the interpolators which may be modified outside of this class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetClippingRangeInterpolator">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetClippingRangeInterpolator(vtk.vtkTupleInterpolator)">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetParallelScaleInterpolator">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetParallelScaleInterpolator(vtk.vtkTupleInterpolator)">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetViewAngleInterpolator">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetViewAngleInterpolator(vtk.vtkTupleInterpolator)">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetViewUpInterpolator">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetViewUpInterpolator(vtk.vtkTupleInterpolator)">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetFocalPointInterpolator">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetFocalPointInterpolator(vtk.vtkTupleInterpolator)">
            <summary />
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetPositionInterpolator">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the position portion of the camera. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances directly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetPositionInterpolator(vtk.vtkTupleInterpolator)">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the position portion of the camera. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances directly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetInterpolationTypeToManual">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the position portion of the camera. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances directly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetInterpolationTypeToSpline">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the instance variable interpolators (i.e., position, focal point, clipping range, orientation, etc.) interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetInterpolationTypeToLinear">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the instance variable interpolators (i.e., position, focal point, clipping range, orientation, etc.) interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetInterpolationType">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the instance variable interpolators (i.e., position, focal point, clipping range, orientation, etc.) interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetInterpolationTypeMaxValue">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the instance variable interpolators (i.e., position, focal point, clipping range, orientation, etc.) interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetInterpolationTypeMinValue">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the instance variable interpolators (i.e., position, focal point, clipping range, orientation, etc.) interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.SetInterpolationType(System.Int32)">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the instance variable interpolators (i.e., position, focal point, clipping range, orientation, etc.) interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.InterpolateCamera(System.Double,vtk.vtkCamera)">
            <summary>
                <para>Interpolate the list of cameras and determine a new camera (i.e., fill in the camera provided). If t is outside the range of (min,max) values, then t is clamped to lie within this range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.RemoveCamera(System.Double)">
            <summary>
                <para>Delete the camera at a particular parameter t. If there is no camera defined at location t, then the method does nothing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.AddCamera(System.Double,vtk.vtkCamera)">
            <summary>
                <para>Add another camera to the list of cameras defining the camera function. Note that using the same time t value more than once replaces the previous camera value at t. At least one camera must be added to define a function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.Initialize">
            <summary>
                <para>Clear the list of cameras.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetMaximumT">
            <summary>
                <para>Obtain some information about the interpolation range. The numbers returned are undefined if the list of cameras is empty.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetMinimumT">
            <summary>
                <para>Obtain some information about the interpolation range. The numbers returned are undefined if the list of cameras is empty.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCameraInterpolator.GetNumberOfCameras">
            <summary>
                <para>Return the number of cameras in the list of cameras.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImagingFactory.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImagingFactory.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImagingFactory.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImagingFactory.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImagingFactory.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImagingFactory.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImagingFactory.GetUseMesaClasses">
            <summary>
                <para>This option enables the creation of Mesa classes instead of the OpenGL classes when using mangled Mesa.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImagingFactory.SetUseMesaClasses(System.Int32)">
            <summary>
                <para>This option enables the creation of Mesa classes instead of the OpenGL classes when using mangled Mesa.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImagingFactory.CreateInstance(System.String)">
            <summary>
                <para>Create and return an instance of the named vtk object. This method first checks the vtkObjectFactory to support dynamic loading. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellPicker.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCellPicker.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCellPicker.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCellPicker.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCellPicker.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCellPicker.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCellPicker.GetPCoords">
            <summary>
                <para>Get the parametric coordinates of the picked cell. Only valid if  pick was made.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellPicker.GetSubId">
            <summary>
                <para>Get the subId of the picked cell. If SubId = -1, nothing was picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCellPicker.GetCellId">
            <summary>
                <para>Get the id of the picked cell. If CellId = -1, nothing was picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLightKit.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLightKit.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLightKit.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLightKit.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLightKit.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetShortStringFromSubType(System.Int32)">
            <summary>
                <para>Helper method to go from a enum subtype to a string subtype The difference from GetStringFromSubType is that it returns a shorter strings (usefull for GUI with minimun space)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetStringFromSubType(System.Int32)">
            <summary>
                <para>Helper method to go from a enum subtype to a string subtype</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetStringFromType(System.Int32)">
            <summary>
                <para>Helper method to go from a enum type to a string type</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.RemoveLightsFromRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Add lights to, or remove lights from, a renderer.   Lights may be added to more than one renderer, if desired.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.AddLightsToRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Add lights to, or remove lights from, a renderer.   Lights may be added to more than one renderer, if desired.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.SetKeyLightAngle(System.Double[])">
            <summary>
                <para>Get/Set the position of the key, fill, and back lights using angular methods.  Elevation corresponds to latitude, azimuth to longitude.  It is recommended that the key light always be on the viewer's side of the object and above the object, while the fill light generally lights the part of the object not lit by the fill light.  The headlight, which is always located at the viewer, can then be used to reduce the contrast in the image. There are a pair of back lights.  They are located at the same elevation and at opposing azimuths (ie, one to the left, and one to the right).  They are generally set at the equator (elevation = 0), and at approximately 120 degrees (lighting from each side and behind).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.SetKeyLightAngle(System.Double,System.Double)">
            <summary>
                <para>Get/Set the position of the key, fill, and back lights using angular methods.  Elevation corresponds to latitude, azimuth to longitude.  It is recommended that the key light always be on the viewer's side of the object and above the object, while the fill light generally lights the part of the object not lit by the fill light.  The headlight, which is always located at the viewer, can then be used to reduce the contrast in the image. There are a pair of back lights.  They are located at the same elevation and at opposing azimuths (ie, one to the left, and one to the right).  They are generally set at the equator (elevation = 0), and at approximately 120 degrees (lighting from each side and behind).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.SetMaintainLuminance(System.Int32)">
            <summary>
                <para>If MaintainLuminance is set, the LightKit will attempt to maintain the apparent intensity of lights based on their perceptual brightnesses. By default, MaintainLuminance is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetMaintainLuminance">
            <summary>
                <para>If MaintainLuminance is set, the LightKit will attempt to maintain the apparent intensity of lights based on their perceptual brightnesses. By default, MaintainLuminance is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.MaintainLuminanceOff">
            <summary>
                <para>If MaintainLuminance is set, the LightKit will attempt to maintain the apparent intensity of lights based on their perceptual brightnesses. By default, MaintainLuminance is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.MaintainLuminanceOn">
            <summary>
                <para>If MaintainLuminance is set, the LightKit will attempt to maintain the apparent intensity of lights based on their perceptual brightnesses. By default, MaintainLuminance is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetHeadlightColor(System.Double[])">
            <summary>
                <para>To maintain a deprecation API:</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetHeadlightWarmth">
            <summary>
                <para>To maintain a deprecation API:</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.SetHeadlightWarmth(System.Double)">
            <summary>
                <para>To maintain a deprecation API:</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetBackLightColor">
            <summary>
                <para>Returns the floating-point RGB values of each of the light's color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetHeadLightColor">
            <summary>
                <para>Returns the floating-point RGB values of each of the light's color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetFillLightColor">
            <summary>
                <para>Returns the floating-point RGB values of each of the light's color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyLightColor">
            <summary>
                <para>Returns the floating-point RGB values of each of the light's color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyLightWarmth">
            <summary>
                <para>Set the warmth of each the lights.  Warmth is a parameter that varies from 0 to 1, where 0 is "cold" (looks icy or lit by a very blue sky), 1 is "warm" (the red of a very red sunset, or the embers of a campfire), and 0.5 is a neutral white.  The warmth scale is non-linear. Warmth values close to 0.5 are subtly "warmer" or "cooler," much like a warmer tungsten incandescent bulb, a cooler halogen, or daylight (cooler still).  Moving further away from 0.5, colors become more quickly varying towards blues and reds.  With regards to aesthetics, extremes of warmth should be used sparingly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.SetKeyLightWarmth(System.Double)">
            <summary>
                <para>Set the warmth of each the lights.  Warmth is a parameter that varies from 0 to 1, where 0 is "cold" (looks icy or lit by a very blue sky), 1 is "warm" (the red of a very red sunset, or the embers of a campfire), and 0.5 is a neutral white.  The warmth scale is non-linear. Warmth values close to 0.5 are subtly "warmer" or "cooler," much like a warmer tungsten incandescent bulb, a cooler halogen, or daylight (cooler still).  Moving further away from 0.5, colors become more quickly varying towards blues and reds.  With regards to aesthetics, extremes of warmth should be used sparingly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyToBackRatio">
            <summary>
                <para>Set/Get the key-to-back light ratio.  This ratio controls how bright the back lights are compared to the key light: larger values correspond to dimmer back lights.  The back lights fill in the remaining high-contrast regions behind the object. Values between 2 and 10 are good.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyToBackRatioMaxValue">
            <summary>
                <para>Set/Get the key-to-back light ratio.  This ratio controls how bright the back lights are compared to the key light: larger values correspond to dimmer back lights.  The back lights fill in the remaining high-contrast regions behind the object. Values between 2 and 10 are good.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyToBackRatioMinValue">
            <summary>
                <para>Set/Get the key-to-back light ratio.  This ratio controls how bright the back lights are compared to the key light: larger values correspond to dimmer back lights.  The back lights fill in the remaining high-contrast regions behind the object. Values between 2 and 10 are good.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.SetKeyToBackRatio(System.Double)">
            <summary>
                <para>Set/Get the key-to-back light ratio.  This ratio controls how bright the back lights are compared to the key light: larger values correspond to dimmer back lights.  The back lights fill in the remaining high-contrast regions behind the object. Values between 2 and 10 are good.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyToHeadRatio">
            <summary>
                <para>Set/Get the key-to-headlight ratio.  Similar to the key-to-fill ratio, this ratio controls how bright the headlight light is compared to the key light: larger values correspond to a dimmer headlight light.  The headlight is special kind of fill light, lighting only the parts of the object that the camera can see. As such, a headlight tends to reduce the contrast of a scene.  It can be used to fill in "shadows" of the object missed by the key and fill lights.  The headlight should always be significantly dimmer than the key light:  ratios of 2 to 15 are typical.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyToHeadRatioMaxValue">
            <summary>
                <para>Set/Get the key-to-headlight ratio.  Similar to the key-to-fill ratio, this ratio controls how bright the headlight light is compared to the key light: larger values correspond to a dimmer headlight light.  The headlight is special kind of fill light, lighting only the parts of the object that the camera can see. As such, a headlight tends to reduce the contrast of a scene.  It can be used to fill in "shadows" of the object missed by the key and fill lights.  The headlight should always be significantly dimmer than the key light:  ratios of 2 to 15 are typical.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyToHeadRatioMinValue">
            <summary>
                <para>Set/Get the key-to-headlight ratio.  Similar to the key-to-fill ratio, this ratio controls how bright the headlight light is compared to the key light: larger values correspond to a dimmer headlight light.  The headlight is special kind of fill light, lighting only the parts of the object that the camera can see. As such, a headlight tends to reduce the contrast of a scene.  It can be used to fill in "shadows" of the object missed by the key and fill lights.  The headlight should always be significantly dimmer than the key light:  ratios of 2 to 15 are typical.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.SetKeyToHeadRatio(System.Double)">
            <summary>
                <para>Set/Get the key-to-headlight ratio.  Similar to the key-to-fill ratio, this ratio controls how bright the headlight light is compared to the key light: larger values correspond to a dimmer headlight light.  The headlight is special kind of fill light, lighting only the parts of the object that the camera can see. As such, a headlight tends to reduce the contrast of a scene.  It can be used to fill in "shadows" of the object missed by the key and fill lights.  The headlight should always be significantly dimmer than the key light:  ratios of 2 to 15 are typical.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyToFillRatio">
            <summary>
                <para>Set/Get the key-to-fill ratio.  This ratio controls how bright the fill light is compared to the key light: larger values correspond to a dimmer fill light.  The purpose of the fill light is to light parts of the object not lit by the key light, while still maintaining constrast.  This type of lighting may correspond to indirect illumination from the key light, bounced off a wall, floor, or other object.  The fill light should never be brighter than the key light:  a good range for the key-to-fill ratio is between 2 and 10.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyToFillRatioMaxValue">
            <summary>
                <para>Set/Get the key-to-fill ratio.  This ratio controls how bright the fill light is compared to the key light: larger values correspond to a dimmer fill light.  The purpose of the fill light is to light parts of the object not lit by the key light, while still maintaining constrast.  This type of lighting may correspond to indirect illumination from the key light, bounced off a wall, floor, or other object.  The fill light should never be brighter than the key light:  a good range for the key-to-fill ratio is between 2 and 10.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyToFillRatioMinValue">
            <summary>
                <para>Set/Get the key-to-fill ratio.  This ratio controls how bright the fill light is compared to the key light: larger values correspond to a dimmer fill light.  The purpose of the fill light is to light parts of the object not lit by the key light, while still maintaining constrast.  This type of lighting may correspond to indirect illumination from the key light, bounced off a wall, floor, or other object.  The fill light should never be brighter than the key light:  a good range for the key-to-fill ratio is between 2 and 10.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.SetKeyToFillRatio(System.Double)">
            <summary>
                <para>Set/Get the key-to-fill ratio.  This ratio controls how bright the fill light is compared to the key light: larger values correspond to a dimmer fill light.  The purpose of the fill light is to light parts of the object not lit by the key light, while still maintaining constrast.  This type of lighting may correspond to indirect illumination from the key light, bounced off a wall, floor, or other object.  The fill light should never be brighter than the key light:  a good range for the key-to-fill ratio is between 2 and 10.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.GetKeyLightIntensity">
            <summary>
                <para>Set/Get the intensity of the key light.  The key light is the brightest light in the scene.  The intensities of the other two lights are ratios of the key light's intensity.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightKit.SetKeyLightIntensity(System.Double)">
            <summary>
                <para>Set/Get the intensity of the key light.  The key light is the brightest light in the scene.  The intensities of the other two lights are ratios of the key light's intensity.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkScalarBarActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of a scalar bar actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetTitle">
            <summary>
                <para>Set/Get the title of the scalar bar actor,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetTitle(System.String)">
            <summary>
                <para>Set/Get the title of the scalar bar actor,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetLabelFormat">
            <summary>
                <para>Set/Get the format with which to print the labels on the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetLabelFormat(System.String)">
            <summary>
                <para>Set/Get the format with which to print the labels on the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetLabelTextProperty">
            <summary>
                <para>Set/Get the labels text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetLabelTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the labels text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetTitleTextProperty">
            <summary>
                <para>Set/Get the title text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetTitleTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the title text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetOrientationToVertical">
            <summary>
                <para>Control the orientation of the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetOrientationToHorizontal">
            <summary>
                <para>Control the orientation of the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetOrientation">
            <summary>
                <para>Control the orientation of the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetOrientationMaxValue">
            <summary>
                <para>Control the orientation of the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetOrientationMinValue">
            <summary>
                <para>Control the orientation of the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetOrientation(System.Int32)">
            <summary>
                <para>Control the orientation of the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetNumberOfLabels">
            <summary>
                <para>Set/Get the number of annotation labels to show.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetNumberOfLabelsMaxValue">
            <summary>
                <para>Set/Get the number of annotation labels to show.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetNumberOfLabelsMinValue">
            <summary>
                <para>Set/Get the number of annotation labels to show.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetNumberOfLabels(System.Int32)">
            <summary>
                <para>Set/Get the number of annotation labels to show.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetMaximumNumberOfColors">
            <summary>
                <para>Set/Get the maximum number of scalar bar segments to show. This may differ from the number of colors in the lookup table, in which case the colors are samples from the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetMaximumNumberOfColorsMaxValue">
            <summary>
                <para>Set/Get the maximum number of scalar bar segments to show. This may differ from the number of colors in the lookup table, in which case the colors are samples from the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetMaximumNumberOfColorsMinValue">
            <summary>
                <para>Set/Get the maximum number of scalar bar segments to show. This may differ from the number of colors in the lookup table, in which case the colors are samples from the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetMaximumNumberOfColors(System.Int32)">
            <summary>
                <para>Set/Get the maximum number of scalar bar segments to show. This may differ from the number of colors in the lookup table, in which case the colors are samples from the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.GetLookupTable">
            <summary>
                <para>Set/Get the vtkLookupTable to use. The lookup table specifies the number of colors to use in the table (if not overridden), as well as the scalar range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.SetLookupTable(vtk.vtkScalarsToColors)">
            <summary>
                <para>Set/Get the vtkLookupTable to use. The lookup table specifies the number of colors to use in the table (if not overridden), as well as the scalar range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.RenderOverlay(vtk.vtkViewport)">
            <summary>
                <para>Draw the scalar bar and annotation text to the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Draw the scalar bar and annotation text to the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkScalarBarActor.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Draw the scalar bar and annotation text to the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetParentId(System.IntPtr)">
            <summary>
Sets the HWND for the parent of the render window.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetWindowId(System.IntPtr)">
            <summary>
Sets the HWND for the render window.
</summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetOffScreenRendering(System.Int32)">
            <summary>
                <para>Override the default implementation so that we can actively switch between on and off screen rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetCurrentCursor(System.Int32)">
            <summary>
                <para>Change the shape of the cursor</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetCursorPosition(System.Int32,System.Int32)">
            <summary>
                <para>Hide or Show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead. Set cursor position in window (note that (0,0) is the lower left  corner).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.ShowCursor">
            <summary>
                <para>Hide or Show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead. Set cursor position in window (note that (0,0) is the lower left  corner).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.HideCursor">
            <summary>
                <para>Hide or Show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead. Set cursor position in window (note that (0,0) is the lower left  corner).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.Clean">
            <summary>
                <para>Clean up device contexts, rendering contexts, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.ResumeScreenRendering">
            <summary>
                <para>These methods can be used by MFC applications to support print preview and printing, or more general rendering into memory.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.GetEventPending">
            <summary>
                <para>Check to see if a mouse button has been pressed. All other events are ignored by this method. This is a useful check to abort a long render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.IsDirect">
            <summary>
                <para>Is this render window using hardware acceleration? 0-false, 1-true</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SupportsOpenGL">
            <summary>
                <para>Does this render window support OpenGL? 0-false, 1-true</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.ReportCapabilities">
            <summary>
                <para>Get report of capabilities for the render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.MakeCurrent">
            <summary>
                <para>Make this windows OpenGL context the current context.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetStereoCapableWindow(System.Int32)">
            <summary>
                <para>Prescribe that the window be created in a stereo-capable mode. This method must be called before the window is realized. This method overrides the superclass method since this class can actually check whether the window has been realized yet.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetParentInfo(System.String)">
            <summary>
                <para>Sets the HWND id of the window that WILL BE created.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetNextWindowInfo(System.String)">
            <summary>
                <para>Sets the WindowInfo that will be used after a WindowRemap.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetWindowInfo(System.String)">
            <summary>
                <para>Set this RenderWindow's window id to a pre-existing window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetWindowName(System.String)">
            <summary>
                <para>Set the name of the window. This appears at the top of the window normally.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetPosition(System.Int32[])">
            <summary>
                <para>Set the position of the window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetPosition(System.Int32,System.Int32)">
            <summary>
                <para>Set the position of the window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetSize(System.Int32[])">
            <summary>
                <para>Set the size of the window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetSize(System.Int32,System.Int32)">
            <summary>
                <para>Set the size of the window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.PrefFullScreen">
            <summary>
                <para>Set the preferred window size to full screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.WindowRemap">
            <summary>
                <para>Remap the window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.SetFullScreen(System.Int32)">
            <summary>
                <para>Change the window to fill the entire screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.FinalizeWrap">
            <summary>
                <para>Finalize the rendering window.  This will shutdown all system-specific resources.  After having called this, it should be possible to destroy a window that was used for a SetWindowId() call without any ill effects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.Initialize">
            <summary>
                <para>Initialize the rendering window.  This will setup all system-specific resources.  This method and Finalize() must be symmetric and it should be possible to call them multiple times, even changing WindowId in-between.  This is what WindowRemap does.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.WindowInitialize">
            <summary>
                <para>Create the window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.Frame">
            <summary>
                <para>End the rendering process and display the image.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32OpenGLRenderWindow.Start">
            <summary>
                <para>Begin the rendering process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLRenderer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderer.UpdateLights">
            <summary>
                <para>Ask lights to load themselves into graphics pipeline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderer.ClearLights">
            <summary>
                <para>Internal method temporarily removes lights before reloading them into graphics pipeline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderer.DeviceRender">
            <summary>
                <para>Concrete open gl render method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLImageActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageActor.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this texture. The parameter window could be used to determine which graphic resources to release. Using the same texture object in multiple render windows is NOT currently supported. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageActor.Render(vtk.vtkRenderer)">
            <summary>
                <para>Implement base class method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageActor.Load(vtk.vtkRenderer)">
            <summary>
                <para>Implement base class method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProperty.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLTexture.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLTexture.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLTexture.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLTexture.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLTexture.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLTexture.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLTexture.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this texture. The parameter window could be used to determine which graphic resources to release. Using the same texture object in multiple render windows is NOT currently supported. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLTexture.Load(vtk.vtkRenderer)">
            <summary>
                <para>Implement base class method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.OpenGLInit">
            <summary>
                <para>Initialize OpenGL for this window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.GetDepthBufferSize">
            <summary>
                <para>Get the size of the depth buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.MakeCurrent">
            <summary>
                <para>Make this window the current OpenGL context.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetZbufferData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkFloatArray)">
            <summary>
                <para>Set/Get the zbuffer data from an image</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetZbufferData(System.Int32,System.Int32,System.Int32,System.Int32,System.Single[])">
            <summary>
                <para>Set/Get the zbuffer data from an image</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.GetZbufferData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkFloatArray)">
            <summary>
                <para>Set/Get the zbuffer data from an image</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.GetZbufferData(System.Int32,System.Int32,System.Int32,System.Int32,System.Single[])">
            <summary>
                <para>Set/Get the zbuffer data from an image</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetRGBACharPixelData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkUnsignedCharArray,System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBARGBA... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetRGBACharPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBARGBA... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.GetRGBACharPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBARGBA... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.ReleaseRGBAPixelData(System.Single[])">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBARGBA... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetRGBAPixelData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkFloatArray,System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBARGBA... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetRGBAPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBARGBA... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.GetRGBAPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkFloatArray)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBARGBA... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetPixelData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkUnsignedCharArray,System.Int32)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBRGB... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBRGB... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.GetPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBRGB... </para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.StereoUpdate">
            <summary>
                <para>Update system if needed due to stereo rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.GetMultiSamples">
            <summary>
                <para>Set / Get the number of multisamples to use for hardware antialiasing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetMultiSamples(System.Int32)">
            <summary>
                <para>Set / Get the number of multisamples to use for hardware antialiasing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.GetGlobalMaximumNumberOfMultiSamples">
            <summary>
                <para>Set/Get the maximum number of multisamples</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLRenderWindow.SetGlobalMaximumNumberOfMultiSamples(System.Int32)">
            <summary>
                <para>Set/Get the maximum number of multisamples</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindowCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindowCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindowCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRenderWindowCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindowCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindowCollection.GetNextItem">
            <summary>
                <para>Get the next RenderWindow in the list. Return NULL when at the end of the  list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowCollection.AddItem(vtk.vtkRenderWindow)">
            <summary>
                <para>Add a RenderWindow to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageViewer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageViewer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageViewer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageViewer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageViewer.OffScreenRenderingOff">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.OffScreenRenderingOn">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetOffScreenRendering">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetOffScreenRendering(System.Int32)">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetupInteractor(vtk.vtkRenderWindowInteractor)">
            <summary>
                <para>Create and attach an interactor for this window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetActor2D">
            <summary>
                <para>Get the internal objects</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetImageMapper">
            <summary>
                <para>Get the internal objects</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetRenderer">
            <summary>
                <para>Get the internal objects</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetRenderWindow">
            <summary>
                <para>Get the internal objects</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetSize(System.Int32[])">
            <summary>
                <para>Set/Get the size of the window in screen coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetSize(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the size of the window in screen coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetSize">
            <summary>
                <para>Set/Get the size of the window in screen coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetPosition(System.Int32[])">
            <summary>
                <para>Set/Get the position in screen coordinates of the rendering window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetPosition(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the position in screen coordinates of the rendering window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetPosition">
            <summary>
                <para>Set/Get the position in screen coordinates of the rendering window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GrayScaleHintOff">
            <summary>
                <para>By default this is a color viewer.  GrayScaleHintOn will improve the appearance of gray scale images on some systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GrayScaleHintOn">
            <summary>
                <para>By default this is a color viewer.  GrayScaleHintOn will improve the appearance of gray scale images on some systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetGrayScaleHint(System.Int32)">
            <summary>
                <para>By default this is a color viewer.  GrayScaleHintOn will improve the appearance of gray scale images on some systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetGrayScaleHint">
            <summary>
                <para>By default this is a color viewer.  GrayScaleHintOn will improve the appearance of gray scale images on some systems.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetParentId(System.IntPtr)">
            <summary>
                <para>These are here for using a tk window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetWindowId(System.IntPtr)">
            <summary>
                <para>These are here for using a tk window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetDisplayId(System.IntPtr)">
            <summary>
                <para>These are here for using a tk window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetColorLevel(System.Double)">
            <summary>
                <para>Sets window/level for mapping pixels to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetColorWindow(System.Double)">
            <summary>
                <para>Sets window/level for mapping pixels to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetColorLevel">
            <summary>
                <para>Sets window/level for mapping pixels to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetColorWindow">
            <summary>
                <para>Sets window/level for mapping pixels to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetZSlice(System.Int32)">
            <summary>
                <para>Set/Get the current Z Slice to display</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetZSlice">
            <summary>
                <para>Set/Get the current Z Slice to display</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetWholeZMax">
            <summary>
                <para>What is the possible Min/ Max z slices available.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetWholeZMin">
            <summary>
                <para>What is the possible Min/ Max z slices available.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetInputConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Set/Get the input to the viewer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetInput">
            <summary>
                <para>Set/Get the input to the viewer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.SetInput(vtk.vtkImageData)">
            <summary>
                <para>Set/Get the input to the viewer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.Render">
            <summary>
                <para>Render the resulting image.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer.GetWindowName">
            <summary>
                <para>Get name of rendering window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProp3DCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProp3DCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.OnChar">
            <summary>
                <para>Override the "fly-to" (f keypress) for images.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.OnRightButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.OnRightButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.OnLeftButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.OnLeftButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.OnMouseMove">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.GetWindowLevelCurrentPosition">
            <summary>
                <para>Some useful information for handling window level</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleImage.GetWindowLevelStartPosition">
            <summary>
                <para>Some useful information for handling window level</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageViewer2.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetZSlice(System.Int32)">
            <summary>
                <para>@deprecated Replaced by vtkImageViewer2::SetSlice() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetZSlice">
            <summary>
                <para>@deprecated Replaced by vtkImageViewer2::GetSlice() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetWholeZMax">
            <summary>
                <para>@deprecated Replaced by vtkImageViewer2::GetSliceMax() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetWholeZMin">
            <summary>
                <para>@deprecated Replaced by vtkImageViewer2::GetSliceMin() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.OffScreenRenderingOff">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.OffScreenRenderingOn">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetOffScreenRendering">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetOffScreenRendering(System.Int32)">
            <summary>
                <para>Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetupInteractor(vtk.vtkRenderWindowInteractor)">
            <summary>
                <para>Attach an interactor for the internal render window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Set your own renderwindow and renderer</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetRenderWindow(vtk.vtkRenderWindow)">
            <summary>
                <para>Set your own renderwindow and renderer</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetInteractorStyle">
            <summary>
                <para>Get the internal render window, renderer, image actor, and image map instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetWindowLevel">
            <summary>
                <para>Get the internal render window, renderer, image actor, and image map instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetImageActor">
            <summary>
                <para>Get the internal render window, renderer, image actor, and image map instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetRenderer">
            <summary>
                <para>Get the internal render window, renderer, image actor, and image map instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetRenderWindow">
            <summary>
                <para>Get the internal render window, renderer, image actor, and image map instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetSize(System.Int32[])">
            <summary>
                <para>Get the internal render window, renderer, image actor, and image map instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetSize(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the size of the window in screen coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetPosition(System.Int32[])">
            <summary>
                <para>Set/Get the size of the window in screen coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetPosition(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the position in screen coordinates of the rendering window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetParentId(System.IntPtr)">
            <summary>
                <para>These are here when using a Tk window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetWindowId(System.IntPtr)">
            <summary>
                <para>These are here when using a Tk window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetDisplayId(System.IntPtr)">
            <summary>
                <para>These are here when using a Tk window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetColorLevel(System.Double)">
            <summary>
                <para>Set window and level for mapping pixels to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetColorWindow(System.Double)">
            <summary>
                <para>Set window and level for mapping pixels to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetColorLevel">
            <summary>
                <para>Set window and level for mapping pixels to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetColorWindow">
            <summary>
                <para>Set window and level for mapping pixels to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetSliceRange(System.Int32@,System.Int32@)">
            <summary>
                <para>Return the minimum and maximum slice values (depending on the orientation this can be in X, Y or Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetSliceRange(System.Int32[])">
            <summary>
                <para>Return the minimum and maximum slice values (depending on the orientation this can be in X, Y or Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetSliceMax">
            <summary>
                <para>Return the minimum and maximum slice values (depending on the orientation this can be in X, Y or Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetSliceMin">
            <summary>
                <para>Return the minimum and maximum slice values (depending on the orientation this can be in X, Y or Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetSlice(System.Int32)">
            <summary>
                <para>Set/Get the current slice to display (depending on the orientation this can be in X, Y or Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetSlice">
            <summary>
                <para>Set/Get the current slice to display (depending on the orientation this can be in X, Y or Z).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetSliceOrientationToXZ">
            <summary>
                <para>Set/get the slice orientation</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetSliceOrientationToYZ">
            <summary>
                <para>Set/get the slice orientation</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetSliceOrientationToXY">
            <summary>
                <para>Set/get the slice orientation</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetSliceOrientation(System.Int32)">
            <summary>
                <para>Set/get the slice orientation</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetSliceOrientation">
            <summary>
                <para>Set/get the slice orientation</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetInputConnection(vtk.vtkAlgorithmOutput)">
            <summary>
                <para>Set/Get the input image to the viewer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetInput">
            <summary>
                <para>Set/Get the input image to the viewer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.SetInput(vtk.vtkImageData)">
            <summary>
                <para>Set/Get the input image to the viewer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.Render">
            <summary>
                <para>Render the resulting image.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageViewer2.GetWindowName">
            <summary>
                <para>Get the name of rendering window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.RenderOverlay(vtk.vtkViewport,vtk.vtkActor2D)">
            <summary>
                <para>Draw the text to the screen at each input point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.RenderOpaqueGeometry(vtk.vtkViewport,vtk.vtkActor2D)">
            <summary>
                <para>Draw the text to the screen at each input point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.GetLabelTextProperty">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelModeToLabelFieldData">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetLabeledComponent to control which components to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelModeToLabelTensors">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetLabeledComponent to control which components to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelModeToLabelTCoords">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetLabeledComponent to control which components to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelModeToLabelNormals">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetLabeledComponent to control which components to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelModeToLabelVectors">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetLabeledComponent to control which components to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelModeToLabelScalars">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetLabeledComponent to control which components to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelModeToLabelIds">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetLabeledComponent to control which components to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.GetLabelMode">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetLabeledComponent to control which components to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelMode(System.Int32)">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetLabeledComponent to control which components to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.GetInput">
            <summary>
                <para>Set the input dataset to the mapper. This mapper handles any type of data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set the input dataset to the mapper. This mapper handles any type of data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.GetFieldDataArray">
            <summary>
                <para>Set/Get the field data array to label. This instance variable is only applicable if field data is labeled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.GetFieldDataArrayMaxValue">
            <summary>
                <para>Set/Get the field data array to label. This instance variable is only applicable if field data is labeled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.GetFieldDataArrayMinValue">
            <summary>
                <para>Set/Get the field data array to label. This instance variable is only applicable if field data is labeled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetFieldDataArray(System.Int32)">
            <summary>
                <para>Set/Get the field data array to label. This instance variable is only applicable if field data is labeled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.GetLabeledComponent">
            <summary>
                <para>Set/Get the component number to label if the data to print has more than one component. For example, all the components of scalars, vectors, normals, etc. are labeled by default (LabeledComponent=(-1)). However, if this ivar is nonnegative, then only the one component specified is labeled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabeledComponent(System.Int32)">
            <summary>
                <para>Set/Get the component number to label if the data to print has more than one component. For example, all the components of scalars, vectors, normals, etc. are labeled by default (LabeledComponent=(-1)). However, if this ivar is nonnegative, then only the one component specified is labeled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.GetLabelFormat">
            <summary>
                <para>Set/Get the format with which to print the labels. The format needs to change depending on what you're trying to print. For example, if you're printing a vector, 3 values are printed, whereas when printing an id only one value is printed. See also the ivar LabeledComponent which can be used to specify the component to print if you want to only print one of several.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLabeledDataMapper.SetLabelFormat(System.String)">
            <summary>
                <para>Set/Get the format with which to print the labels. The format needs to change depending on what you're trying to print. For example, if you're printing a vector, 3 values are printed, whereas when printing an id only one value is printed. See also the ivar LabeledComponent which can be used to specify the component to print if you want to only print one of several.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.OnTimer">
            <summary>
                <para>OnTimer calls RotateCamera, RotateActor etc which should be overridden by style subclasses.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.OnLeftButtonMove">
            <summary>
                <para>Concrete implementation of event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.OnLeftButtonUp">
            <summary>
                <para>Concrete implementation of event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.OnLeftButtonDown">
            <summary>
                <para>Concrete implementation of event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUnicam.OnMouseMove">
            <summary>
                <para>Concrete implementation of event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.OnRightButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.OnRightButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.OnMiddleButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.OnMiddleButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.OnLeftButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.OnLeftButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballActor.OnMouseMove">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProp3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProp3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.ShallowCopy(vtk.vtkAbstractMapper)">
            <summary>
                <para>Make a shallow copy of this mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.GetBounds(System.Double[])">
            <summary>
                <para>Return bounding box (array of six doubles) of data expressed as (xmin,xmax, ymin,ymax, zmin,zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.GetBounds">
            <summary>
                <para>Return bounding box (array of six doubles) of data expressed as (xmin,xmax, ymin,ymax, zmin,zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.GetGhostLevel">
            <summary>
                <para>Set the number of ghost cells to return.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.SetGhostLevel(System.Int32)">
            <summary>
                <para>Set the number of ghost cells to return.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.GetNumberOfSubPieces">
            <summary>
                <para>If you want only a part of the data, specify by setting the piece.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.SetNumberOfSubPieces(System.Int32)">
            <summary>
                <para>If you want only a part of the data, specify by setting the piece.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.GetNumberOfPieces">
            <summary>
                <para>If you want only a part of the data, specify by setting the piece.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.SetNumberOfPieces(System.Int32)">
            <summary>
                <para>If you want only a part of the data, specify by setting the piece.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.GetPiece">
            <summary>
                <para>If you want only a part of the data, specify by setting the piece.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.SetPiece(System.Int32)">
            <summary>
                <para>If you want only a part of the data, specify by setting the piece.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.Update">
            <summary>
                <para>Update that sets the update piece first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.GetInput">
            <summary>
                <para>Specify the input data to map.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.SetInput(vtk.vtkPolyData)">
            <summary>
                <para>Specify the input data to map.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.Render(vtk.vtkRenderer,vtk.vtkActor)">
            <summary>
                <para>This calls RenderPiece (in a for loop is streaming is necessary).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper.RenderPiece(vtk.vtkRenderer,vtk.vtkActor)">
            <summary>
                <para>Implemented by sub classes. Actual rendering is done here.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDataSetMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.GetInput">
            <summary>
                <para>Set the Input of this mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set the Input of this mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.GetMTime">
            <summary>
                <para>Get the mtime also considering the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this mapper. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDataSetMapper.GetPolyDataMapper">
            <summary>
                <para>Get the internal poly data mapper used to map data set to graphics system.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageActor.SetZSlice(System.Int32)">
            <summary>
                <para>Set/Get the current slice number. The axis Z in ZSlice does not necessarily have any relation to the z axis of the data on disk. It is simply the axis orthogonal to the x,y, display plane. GetWholeZMax and Min are convenience methods for obtaining the number of slices that can be displayed. Again the number of slices is in reference to the display z axis, which is not necessarily the z axis on disk. (due to reformatting etc)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetSliceNumber">
            <summary>
                <para>Return a slice number computed from the display extent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetDisplayBounds(System.Double[])">
            <summary>
                <para>Get the bounds of the data that is displayed by this image actor.  If the transformation matrix for this actor is the identity matrix, this will return the same value as GetBounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetBounds(System.Double[])">
            <summary>
                <para>Get the bounds of this image actor. Either copy the bounds into a user provided array or return a pointer to an array. In either case the boudns is expressed as a 6-vector  (xmin,xmax, ymin,ymax, zmin,zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetBounds">
            <summary>
                <para>Get the bounds of this image actor. Either copy the bounds into a user provided array or return a pointer to an array. In either case the boudns is expressed as a 6-vector  (xmin,xmax, ymin,ymax, zmin,zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetDisplayExtent">
            <summary>
                <para>Get the bounds of this image actor. Either copy the bounds into a user provided array or return a pointer to an array. In either case the boudns is expressed as a 6-vector  (xmin,xmax, ymin,ymax, zmin,zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetDisplayExtent(System.Int32[])">
            <summary>
                <para>The image extent is generally set explicitly, but if not set it will be determined from the input image data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.SetDisplayExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>The image extent is generally set explicitly, but if not set it will be determined from the input image data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.SetDisplayExtent(System.Int32[])">
            <summary>
                <para>The image extent is generally set explicitly, but if not set it will be determined from the input image data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetOpacity">
            <summary>
                <para>Set/Get the object's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetOpacityMaxValue">
            <summary>
                <para>Set/Get the object's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetOpacityMinValue">
            <summary>
                <para>Set/Get the object's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.SetOpacity(System.Double)">
            <summary>
                <para>Set/Get the object's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.InterpolateOff">
            <summary>
                <para>Turn on/off linear interpolation of the image when rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.InterpolateOn">
            <summary>
                <para>Turn on/off linear interpolation of the image when rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.SetInterpolate(System.Int32)">
            <summary>
                <para>Turn on/off linear interpolation of the image when rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetInterpolate">
            <summary>
                <para>Turn on/off linear interpolation of the image when rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.GetInput">
            <summary>
                <para>Set/Get the image data input for the image actor.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageActor.SetInput(vtk.vtkImageData)">
            <summary>
                <para>Set/Get the image data input for the image actor.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPicker.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProp3DCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProp3DCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProp3DCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProp3DCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProp3DCollection.GetLastProp3D">
            <summary>
                <para>Get the last actor in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3DCollection.GetNextProp3D">
            <summary>
                <para>Get the next actor in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3DCollection.AddItem(vtk.vtkProp3D)">
            <summary>
                <para>Add an actor to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPicker.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPicker.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPicker.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPicker.Pick(System.Double[],vtk.vtkRenderer)">
            <summary>
                <para>Perform pick operation with selection point provided. Normally the first two values for the selection point are x-y pixel coordinate, and the third value is =0. Return non-zero if something was successfully picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.Pick(System.Double,System.Double,System.Double,vtk.vtkRenderer)">
            <summary>
                <para>Perform pick operation with selection point provided. Normally the  first two values for the selection point are x-y pixel coordinate, and the third value is =0. Return non-zero if something was successfully  picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.GetPickedPositions">
            <summary>
                <para>Return a list of the points the the actors returned by GetActors were intersected at. The order of this list will match the order of GetActors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.GetActors">
            <summary>
                <para>Return a collection of all the actors that were intersected. This collection is not sorted. (This is a convenience method to maintain backward compatibility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.GetProp3Ds">
            <summary>
                <para>Return a collection of all the prop 3D's that were intersected by the pick ray. This collection is not sorted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.GetDataSet">
            <summary>
                <para>Get a pointer to the dataset that was picked (if any). If nothing  was picked then NULL is returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.GetMapper">
            <summary>
                <para>Return mapper that was picked (if any).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.GetMapperPosition">
            <summary>
                <para>Return position in mapper (i.e., non-transformed) coordinates of  pick point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.GetTolerance">
            <summary>
                <para>Specify tolerance for performing pick operation. Tolerance is specified as fraction of rendering window size. (Rendering window size is measured across diagonal.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPicker.SetTolerance(System.Double)">
            <summary>
                <para>Specify tolerance for performing pick operation. Tolerance is specified as fraction of rendering window size. (Rendering window size is measured across diagonal.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLFreeTypeTextMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLFreeTypeTextMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLFreeTypeTextMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLFreeTypeTextMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLFreeTypeTextMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLFreeTypeTextMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLFreeTypeTextMapper.GetSize(vtk.vtkViewport,System.Int32[])">
            <summary>
                <para>What is the size of the rectangle required to draw this mapper ?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLFreeTypeTextMapper.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLFreeTypeTextMapper.RenderOverlay(vtk.vtkViewport,vtk.vtkActor2D)">
            <summary>
                <para>Actally draw the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAssembly.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAssembly.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAssembly.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAssembly.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAssembly.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of an assembly. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.GetMTime">
            <summary>
                <para>Override default GetMTime method to also consider all of the assembly's parts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.GetBounds">
            <summary>
                <para>Get the bounds for the assembly as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.GetBounds(System.Double[])">
            <summary>
                <para>Get the bounds for the assembly as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.GetNumberOfPaths">
            <summary>
                <para>Methods to traverse the parts of an assembly. Each part (starting from the root) will appear properly transformed and with the correct properties (depending upon the ApplyProperty and ApplyTransform ivars). Note that the part appears as an instance of vtkProp. These methods should be contrasted to those that traverse the list of parts using GetParts().  GetParts() returns a list of children of this assembly, not necessarily with the correct transformation or properties. To use the methods below - first invoke InitPathTraversal() followed by repeated calls to GetNextPath().  GetNextPath() returns a NULL pointer when the list is exhausted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.GetNextPath">
            <summary>
                <para>Methods to traverse the parts of an assembly. Each part (starting from the root) will appear properly transformed and with the correct properties (depending upon the ApplyProperty and ApplyTransform ivars). Note that the part appears as an instance of vtkProp. These methods should be contrasted to those that traverse the list of parts using GetParts().  GetParts() returns a list of children of this assembly, not necessarily with the correct transformation or properties. To use the methods below - first invoke InitPathTraversal() followed by repeated calls to GetNextPath().  GetNextPath() returns a NULL pointer when the list is exhausted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.InitPathTraversal">
            <summary>
                <para>Methods to traverse the parts of an assembly. Each part (starting from the root) will appear properly transformed and with the correct properties (depending upon the ApplyProperty and ApplyTransform ivars). Note that the part appears as an instance of vtkProp. These methods should be contrasted to those that traverse the list of parts using GetParts().  GetParts() returns a list of children of this assembly, not necessarily with the correct transformation or properties. To use the methods below - first invoke InitPathTraversal() followed by repeated calls to GetNextPath().  GetNextPath() returns a NULL pointer when the list is exhausted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Render this assembly and all its parts.  The rendering process is recursive. Note that a mapper need not be defined. If not defined, then no geometry  will be drawn for this assembly. This allows you to create "logical" assemblies; that is, assemblies that only serve to group and transform its parts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Render this assembly and all its parts.  The rendering process is recursive. Note that a mapper need not be defined. If not defined, then no geometry  will be drawn for this assembly. This allows you to create "logical" assemblies; that is, assemblies that only serve to group and transform its parts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.GetVolumes(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.GetActors(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.GetParts">
            <summary>
                <para>Return the parts (direct descendants) of this assembly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.RemovePart(vtk.vtkProp3D)">
            <summary>
                <para>Remove a part from the list of parts,</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAssembly.AddPart(vtk.vtkProp3D)">
            <summary>
                <para>Add a part to the list of parts.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.GetProp">
            <summary>
                <para>@deprecated Replaced by vtkAbstractPicker::GetViewProp() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.GetPropAssembly">
            <summary>
                <para>Return the vtkPropAssembly that has been picked. If NULL, no prop assembly was picked. (Note: the returned prop assembly is the first node in the assembly path. If the path is one node long, then the prop assembly and the prop are the same, assuming that the first node is a vtkPropAssembly.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.GetAssembly">
            <summary>
                <para>Return the vtkAssembly that has been picked. If NULL, no assembly  was picked. (Note: the returned assembly is the first node in the assembly path. If the path is one node long, then the assembly and the prop are the same, assuming that the first node is a vtkAssembly.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.GetVolume">
            <summary>
                <para>Return the vtkVolume that has been picked. If NULL, no volume was picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.GetActor2D">
            <summary>
                <para>Return the vtkActor2D that has been picked. If NULL, no actor2D was  picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.GetActor">
            <summary>
                <para>Return the vtkActor that has been picked. If NULL, no actor was picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.GetProp3D">
            <summary>
                <para>Return the vtkProp that has been picked. If NULL, no vtkProp3D was picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.GetViewProp">
            <summary>
                <para>Return the vtkProp that has been picked. If NULL, nothing was picked. If anything at all was picked, this method will return something.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.GetPath">
            <summary>
                <para>Return the vtkAssemblyPath that has been picked. The assembly path lists all the vtkProps that form an assembly. If no assembly is present, then the assembly path will have one node (which is the picked prop). The set method is used internally to set the path. (Note: the structure of an assembly path is a collection of vtkAssemblyNode, each node pointing to a vtkProp and (possibly) a transformation matrix.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPropPicker.SetPath(vtk.vtkAssemblyPath)">
            <summary>
                <para>Return the vtkAssemblyPath that has been picked. The assembly path lists all the vtkProps that form an assembly. If no assembly is present, then the assembly path will have one node (which is the picked prop). The set method is used internally to set the path. (Note: the structure of an assembly path is a collection of vtkAssemblyNode, each node pointing to a vtkProp and (possibly) a transformation matrix.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLODActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkMapperCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMapperCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMapperCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMapperCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMapperCollection.GetLastItem">
            <summary>
                <para>Get the last mapper in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapperCollection.GetNextItem">
            <summary>
                <para>Get the next mapper in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapperCollection.AddItem(vtk.vtkMapper)">
            <summary>
                <para>Add an mapper to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLODActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLODActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLODActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLODActor.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of an LOD actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.Modified">
            <summary>
                <para>When this objects gets modified, this method also modifies the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.GetLODMappers">
            <summary>
                <para>All the mappers for different LODs are stored here. The order is not important.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.SetNumberOfCloudPoints(System.Int32)">
            <summary>
                <para>Set/Get the number of random points for the point cloud.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.GetNumberOfCloudPoints">
            <summary>
                <para>Set/Get the number of random points for the point cloud.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.AddLODMapper(vtk.vtkMapper)">
            <summary>
                <para>Add another level of detail.  They do not have to be in any order of complexity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>This method is used internally by the rendering process. We overide  the superclass method to properly set the estimated render time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODActor.Render(vtk.vtkRenderer,vtk.vtkMapper)">
            <summary>
                <para>This causes the actor to be rendered. It, in turn, will render the actor's property and then mapper.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.LoadExtension(System.String)">
            <summary>
                <para>Loads all the functions associated with the given extension into the appropriate static members of vtkgl.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.ExtensionSupported(System.String)">
            <summary>
                <para>Returns true if the extension is supported, false otherwise.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.GetExtensionsString">
            <summary>
                <para>Returns a string listing all available extensions.  Call Update first to validate this string.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.Update">
            <summary>
                <para>Updates the extensions string.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.SetRenderWindow(vtk.vtkRenderWindow)">
            <summary>
                <para>Set/Get the render window to query extensions on.  If set to null, justs queries the current render window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLExtensionManager.GetRenderWindow">
            <summary>
                <para>Set/Get the render window to query extensions on.  If set to null, justs queries the current render window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkScaledTextActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkScaledTextActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkScaledTextActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkScaledTextActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkScaledTextActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkScaledTextActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnLeave">
            <summary>
                <para>These are more esoteric events, but are useful in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnEnter">
            <summary>
                <para>These are more esoteric events, but are useful in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnConfigure">
            <summary>
                <para>These are more esoteric events, but are useful in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnExpose">
            <summary>
                <para>These are more esoteric events, but are useful in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnKeyRelease">
            <summary>
                <para>Keyboard functions</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnKeyPress">
            <summary>
                <para>Keyboard functions</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnChar">
            <summary>
                <para>Keyboard functions</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnRightButtonUp">
            <summary>
                <para>Generic event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnRightButtonDown">
            <summary>
                <para>Generic event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnMiddleButtonUp">
            <summary>
                <para>Generic event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnMiddleButtonDown">
            <summary>
                <para>Generic event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnLeftButtonUp">
            <summary>
                <para>Generic event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnLeftButtonDown">
            <summary>
                <para>Generic event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.OnMouseMove">
            <summary>
                <para>Generic event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.GetButton">
            <summary>
                <para>Get the mouse button that was last pressed inside the window (returns zero when the button is released).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.GetKeySym">
            <summary>
                <para>Get the KeySym (in the same format as Tk KeySyms) for a  KeyPress or KeyRelease method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.GetChar">
            <summary>
                <para>Get the character for a Char event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.GetCtrlKey">
            <summary>
                <para>Test whether modifiers were held down when mouse button or key was pressed</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.GetShiftKey">
            <summary>
                <para>Test whether modifiers were held down when mouse button or key was pressed</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.GetOldPos">
            <summary>
                <para>Get the previous mouse position during mouse motion, or after a key press.  This can be used to calculate the relative  displacement of the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleUser.GetLastPos">
            <summary>
                <para>Get the most recent mouse position during mouse motion.   In your user interaction method, you must use this to track the mouse movement.  Do not use GetEventPosition(), which records the last position where a mouse button was pressed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLExporter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVRMLExporter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVRMLExporter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVRMLExporter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVRMLExporter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVRMLExporter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVRMLExporter.GetSpeed">
            <summary>
                <para>Specify the Speed of navigation. Default is 4.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLExporter.SetSpeed(System.Double)">
            <summary>
                <para>Specify the Speed of navigation. Default is 4.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLExporter.GetFileName">
            <summary>
                <para>Specify the name of the VRML file to write.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLExporter.SetFileName(System.String)">
            <summary>
                <para>Specify the name of the VRML file to write.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIVExporter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkIVExporter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkIVExporter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkIVExporter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkIVExporter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkIVExporter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkIVExporter.GetFileName">
            <summary>
                <para>Specify the name of the OpenInventor file to write.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIVExporter.SetFileName(System.String)">
            <summary>
                <para>Specify the name of the OpenInventor file to write.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleRubberBandZoom.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleRubberBandZoom.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleRubberBandZoom.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleRubberBandZoom.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleRubberBandZoom.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleRubberBandZoom.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleRubberBandZoom.OnLeftButtonUp">
            <summary>
                <para>Event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleRubberBandZoom.OnLeftButtonDown">
            <summary>
                <para>Event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleRubberBandZoom.OnMouseMove">
            <summary>
                <para>Event bindings</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRendererCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRendererCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRendererCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRendererCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRendererCollection.GetFirstRenderer">
            <summary>
                <para>Get the first Renderer in the list. Return NULL when at the end of the  list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererCollection.Render">
            <summary>
                <para>Forward the Render() method to each renderer in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererCollection.GetNextItem">
            <summary>
                <para>Get the next Renderer in the list. Return NULL when at the end of the  list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRendererCollection.AddItem(vtk.vtkRenderer)">
            <summary>
                <para>Add a Renderer to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImporter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImporter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImporter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImporter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImporter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImporter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLightCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLightCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLProperty.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLProperty.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLProperty.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLProperty.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLProperty.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLProperty.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLProperty.BackfaceRender(vtk.vtkActor,vtk.vtkRenderer)">
            <summary>
                <para>Implement base class method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLProperty.Render(vtk.vtkActor,vtk.vtkRenderer)">
            <summary>
                <para>Implement base class method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalPolyDataMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalPolyDataMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalPolyDataMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkHierarchicalPolyDataMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalPolyDataMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalPolyDataMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkHierarchicalPolyDataMapper.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release the underlying resources associated with this mapper  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalPolyDataMapper.GetBounds(System.Double[])">
            <summary>
                <para>Standard vtkProp method to get 3D bounds of a 3D prop</para>
            </summary>
        </member>
        <member name="M:vtk.vtkHierarchicalPolyDataMapper.Render(vtk.vtkRenderer,vtk.vtkActor)">
            <summary>
                <para>Standard method for rendering a mapper. This method will be  called by the actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageMapper.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageMapper.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLImageMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageMapper.RenderData(vtk.vtkViewport,vtk.vtkImageData,vtk.vtkActor2D)">
            <summary>
                <para>Called by the Render function in vtkImageMapper.  Actually draws the image to the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLImageMapper.RenderOverlay(vtk.vtkViewport,vtk.vtkActor2D)">
            <summary>
                <para>Called by the Render function in vtkImageMapper.  Actually draws the image to the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetCustomDisplayExtents">
            <summary>
                <para>The image extents which should be displayed with UseCustomExtents Note that the Custom extents are x,y only and the zslice is still applied</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.SetCustomDisplayExtents(System.Int32[])">
            <summary>
                <para>The image extents which should be displayed with UseCustomExtents Note that the Custom extents are x,y only and the zslice is still applied</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.UseCustomExtentsOff">
            <summary>
                <para>Usually, the entire image is displayed, if UseCustomExtents is set (by default not), then the region supplied in the CustomDisplayExtents is used in preference. Note that the Custom extents are x,y only and the zslice is still applied</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.UseCustomExtentsOn">
            <summary>
                <para>Usually, the entire image is displayed, if UseCustomExtents is set (by default not), then the region supplied in the CustomDisplayExtents is used in preference. Note that the Custom extents are x,y only and the zslice is still applied</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetUseCustomExtents">
            <summary>
                <para>Usually, the entire image is displayed, if UseCustomExtents is set (by default not), then the region supplied in the CustomDisplayExtents is used in preference. Note that the Custom extents are x,y only and the zslice is still applied</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.SetUseCustomExtents(System.Int32)">
            <summary>
                <para>Usually, the entire image is displayed, if UseCustomExtents is set (by default not), then the region supplied in the CustomDisplayExtents is used in preference. Note that the Custom extents are x,y only and the zslice is still applied</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.RenderToRectangleOff">
            <summary>
                <para>If RenderToRectangle is set (by default not), then the imagemapper will render the image into the rectangle supplied by the Actor2D's PositionCoordinate and Position2Coordinate</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.RenderToRectangleOn">
            <summary>
                <para>If RenderToRectangle is set (by default not), then the imagemapper will render the image into the rectangle supplied by the Actor2D's PositionCoordinate and Position2Coordinate</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetRenderToRectangle">
            <summary>
                <para>If RenderToRectangle is set (by default not), then the imagemapper will render the image into the rectangle supplied by the Actor2D's PositionCoordinate and Position2Coordinate</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.SetRenderToRectangle(System.Int32)">
            <summary>
                <para>If RenderToRectangle is set (by default not), then the imagemapper will render the image into the rectangle supplied by the Actor2D's PositionCoordinate and Position2Coordinate</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetInput">
            <summary>
                <para>Set the Input of a filter. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.SetInput(vtk.vtkImageData)">
            <summary>
                <para>Set the Input of a filter. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetColorScale">
            <summary>
                <para>Methods used internally for performing the Window/Level mapping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetColorShift">
            <summary>
                <para>Methods used internally for performing the Window/Level mapping.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.RenderData(vtk.vtkViewport,vtk.vtkImageData,vtk.vtkActor2D)">
            <summary>
                <para>Function called by Render to actually draw the image to to the screen</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.RenderStart(vtk.vtkViewport,vtk.vtkActor2D)">
            <summary>
                <para>Draw the image to the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetWholeZMax">
            <summary>
                <para>Set/Get the current slice number. The axis Z in ZSlice does not necessarily have any relation to the z axis of the data on disk. It is simply the axis orthogonal to the x,y, display plane. GetWholeZMax and Min are convenience methods for obtaining the number of slices that can be displayed. Again the number of slices is in reference to the display z axis, which is not necessarily the z axis on disk. (due to reformatting etc)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetWholeZMin">
            <summary>
                <para>Set/Get the current slice number. The axis Z in ZSlice does not necessarily have any relation to the z axis of the data on disk. It is simply the axis orthogonal to the x,y, display plane. GetWholeZMax and Min are convenience methods for obtaining the number of slices that can be displayed. Again the number of slices is in reference to the display z axis, which is not necessarily the z axis on disk. (due to reformatting etc)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetZSlice">
            <summary>
                <para>Set/Get the current slice number. The axis Z in ZSlice does not necessarily have any relation to the z axis of the data on disk. It is simply the axis orthogonal to the x,y, display plane. GetWholeZMax and Min are convenience methods for obtaining the number of slices that can be displayed. Again the number of slices is in reference to the display z axis, which is not necessarily the z axis on disk. (due to reformatting etc)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.SetZSlice(System.Int32)">
            <summary>
                <para>Set/Get the current slice number. The axis Z in ZSlice does not necessarily have any relation to the z axis of the data on disk. It is simply the axis orthogonal to the x,y, display plane. GetWholeZMax and Min are convenience methods for obtaining the number of slices that can be displayed. Again the number of slices is in reference to the display z axis, which is not necessarily the z axis on disk. (due to reformatting etc)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetColorLevel">
            <summary>
                <para>Set/Get the level value for window/level</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.SetColorLevel(System.Double)">
            <summary>
                <para>Set/Get the level value for window/level</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetColorWindow">
            <summary>
                <para>Set/Get the window value for window/level</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.SetColorWindow(System.Double)">
            <summary>
                <para>Set/Get the window value for window/level</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageMapper.GetMTime">
            <summary>
                <para>Override Modifiedtime as we have added a lookuptable</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.GetSortingStyleAsString">
            <summary>
                <para>Set the sorting style - none, front-to-back or back-to-front The default is none</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.SetSortingStyleToFrontToBack">
            <summary>
                <para>Set the sorting style - none, front-to-back or back-to-front The default is none</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.SetSortingStyleToBackToFront">
            <summary>
                <para>Set the sorting style - none, front-to-back or back-to-front The default is none</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.SetSortingStyleToNone">
            <summary>
                <para>Set the sorting style - none, front-to-back or back-to-front The default is none</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.GetSortingStyle">
            <summary>
                <para>Set the sorting style - none, front-to-back or back-to-front The default is none</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.GetSortingStyleMaxValue">
            <summary>
                <para>Set the sorting style - none, front-to-back or back-to-front The default is none</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.GetSortingStyleMinValue">
            <summary>
                <para>Set the sorting style - none, front-to-back or back-to-front The default is none</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.SetSortingStyle(System.Int32)">
            <summary>
                <para>Set the sorting style - none, front-to-back or back-to-front The default is none</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.GetMaximumCoverage">
            <summary>
                <para>Set/Get the maximum coverage - props with more coverage than this are given an allocated render time of 1.0 (the maximum)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.SetMaximumCoverage(System.Double)">
            <summary>
                <para>Set/Get the maximum coverage - props with more coverage than this are given an allocated render time of 1.0 (the maximum)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.GetMinimumCoverage">
            <summary>
                <para>Set/Get the minimum coverage - props with less coverage than this are given no time to render (they are culled)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFrustumCoverageCuller.SetMinimumCoverage(System.Double)">
            <summary>
                <para>Set/Get the minimum coverage - props with less coverage than this are given no time to render (they are culled)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.OnMouseWheelBackward">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.OnMouseWheelForward">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.OnRightButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.OnRightButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.OnMiddleButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.OnMiddleButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.OnLeftButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.OnLeftButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleJoystickCamera.OnMouseMove">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.ShallowCopy(vtk.vtkAbstractMapper)">
            <summary>
                <para>Make a shallow copy of this mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.MapScalars(System.Double)">
            <summary>
                <para>Map the scalars (if there are any scalars and ScalarVisibility is on) through the lookup table, returning an unsigned char RGBA array. This is typically done as part of the rendering process. The alpha parameter  allows the blending of the scalars with an additional alpha (typically which comes from a vtkActor, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetTransformCoordinate">
            <summary>
                <para>Specify a vtkCoordinate object to be used to transform the vtkPolyData point coordinates. By default (no vtkCoordinate specified), the point  coordinates are taken as local display coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetTransformCoordinate(vtk.vtkCoordinate)">
            <summary>
                <para>Specify a vtkCoordinate object to be used to transform the vtkPolyData point coordinates. By default (no vtkCoordinate specified), the point  coordinates are taken as local display coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetMTime">
            <summary>
                <para>Overload standard modified time function. If lookup table is modified, then this object is modified as well.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetArrayComponent">
            <summary>
                <para>Overload standard modified time function. If lookup table is modified, then this object is modified as well.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetArrayAccessMode">
            <summary>
                <para>Get the array name or number and component to color by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetArrayId">
            <summary>
                <para>Get the array name or number and component to color by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetArrayName">
            <summary>
                <para>Get the array name or number and component to color by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.ColorByArrayComponent(System.String,System.Int32)">
            <summary>
                <para>Choose which component of which field data array to color by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.ColorByArrayComponent(System.Int32,System.Int32)">
            <summary>
                <para>Choose which component of which field data array to color by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetScalarModeToUseCellFieldData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call ColorByArrayComponent before you call GetColors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetScalarModeToUsePointFieldData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call ColorByArrayComponent before you call GetColors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetScalarModeToUseCellData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call ColorByArrayComponent before you call GetColors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetScalarModeToUsePointData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call ColorByArrayComponent before you call GetColors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetScalarModeToDefault">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call ColorByArrayComponent before you call GetColors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetScalarMode">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call ColorByArrayComponent before you call GetColors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetScalarMode(System.Int32)">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call ColorByArrayComponent before you call GetColors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetScalarRange">
            <summary>
                <para>Specify range in terms of scalar minimum and maximum (smin,smax). These values are used to map scalars into lookup table. Has no effect when UseLookupTableScalarRange is true.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetScalarRange(System.Double[])">
            <summary>
                <para>Specify range in terms of scalar minimum and maximum (smin,smax). These values are used to map scalars into lookup table. Has no effect when UseLookupTableScalarRange is true.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetScalarRange(System.Double,System.Double)">
            <summary>
                <para>Specify range in terms of scalar minimum and maximum (smin,smax). These values are used to map scalars into lookup table. Has no effect when UseLookupTableScalarRange is true.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.UseLookupTableScalarRangeOff">
            <summary>
                <para>Control whether the mapper sets the lookuptable range based on its own ScalarRange, or whether it will use the LookupTable ScalarRange regardless of it's own setting. By default the Mapper is allowed to set the LookupTable range, but users who are sharing LookupTables between mappers/actors will probably wish to force the mapper to use the LookupTable unchanged.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.UseLookupTableScalarRangeOn">
            <summary>
                <para>Control whether the mapper sets the lookuptable range based on its own ScalarRange, or whether it will use the LookupTable ScalarRange regardless of it's own setting. By default the Mapper is allowed to set the LookupTable range, but users who are sharing LookupTables between mappers/actors will probably wish to force the mapper to use the LookupTable unchanged.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetUseLookupTableScalarRange">
            <summary>
                <para>Control whether the mapper sets the lookuptable range based on its own ScalarRange, or whether it will use the LookupTable ScalarRange regardless of it's own setting. By default the Mapper is allowed to set the LookupTable range, but users who are sharing LookupTables between mappers/actors will probably wish to force the mapper to use the LookupTable unchanged.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetUseLookupTableScalarRange(System.Int32)">
            <summary>
                <para>Control whether the mapper sets the lookuptable range based on its own ScalarRange, or whether it will use the LookupTable ScalarRange regardless of it's own setting. By default the Mapper is allowed to set the LookupTable range, but users who are sharing LookupTables between mappers/actors will probably wish to force the mapper to use the LookupTable unchanged.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetColorModeAsString">
            <summary>
                <para>Return the method of coloring scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetColorModeToMapScalars">
            <summary>
                <para>Control how the scalar data is mapped to colors.  By default (ColorModeToDefault), unsigned char scalars are treated as colors, and NOT mapped through the lookup table, while everything else is. Setting ColorModeToMapScalars means that all scalar data will be mapped through the lookup table.  (Note that for multi-component scalars, the particular component to use for mapping can be specified using the ColorByArrayComponent() method.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetColorModeToDefault">
            <summary>
                <para>Control how the scalar data is mapped to colors.  By default (ColorModeToDefault), unsigned char scalars are treated as colors, and NOT mapped through the lookup table, while everything else is. Setting ColorModeToMapScalars means that all scalar data will be mapped through the lookup table.  (Note that for multi-component scalars, the particular component to use for mapping can be specified using the ColorByArrayComponent() method.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetColorMode">
            <summary>
                <para>Control how the scalar data is mapped to colors.  By default (ColorModeToDefault), unsigned char scalars are treated as colors, and NOT mapped through the lookup table, while everything else is. Setting ColorModeToMapScalars means that all scalar data will be mapped through the lookup table.  (Note that for multi-component scalars, the particular component to use for mapping can be specified using the ColorByArrayComponent() method.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetColorMode(System.Int32)">
            <summary>
                <para>Control how the scalar data is mapped to colors.  By default (ColorModeToDefault), unsigned char scalars are treated as colors, and NOT mapped through the lookup table, while everything else is. Setting ColorModeToMapScalars means that all scalar data will be mapped through the lookup table.  (Note that for multi-component scalars, the particular component to use for mapping can be specified using the ColorByArrayComponent() method.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.ScalarVisibilityOff">
            <summary>
                <para>Turn on/off flag to control whether scalar data is used to color objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.ScalarVisibilityOn">
            <summary>
                <para>Turn on/off flag to control whether scalar data is used to color objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetScalarVisibility">
            <summary>
                <para>Turn on/off flag to control whether scalar data is used to color objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetScalarVisibility(System.Int32)">
            <summary>
                <para>Turn on/off flag to control whether scalar data is used to color objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.CreateDefaultLookupTable">
            <summary>
                <para>Create default lookup table. Generally used to create one when none is available with the scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetLookupTable">
            <summary>
                <para>Specify a lookup table for the mapper to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetLookupTable(vtk.vtkScalarsToColors)">
            <summary>
                <para>Specify a lookup table for the mapper to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.GetInput">
            <summary>
                <para>Set the input to the mapper.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataMapper2D.SetInput(vtk.vtkPolyData)">
            <summary>
                <para>Set the input to the mapper.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVolumeProperty.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetSpecularPower(System.Int32)">
            <summary>
                <para>Set/Get the specular power.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetSpecularPower(System.Double)">
            <summary>
                <para>Set/Get the specular power.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetSpecularPower(System.Int32,System.Double)">
            <summary>
                <para>Set/Get the specular power.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetSpecular">
            <summary>
                <para>Set/Get the specular power.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetSpecular(System.Int32)">
            <summary>
                <para>Set/Get the specular lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetSpecular(System.Double)">
            <summary>
                <para>Set/Get the specular lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetSpecular(System.Int32,System.Double)">
            <summary>
                <para>Set/Get the specular lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetDiffuse">
            <summary>
                <para>Set/Get the specular lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetDiffuse(System.Int32)">
            <summary>
                <para>Set/Get the diffuse lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetDiffuse(System.Double)">
            <summary>
                <para>Set/Get the diffuse lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetDiffuse(System.Int32,System.Double)">
            <summary>
                <para>Set/Get the diffuse lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetAmbient">
            <summary>
                <para>Set/Get the diffuse lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetAmbient(System.Int32)">
            <summary>
                <para>Set/Get the ambient lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetAmbient(System.Double)">
            <summary>
                <para>Set/Get the ambient lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetAmbient(System.Int32,System.Double)">
            <summary>
                <para>Set/Get the ambient lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.ShadeOff">
            <summary>
                <para>Set/Get the ambient lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.ShadeOff(System.Int32)">
            <summary>
                <para>Set/Get the shading of a volume. If shading is turned off, then the mapper for the volume will not perform shading calculations. If shading is turned on, the mapper may perform shading  calculations - in some cases shading does not apply (for example, in a maximum intensity projection) and therefore shading will not be performed even if this flag is on. For a compositing type of mapper, turning shading off is generally the same as setting ambient=1, diffuse=0, specular=0. Shading can be independently turned on/off per component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.ShadeOn">
            <summary>
                <para>Set/Get the shading of a volume. If shading is turned off, then the mapper for the volume will not perform shading calculations. If shading is turned on, the mapper may perform shading  calculations - in some cases shading does not apply (for example, in a maximum intensity projection) and therefore shading will not be performed even if this flag is on. For a compositing type of mapper, turning shading off is generally the same as setting ambient=1, diffuse=0, specular=0. Shading can be independently turned on/off per component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.ShadeOn(System.Int32)">
            <summary>
                <para>Set/Get the shading of a volume. If shading is turned off, then the mapper for the volume will not perform shading calculations. If shading is turned on, the mapper may perform shading  calculations - in some cases shading does not apply (for example, in a maximum intensity projection) and therefore shading will not be performed even if this flag is on. For a compositing type of mapper, turning shading off is generally the same as setting ambient=1, diffuse=0, specular=0. Shading can be independently turned on/off per component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetShade">
            <summary>
                <para>Set/Get the shading of a volume. If shading is turned off, then the mapper for the volume will not perform shading calculations. If shading is turned on, the mapper may perform shading  calculations - in some cases shading does not apply (for example, in a maximum intensity projection) and therefore shading will not be performed even if this flag is on. For a compositing type of mapper, turning shading off is generally the same as setting ambient=1, diffuse=0, specular=0. Shading can be independently turned on/off per component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetShade(System.Int32)">
            <summary>
                <para>Set/Get the shading of a volume. If shading is turned off, then the mapper for the volume will not perform shading calculations. If shading is turned on, the mapper may perform shading  calculations - in some cases shading does not apply (for example, in a maximum intensity projection) and therefore shading will not be performed even if this flag is on. For a compositing type of mapper, turning shading off is generally the same as setting ambient=1, diffuse=0, specular=0. Shading can be independently turned on/off per component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetShade(System.Int32)">
            <summary>
                <para>Set/Get the shading of a volume. If shading is turned off, then the mapper for the volume will not perform shading calculations. If shading is turned on, the mapper may perform shading  calculations - in some cases shading does not apply (for example, in a maximum intensity projection) and therefore shading will not be performed even if this flag is on. For a compositing type of mapper, turning shading off is generally the same as setting ambient=1, diffuse=0, specular=0. Shading can be independently turned on/off per component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetShade(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the shading of a volume. If shading is turned off, then the mapper for the volume will not perform shading calculations. If shading is turned on, the mapper may perform shading  calculations - in some cases shading does not apply (for example, in a maximum intensity projection) and therefore shading will not be performed even if this flag is on. For a compositing type of mapper, turning shading off is generally the same as setting ambient=1, diffuse=0, specular=0. Shading can be independently turned on/off per component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetStoredGradientOpacity">
            <summary>
                <para>Set/Get the shading of a volume. If shading is turned off, then the mapper for the volume will not perform shading calculations. If shading is turned on, the mapper may perform shading  calculations - in some cases shading does not apply (for example, in a maximum intensity projection) and therefore shading will not be performed even if this flag is on. For a compositing type of mapper, turning shading off is generally the same as setting ambient=1, diffuse=0, specular=0. Shading can be independently turned on/off per component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetStoredGradientOpacity(System.Int32)">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetDisableGradientOpacity">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetDisableGradientOpacity(System.Int32)">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.DisableGradientOpacityOff">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.DisableGradientOpacityOff(System.Int32)">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.DisableGradientOpacityOn">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.DisableGradientOpacityOn(System.Int32)">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetDisableGradientOpacity(System.Int32)">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetDisableGradientOpacity(System.Int32,System.Int32)">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetGradientOpacity">
            <summary>
                <para>Enable/Disable the gradient opacity function for the given component.  If set to true, any call to GetGradientOpacity() will return a default function for this component. Note that the gradient opacity function is  still stored, it is not set or reset and can be retrieved using  GetStoredGradientOpacity().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetGradientOpacity(System.Int32)">
            <summary>
                <para>Get the gradient magnitude opacity transfer function for the given component. If no transfer function has been set for this component, a default one is created and returned. This default function is always returned if DisableGradientOpacity is On for that component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetGradientOpacity(vtk.vtkPiecewiseFunction)">
            <summary>
                <para>Get the gradient magnitude opacity transfer function for the given component. If no transfer function has been set for this component, a default one is created and returned. This default function is always returned if DisableGradientOpacity is On for that component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetGradientOpacity(System.Int32,vtk.vtkPiecewiseFunction)">
            <summary>
                <para>Set the opacity of a volume to an opacity transfer function based on gradient magnitude for the given component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetScalarOpacityUnitDistance">
            <summary>
                <para>Set the opacity of a volume to an opacity transfer function based on gradient magnitude for the given component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetScalarOpacityUnitDistance(System.Int32)">
            <summary>
                <para>Set/Get the unit distance on which the scalar opacity transfer function is defined. By default this is 1.0, meaning that over a distance of 1.0 units, a given opacity (from the transfer function) is accumulated. This is adjusted for the actual sampling distance during rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetScalarOpacityUnitDistance(System.Double)">
            <summary>
                <para>Set/Get the unit distance on which the scalar opacity transfer function is defined. By default this is 1.0, meaning that over a distance of 1.0 units, a given opacity (from the transfer function) is accumulated. This is adjusted for the actual sampling distance during rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetScalarOpacityUnitDistance(System.Int32,System.Double)">
            <summary>
                <para>Set/Get the unit distance on which the scalar opacity transfer function is defined. By default this is 1.0, meaning that over a distance of 1.0 units, a given opacity (from the transfer function) is accumulated. This is adjusted for the actual sampling distance during rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetScalarOpacity">
            <summary>
                <para>Get the scalar opacity transfer function for the given component. If no transfer function has been set for this component, a default one is created and returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetScalarOpacity(System.Int32)">
            <summary>
                <para>Get the scalar opacity transfer function for the given component. If no transfer function has been set for this component, a default one is created and returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetScalarOpacity(vtk.vtkPiecewiseFunction)">
            <summary>
                <para>Set the opacity of a volume to an opacity transfer function based on scalar value for the component indicated by index. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetScalarOpacity(System.Int32,vtk.vtkPiecewiseFunction)">
            <summary>
                <para>Set the opacity of a volume to an opacity transfer function based on scalar value for the component indicated by index. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetRGBTransferFunction">
            <summary>
                <para>Get the RGB transfer function for the given component. If no transfer function has been set for this component, a default one is created and returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetRGBTransferFunction(System.Int32)">
            <summary>
                <para>Get the RGB transfer function for the given component. If no transfer function has been set for this component, a default one is created and returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetGrayTransferFunction">
            <summary>
                <para>Get the gray transfer function. If no transfer function has been set for this component, a default one is created and returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetGrayTransferFunction(System.Int32)">
            <summary>
                <para>Get the gray transfer function. If no transfer function has been set for this component, a default one is created and returned.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetColorChannels">
            <summary>
                <para>Get the number of color channels in the transfer function for the given component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetColorChannels(System.Int32)">
            <summary>
                <para>Get the number of color channels in the transfer function for the given component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetColor(vtk.vtkColorTransferFunction)">
            <summary>
                <para>Set the color of a volume to an RGB transfer function for the component indicated by index. This will set the color channels for this component to 3. This will also recompute the color channels</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetColor(System.Int32,vtk.vtkColorTransferFunction)">
            <summary>
                <para>Set the color of a volume to an RGB transfer function for the component indicated by index. This will set the color channels for this component to 3. This will also recompute the color channels</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetColor(vtk.vtkPiecewiseFunction)">
            <summary>
                <para>Set the color of a volume to a gray level transfer function for the component indicated by index. This will set the color channels for this component to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetColor(System.Int32,vtk.vtkPiecewiseFunction)">
            <summary>
                <para>Set the color of a volume to a gray level transfer function for the component indicated by index. This will set the color channels for this component to 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetInterpolationTypeAsString">
            <summary>
                <para>Set the interpolation type for sampling a volume.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetInterpolationTypeToLinear">
            <summary>
                <para>Set the interpolation type for sampling a volume.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetInterpolationTypeToNearest">
            <summary>
                <para>Set the interpolation type for sampling a volume.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetInterpolationType">
            <summary>
                <para>Set the interpolation type for sampling a volume.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetInterpolationTypeMaxValue">
            <summary>
                <para>Set the interpolation type for sampling a volume.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetInterpolationTypeMinValue">
            <summary>
                <para>Set the interpolation type for sampling a volume.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetInterpolationType(System.Int32)">
            <summary>
                <para>Set the interpolation type for sampling a volume.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetComponentWeight(System.Int32)">
            <summary>
                <para>Set/Get the scalar component weights</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetComponentWeight(System.Int32,System.Double)">
            <summary>
                <para>Set/Get the scalar component weights</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.IndependentComponentsOff">
            <summary>
                <para>Does the data have independent components, or do some define color  only? If IndependentComponents is On (the default) then each component  will be independently passed through a lookup table to determine RGBA,  shaded. Some volume Mappers can handle 1 to 4 component  unsigned char or unsigned short data (see each mapper header file to determine functionality). If IndependentComponents is Off, then you  must have either 2 or 4 component data. For 2 component data, the  first is passed through the first color transfer function and the  second component is passed through the first opacity transfer function.  Normals will be generated off of the second component. For 4 component  data, the first three will directly represent RGB (no lookup table).  The fourth component will be passed through the first scalar opacity  transfer function for opacity. Normals will be generated from the fourth  component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.IndependentComponentsOn">
            <summary>
                <para>Does the data have independent components, or do some define color  only? If IndependentComponents is On (the default) then each component  will be independently passed through a lookup table to determine RGBA,  shaded. Some volume Mappers can handle 1 to 4 component  unsigned char or unsigned short data (see each mapper header file to determine functionality). If IndependentComponents is Off, then you  must have either 2 or 4 component data. For 2 component data, the  first is passed through the first color transfer function and the  second component is passed through the first opacity transfer function.  Normals will be generated off of the second component. For 4 component  data, the first three will directly represent RGB (no lookup table).  The fourth component will be passed through the first scalar opacity  transfer function for opacity. Normals will be generated from the fourth  component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetIndependentComponents">
            <summary>
                <para>Does the data have independent components, or do some define color  only? If IndependentComponents is On (the default) then each component  will be independently passed through a lookup table to determine RGBA,  shaded. Some volume Mappers can handle 1 to 4 component  unsigned char or unsigned short data (see each mapper header file to determine functionality). If IndependentComponents is Off, then you  must have either 2 or 4 component data. For 2 component data, the  first is passed through the first color transfer function and the  second component is passed through the first opacity transfer function.  Normals will be generated off of the second component. For 4 component  data, the first three will directly represent RGB (no lookup table).  The fourth component will be passed through the first scalar opacity  transfer function for opacity. Normals will be generated from the fourth  component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetIndependentComponentsMaxValue">
            <summary>
                <para>Does the data have independent components, or do some define color  only? If IndependentComponents is On (the default) then each component  will be independently passed through a lookup table to determine RGBA,  shaded. Some volume Mappers can handle 1 to 4 component  unsigned char or unsigned short data (see each mapper header file to determine functionality). If IndependentComponents is Off, then you  must have either 2 or 4 component data. For 2 component data, the  first is passed through the first color transfer function and the  second component is passed through the first opacity transfer function.  Normals will be generated off of the second component. For 4 component  data, the first three will directly represent RGB (no lookup table).  The fourth component will be passed through the first scalar opacity  transfer function for opacity. Normals will be generated from the fourth  component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetIndependentComponentsMinValue">
            <summary>
                <para>Does the data have independent components, or do some define color  only? If IndependentComponents is On (the default) then each component  will be independently passed through a lookup table to determine RGBA,  shaded. Some volume Mappers can handle 1 to 4 component  unsigned char or unsigned short data (see each mapper header file to determine functionality). If IndependentComponents is Off, then you  must have either 2 or 4 component data. For 2 component data, the  first is passed through the first color transfer function and the  second component is passed through the first opacity transfer function.  Normals will be generated off of the second component. For 4 component  data, the first three will directly represent RGB (no lookup table).  The fourth component will be passed through the first scalar opacity  transfer function for opacity. Normals will be generated from the fourth  component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.SetIndependentComponents(System.Int32)">
            <summary>
                <para>Does the data have independent components, or do some define color  only? If IndependentComponents is On (the default) then each component  will be independently passed through a lookup table to determine RGBA,  shaded. Some volume Mappers can handle 1 to 4 component  unsigned char or unsigned short data (see each mapper header file to determine functionality). If IndependentComponents is Off, then you  must have either 2 or 4 component data. For 2 component data, the  first is passed through the first color transfer function and the  second component is passed through the first opacity transfer function.  Normals will be generated off of the second component. For 4 component  data, the first three will directly represent RGB (no lookup table).  The fourth component will be passed through the first scalar opacity  transfer function for opacity. Normals will be generated from the fourth  component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeProperty.GetMTime">
            <summary>
                <para>Get the modified time for this object (or the properties registered with this object).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTexture.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTexture.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTexture.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTexture.GetMappedScalars">
            <summary>
                <para>Get Mapped Scalars</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.GetLookupTable">
            <summary>
                <para>Specify the lookup table to convert scalars if necessary</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.SetLookupTable(vtk.vtkLookupTable)">
            <summary>
                <para>Specify the lookup table to convert scalars if necessary</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.MapColorScalarsThroughLookupTableOff">
            <summary>
                <para>Turn on/off the mapping of color scalars through the lookup table. The default is Off. If Off, unsigned char scalars will be used directly as texture. If On, scalars will be mapped through the lookup table to generate 4-component unsigned char scalars. This ivar does not affect other scalars like unsigned short, float, etc. These scalars are always mapped through lookup tables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.MapColorScalarsThroughLookupTableOn">
            <summary>
                <para>Turn on/off the mapping of color scalars through the lookup table. The default is Off. If Off, unsigned char scalars will be used directly as texture. If On, scalars will be mapped through the lookup table to generate 4-component unsigned char scalars. This ivar does not affect other scalars like unsigned short, float, etc. These scalars are always mapped through lookup tables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.SetMapColorScalarsThroughLookupTable(System.Int32)">
            <summary>
                <para>Turn on/off the mapping of color scalars through the lookup table. The default is Off. If Off, unsigned char scalars will be used directly as texture. If On, scalars will be mapped through the lookup table to generate 4-component unsigned char scalars. This ivar does not affect other scalars like unsigned short, float, etc. These scalars are always mapped through lookup tables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.GetMapColorScalarsThroughLookupTable">
            <summary>
                <para>Turn on/off the mapping of color scalars through the lookup table. The default is Off. If Off, unsigned char scalars will be used directly as texture. If On, scalars will be mapped through the lookup table to generate 4-component unsigned char scalars. This ivar does not affect other scalars like unsigned short, float, etc. These scalars are always mapped through lookup tables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.SetQualityTo32Bit">
            <summary>
                <para>Force texture quality to 16-bit or 32-bit. This might not be supported on all machines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.SetQualityTo16Bit">
            <summary>
                <para>Force texture quality to 16-bit or 32-bit. This might not be supported on all machines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.SetQualityToDefault">
            <summary>
                <para>Force texture quality to 16-bit or 32-bit. This might not be supported on all machines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.GetQuality">
            <summary>
                <para>Force texture quality to 16-bit or 32-bit. This might not be supported on all machines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.SetQuality(System.Int32)">
            <summary>
                <para>Force texture quality to 16-bit or 32-bit. This might not be supported on all machines.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.InterpolateOff">
            <summary>
                <para>Turn on/off linear interpolation of the texture map when rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.InterpolateOn">
            <summary>
                <para>Turn on/off linear interpolation of the texture map when rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.SetInterpolate(System.Int32)">
            <summary>
                <para>Turn on/off linear interpolation of the texture map when rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.GetInterpolate">
            <summary>
                <para>Turn on/off linear interpolation of the texture map when rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.RepeatOff">
            <summary>
                <para>Turn on/off the repetition of the texture map when the texture coords extend beyond the [0,1] range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.RepeatOn">
            <summary>
                <para>Turn on/off the repetition of the texture map when the texture coords extend beyond the [0,1] range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.SetRepeat(System.Int32)">
            <summary>
                <para>Turn on/off the repetition of the texture map when the texture coords extend beyond the [0,1] range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.GetRepeat">
            <summary>
                <para>Turn on/off the repetition of the texture map when the texture coords extend beyond the [0,1] range.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.Load(vtk.vtkRenderer)">
            <summary>
                <para>Abstract interface to renderer. Each concrete subclass of  vtkTexture will load its data into graphics system in response  to this method invocation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this texture. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTexture.Render(vtk.vtkRenderer)">
            <summary>
                <para>Renders a texture map. It first checks the object's modified time to make sure the texture maps Input is valid, then it invokes the  Load() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProperty.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProperty.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProperty.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProperty.FrontfaceCullingOff">
            <summary>
                <para>Turn on/off fast culling of polygons based on orientation of normal  with respect to camera. If frontface culling is on, polygons facing towards camera are not drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.FrontfaceCullingOn">
            <summary>
                <para>Turn on/off fast culling of polygons based on orientation of normal  with respect to camera. If frontface culling is on, polygons facing towards camera are not drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetFrontfaceCulling(System.Int32)">
            <summary>
                <para>Turn on/off fast culling of polygons based on orientation of normal  with respect to camera. If frontface culling is on, polygons facing towards camera are not drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetFrontfaceCulling">
            <summary>
                <para>Turn on/off fast culling of polygons based on orientation of normal  with respect to camera. If frontface culling is on, polygons facing towards camera are not drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.BackfaceCullingOff">
            <summary>
                <para>Turn on/off fast culling of polygons based on orientation of normal  with respect to camera. If backface culling is on, polygons facing away from camera are not drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.BackfaceCullingOn">
            <summary>
                <para>Turn on/off fast culling of polygons based on orientation of normal  with respect to camera. If backface culling is on, polygons facing away from camera are not drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetBackfaceCulling(System.Int32)">
            <summary>
                <para>Turn on/off fast culling of polygons based on orientation of normal  with respect to camera. If backface culling is on, polygons facing away from camera are not drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetBackfaceCulling">
            <summary>
                <para>Turn on/off fast culling of polygons based on orientation of normal  with respect to camera. If backface culling is on, polygons facing away from camera are not drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetPointSize">
            <summary>
                <para>Set/Get the diameter of a point. The size is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetPointSizeMaxValue">
            <summary>
                <para>Set/Get the diameter of a point. The size is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetPointSizeMinValue">
            <summary>
                <para>Set/Get the diameter of a point. The size is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetPointSize(System.Single)">
            <summary>
                <para>Set/Get the diameter of a point. The size is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetLineStippleRepeatFactor">
            <summary>
                <para>Set/Get the stippling repeat factor of a Line, which specifies how many times each bit in the pattern is to be repeated. This is only implemented for OpenGL. The default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetLineStippleRepeatFactorMaxValue">
            <summary>
                <para>Set/Get the stippling repeat factor of a Line, which specifies how many times each bit in the pattern is to be repeated. This is only implemented for OpenGL. The default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetLineStippleRepeatFactorMinValue">
            <summary>
                <para>Set/Get the stippling repeat factor of a Line, which specifies how many times each bit in the pattern is to be repeated. This is only implemented for OpenGL. The default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetLineStippleRepeatFactor(System.Int32)">
            <summary>
                <para>Set/Get the stippling repeat factor of a Line, which specifies how many times each bit in the pattern is to be repeated. This is only implemented for OpenGL. The default is 1.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetLineStipplePattern">
            <summary>
                <para>Set/Get the stippling pattern of a Line, as a 16-bit binary pattern  (1 = pixel on, 0 = pixel off). This is only implemented for OpenGL. The default is 0xFFFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetLineStipplePattern(System.Int32)">
            <summary>
                <para>Set/Get the stippling pattern of a Line, as a 16-bit binary pattern  (1 = pixel on, 0 = pixel off). This is only implemented for OpenGL. The default is 0xFFFF.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetLineWidth">
            <summary>
                <para>Set/Get the width of a Line. The width is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetLineWidthMaxValue">
            <summary>
                <para>Set/Get the width of a Line. The width is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetLineWidthMinValue">
            <summary>
                <para>Set/Get the width of a Line. The width is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetLineWidth(System.Single)">
            <summary>
                <para>Set/Get the width of a Line. The width is expressed in screen units. This is only implemented for OpenGL. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetEdgeColor">
            <summary>
                <para>Set/Get the color of primitive edges (if edge visibility is enabled).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetEdgeColor(System.Double[])">
            <summary>
                <para>Set/Get the color of primitive edges (if edge visibility is enabled).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetEdgeColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the color of primitive edges (if edge visibility is enabled).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.EdgeVisibilityOff">
            <summary>
                <para>Turn on/off the visibility of edges. On some renderers it is possible to render the edges of geometric primitives separately from the interior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.EdgeVisibilityOn">
            <summary>
                <para>Turn on/off the visibility of edges. On some renderers it is possible to render the edges of geometric primitives separately from the interior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetEdgeVisibility(System.Int32)">
            <summary>
                <para>Turn on/off the visibility of edges. On some renderers it is possible to render the edges of geometric primitives separately from the interior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetEdgeVisibility">
            <summary>
                <para>Turn on/off the visibility of edges. On some renderers it is possible to render the edges of geometric primitives separately from the interior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetSpecularColor">
            <summary>
                <para>Set/Get the specular surface color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetSpecularColor(System.Double[])">
            <summary>
                <para>Set/Get the specular surface color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetSpecularColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the specular surface color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetDiffuseColor">
            <summary>
                <para>Set/Get the diffuse surface color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetDiffuseColor(System.Double[])">
            <summary>
                <para>Set/Get the diffuse surface color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetDiffuseColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the diffuse surface color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetAmbientColor">
            <summary>
                <para>Set/Get the ambient surface color. Not all renderers support separate ambient and diffuse colors. From a physical standpoint it really doesn't make too much sense to have both. For the rendering libraries that don't support both, the diffuse color is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetAmbientColor(System.Double[])">
            <summary>
                <para>Set/Get the ambient surface color. Not all renderers support separate ambient and diffuse colors. From a physical standpoint it really doesn't make too much sense to have both. For the rendering libraries that don't support both, the diffuse color is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetAmbientColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the ambient surface color. Not all renderers support separate ambient and diffuse colors. From a physical standpoint it really doesn't make too much sense to have both. For the rendering libraries that don't support both, the diffuse color is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetOpacity">
            <summary>
                <para>Set/Get the object's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetOpacityMaxValue">
            <summary>
                <para>Set/Get the object's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetOpacityMinValue">
            <summary>
                <para>Set/Get the object's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetOpacity(System.Double)">
            <summary>
                <para>Set/Get the object's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetSpecularPower">
            <summary>
                <para>Set/Get the specular power.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetSpecularPowerMaxValue">
            <summary>
                <para>Set/Get the specular power.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetSpecularPowerMinValue">
            <summary>
                <para>Set/Get the specular power.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetSpecularPower(System.Double)">
            <summary>
                <para>Set/Get the specular power.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetSpecular">
            <summary>
                <para>Set/Get the specular lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetSpecularMaxValue">
            <summary>
                <para>Set/Get the specular lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetSpecularMinValue">
            <summary>
                <para>Set/Get the specular lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetSpecular(System.Double)">
            <summary>
                <para>Set/Get the specular lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetDiffuse">
            <summary>
                <para>Set/Get the diffuse lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetDiffuseMaxValue">
            <summary>
                <para>Set/Get the diffuse lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetDiffuseMinValue">
            <summary>
                <para>Set/Get the diffuse lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetDiffuse(System.Double)">
            <summary>
                <para>Set/Get the diffuse lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetAmbient">
            <summary>
                <para>Set/Get the ambient lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetAmbientMaxValue">
            <summary>
                <para>Set/Get the ambient lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetAmbientMinValue">
            <summary>
                <para>Set/Get the ambient lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetAmbient(System.Double)">
            <summary>
                <para>Set/Get the ambient lighting coefficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetColor(System.Double[])">
            <summary>
                <para>Set the color of the object. Has the side effect of setting the ambient diffuse and specular colors as well. This is basically a quick overall color setting method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetColor">
            <summary>
                <para>Set the color of the object. Has the side effect of setting the ambient diffuse and specular colors as well. This is basically a quick overall color setting method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetColor(System.Double[])">
            <summary>
                <para>Set the color of the object. Has the side effect of setting the ambient diffuse and specular colors as well. This is basically a quick overall color setting method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the color of the object. Has the side effect of setting the ambient diffuse and specular colors as well. This is basically a quick overall color setting method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetRepresentationAsString">
            <summary>
                <para>Control the surface geometry representation for the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetRepresentationToSurface">
            <summary>
                <para>Control the surface geometry representation for the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetRepresentationToWireframe">
            <summary>
                <para>Control the surface geometry representation for the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetRepresentationToPoints">
            <summary>
                <para>Control the surface geometry representation for the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetRepresentation">
            <summary>
                <para>Control the surface geometry representation for the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetRepresentationMaxValue">
            <summary>
                <para>Control the surface geometry representation for the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetRepresentationMinValue">
            <summary>
                <para>Control the surface geometry representation for the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetRepresentation(System.Int32)">
            <summary>
                <para>Control the surface geometry representation for the object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetInterpolationAsString">
            <summary>
                <para>Set the shading interpolation method for an object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetInterpolationToPhong">
            <summary>
                <para>Set the shading interpolation method for an object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetInterpolationToGouraud">
            <summary>
                <para>Set the shading interpolation method for an object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetInterpolationToFlat">
            <summary>
                <para>Set the shading interpolation method for an object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetInterpolation">
            <summary>
                <para>Set the shading interpolation method for an object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetInterpolationMaxValue">
            <summary>
                <para>Set the shading interpolation method for an object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.GetInterpolationMinValue">
            <summary>
                <para>Set the shading interpolation method for an object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.SetInterpolation(System.Int32)">
            <summary>
                <para>Set the shading interpolation method for an object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.BackfaceRender(vtk.vtkActor,vtk.vtkRenderer)">
            <summary>
                <para>This method renders the property as a backface property. TwoSidedLighting must be turned off to see any backface properties. Note that only colors and opacity are used for backface properties. Other properties such as Representation, Culling are specified by the Property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.Render(vtk.vtkActor,vtk.vtkRenderer)">
            <summary>
                <para>This method causes the property to set up whatever is required for its instance variables. This is actually handled by a subclass of vtkProperty, which is created automatically. This method includes the invoking actor as an argument which can be used by property devices that require the actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProperty.DeepCopy(vtk.vtkProperty)">
            <summary>
                <para>Assign one property to another. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkMapper.GetScalarMaterialModeAsString">
            <summary>
                <para>Return the light-model color mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarMaterialModeToAmbientAndDiffuse">
            <summary>
                <para>Set/Get the light-model color mode. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarMaterialModeToDiffuse">
            <summary>
                <para>Set/Get the light-model color mode. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarMaterialModeToAmbient">
            <summary>
                <para>Set/Get the light-model color mode. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarMaterialModeToDefault">
            <summary>
                <para>Set/Get the light-model color mode. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetScalarMaterialMode">
            <summary>
                <para>Set/Get the light-model color mode. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarMaterialMode(System.Int32)">
            <summary>
                <para>Set/Get the light-model color mode. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.MapScalars(System.Double)">
            <summary>
                <para>Map the scalars (if there are any scalars and ScalarVisibility is on) through the lookup table, returning an unsigned char RGBA array. This is typically done as part of the rendering process. The alpha parameter  allows the blending of the scalars with an additional alpha (typically which comes from a vtkActor, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetInputAsDataSet">
            <summary>
                <para>Map the scalars (if there are any scalars and ScalarVisibility is on) through the lookup table, returning an unsigned char RGBA array. This is typically done as part of the rendering process. The alpha parameter  allows the blending of the scalars with an additional alpha (typically which comes from a vtkActor, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetRenderTime">
            <summary>
                <para>This instance variable is used by vtkLODActor to determine which mapper to use.  It is an estimate of the time necessary to render. Setting the render time does not modify the mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetRenderTime(System.Double)">
            <summary>
                <para>This instance variable is used by vtkLODActor to determine which mapper to use.  It is an estimate of the time necessary to render. Setting the render time does not modify the mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetBounds(System.Double[])">
            <summary>
                <para>Return bounding box (array of six doubles) of data expressed as (xmin,xmax, ymin,ymax, zmin,zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetBounds">
            <summary>
                <para>Return bounding box (array of six doubles) of data expressed as (xmin,xmax, ymin,ymax, zmin,zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetResolveCoincidentTopologyZShift">
            <summary>
                <para>Used to set the z-shift if ResolveCoincidentTopology is set to ShiftZBuffer. This is a global variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetResolveCoincidentTopologyZShift(System.Double)">
            <summary>
                <para>Used to set the z-shift if ResolveCoincidentTopology is set to ShiftZBuffer. This is a global variable.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetResolveCoincidentTopologyPolygonOffsetParameters(System.Double@,System.Double@)">
            <summary>
                <para>Used to set the polygon offset scale factor and units. Used when ResolveCoincidentTopology is set to PolygonOffset.  These are global variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetResolveCoincidentTopologyPolygonOffsetParameters(System.Double,System.Double)">
            <summary>
                <para>Used to set the polygon offset scale factor and units. Used when ResolveCoincidentTopology is set to PolygonOffset.  These are global variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetResolveCoincidentTopologyToShiftZBuffer">
            <summary>
                <para>Used to set the polygon offset scale factor and units. Used when ResolveCoincidentTopology is set to PolygonOffset.  These are global variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetResolveCoincidentTopologyToPolygonOffset">
            <summary>
                <para>Set/Get a global flag that controls whether coincident topology (e.g., a line on top of a polygon) is shifted to avoid z-buffer resolution (and hence rendering problems). If not off, there are two methods to choose from. PolygonOffset uses graphics systems calls to shift polygons, but does not distinguish vertices and lines from one another. ShiftZBuffer remaps the z-buffer to distinguish vertices, lines, and polygons, but does not always produce acceptable results. If you use the ShiftZBuffer approach, you may also want to set the ResolveCoincidentTopologyZShift value. (Note: not all mappers/graphics systems implement this  functionality.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetResolveCoincidentTopologyToOff">
            <summary>
                <para>Set/Get a global flag that controls whether coincident topology (e.g., a line on top of a polygon) is shifted to avoid z-buffer resolution (and hence rendering problems). If not off, there are two methods to choose from. PolygonOffset uses graphics systems calls to shift polygons, but does not distinguish vertices and lines from one another. ShiftZBuffer remaps the z-buffer to distinguish vertices, lines, and polygons, but does not always produce acceptable results. If you use the ShiftZBuffer approach, you may also want to set the ResolveCoincidentTopologyZShift value. (Note: not all mappers/graphics systems implement this  functionality.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetResolveCoincidentTopologyToDefault">
            <summary>
                <para>Set/Get a global flag that controls whether coincident topology (e.g., a line on top of a polygon) is shifted to avoid z-buffer resolution (and hence rendering problems). If not off, there are two methods to choose from. PolygonOffset uses graphics systems calls to shift polygons, but does not distinguish vertices and lines from one another. ShiftZBuffer remaps the z-buffer to distinguish vertices, lines, and polygons, but does not always produce acceptable results. If you use the ShiftZBuffer approach, you may also want to set the ResolveCoincidentTopologyZShift value. (Note: not all mappers/graphics systems implement this  functionality.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetResolveCoincidentTopology">
            <summary>
                <para>Set/Get a global flag that controls whether coincident topology (e.g., a line on top of a polygon) is shifted to avoid z-buffer resolution (and hence rendering problems). If not off, there are two methods to choose from. PolygonOffset uses graphics systems calls to shift polygons, but does not distinguish vertices and lines from one another. ShiftZBuffer remaps the z-buffer to distinguish vertices, lines, and polygons, but does not always produce acceptable results. If you use the ShiftZBuffer approach, you may also want to set the ResolveCoincidentTopologyZShift value. (Note: not all mappers/graphics systems implement this  functionality.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetResolveCoincidentTopology(System.Int32)">
            <summary>
                <para>Set/Get a global flag that controls whether coincident topology (e.g., a line on top of a polygon) is shifted to avoid z-buffer resolution (and hence rendering problems). If not off, there are two methods to choose from. PolygonOffset uses graphics systems calls to shift polygons, but does not distinguish vertices and lines from one another. ShiftZBuffer remaps the z-buffer to distinguish vertices, lines, and polygons, but does not always produce acceptable results. If you use the ShiftZBuffer approach, you may also want to set the ResolveCoincidentTopologyZShift value. (Note: not all mappers/graphics systems implement this  functionality.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetScalarModeAsString">
            <summary>
                <para>Return the method for obtaining scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetArrayComponent">
            <summary>
                <para>Return the method for obtaining scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetArrayAccessMode">
            <summary>
                <para>Get the array name or number and component to color by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetArrayId">
            <summary>
                <para>Get the array name or number and component to color by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetArrayName">
            <summary>
                <para>Get the array name or number and component to color by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.ColorByArrayComponent(System.String,System.Int32)">
            <summary>
                <para>Legacy: These methods used to be used to specify the array component. It is better to do this in the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.ColorByArrayComponent(System.Int32,System.Int32)">
            <summary>
                <para>Legacy: These methods used to be used to specify the array component. It is better to do this in the lookup table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SelectColorArray(System.String)">
            <summary>
                <para>When ScalarMode is set to UsePointFileData or UseCellFieldData, you can specify which array to use for coloring using these methods. The lookup table will decide how to convert vectors to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SelectColorArray(System.Int32)">
            <summary>
                <para>When ScalarMode is set to UsePointFileData or UseCellFieldData, you can specify which array to use for coloring using these methods. The lookup table will decide how to convert vectors to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarModeToUseFieldData">
            <summary>
                <para>When ScalarMode is set to UsePointFileData or UseCellFieldData, you can specify which array to use for coloring using these methods. The lookup table will decide how to convert vectors to colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarModeToUseCellFieldData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call SelectColorArray before you call GetColors. When ScalarMode is set to use Field Data (ScalarModeToFieldData), you  must call SelectColorArray to choose the field data array to be used to color cells. In this mode, if the poly data has triangle strips,  the field data is treated as the celldata for each mini-cell formed by a triangle in the strip rather than the entire strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarModeToUsePointFieldData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call SelectColorArray before you call GetColors. When ScalarMode is set to use Field Data (ScalarModeToFieldData), you  must call SelectColorArray to choose the field data array to be used to color cells. In this mode, if the poly data has triangle strips,  the field data is treated as the celldata for each mini-cell formed by a triangle in the strip rather than the entire strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarModeToUseCellData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call SelectColorArray before you call GetColors. When ScalarMode is set to use Field Data (ScalarModeToFieldData), you  must call SelectColorArray to choose the field data array to be used to color cells. In this mode, if the poly data has triangle strips,  the field data is treated as the celldata for each mini-cell formed by a triangle in the strip rather than the entire strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarModeToUsePointData">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call SelectColorArray before you call GetColors. When ScalarMode is set to use Field Data (ScalarModeToFieldData), you  must call SelectColorArray to choose the field data array to be used to color cells. In this mode, if the poly data has triangle strips,  the field data is treated as the celldata for each mini-cell formed by a triangle in the strip rather than the entire strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarModeToDefault">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call SelectColorArray before you call GetColors. When ScalarMode is set to use Field Data (ScalarModeToFieldData), you  must call SelectColorArray to choose the field data array to be used to color cells. In this mode, if the poly data has triangle strips,  the field data is treated as the celldata for each mini-cell formed by a triangle in the strip rather than the entire strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetScalarMode">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call SelectColorArray before you call GetColors. When ScalarMode is set to use Field Data (ScalarModeToFieldData), you  must call SelectColorArray to choose the field data array to be used to color cells. In this mode, if the poly data has triangle strips,  the field data is treated as the celldata for each mini-cell formed by a triangle in the strip rather than the entire strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarMode(System.Int32)">
            <summary>
                <para>Control how the filter works with scalar point data and cell attribute data.  By default (ScalarModeToDefault), the filter will use point data, and if no point data is available, then cell data is used. Alternatively you can explicitly set the filter to use point data (ScalarModeToUsePointData) or cell data (ScalarModeToUseCellData). You can also choose to get the scalars from an array in point field data (ScalarModeToUsePointFieldData) or cell field data (ScalarModeToUseCellFieldData).  If scalars are coming from a field data array, you must call SelectColorArray before you call GetColors. When ScalarMode is set to use Field Data (ScalarModeToFieldData), you  must call SelectColorArray to choose the field data array to be used to color cells. In this mode, if the poly data has triangle strips,  the field data is treated as the celldata for each mini-cell formed by a triangle in the strip rather than the entire strip.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetGlobalImmediateModeRendering">
            <summary>
                <para>Turn on/off flag to control whether data is rendered using immediate mode or note. Immediate mode rendering tends to be slower but it can handle larger datasets. The default value is immediate mode off. If you are  having problems rendering a large dataset you might want to consider using immediate more rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GlobalImmediateModeRenderingOff">
            <summary>
                <para>Turn on/off flag to control whether data is rendered using immediate mode or note. Immediate mode rendering tends to be slower but it can handle larger datasets. The default value is immediate mode off. If you are  having problems rendering a large dataset you might want to consider using immediate more rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GlobalImmediateModeRenderingOn">
            <summary>
                <para>Turn on/off flag to control whether data is rendered using immediate mode or note. Immediate mode rendering tends to be slower but it can handle larger datasets. The default value is immediate mode off. If you are  having problems rendering a large dataset you might want to consider using immediate more rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetGlobalImmediateModeRendering(System.Int32)">
            <summary>
                <para>Turn on/off flag to control whether data is rendered using immediate mode or note. Immediate mode rendering tends to be slower but it can handle larger datasets. The default value is immediate mode off. If you are  having problems rendering a large dataset you might want to consider using immediate more rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.ImmediateModeRenderingOff">
            <summary>
                <para>Turn on/off flag to control whether data is rendered using immediate mode or note. Immediate mode rendering tends to be slower but it can handle larger datasets. The default value is immediate mode off. If you are having problems rendering a large dataset you might want to consider using immediate more rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.ImmediateModeRenderingOn">
            <summary>
                <para>Turn on/off flag to control whether data is rendered using immediate mode or note. Immediate mode rendering tends to be slower but it can handle larger datasets. The default value is immediate mode off. If you are having problems rendering a large dataset you might want to consider using immediate more rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetImmediateModeRendering">
            <summary>
                <para>Turn on/off flag to control whether data is rendered using immediate mode or note. Immediate mode rendering tends to be slower but it can handle larger datasets. The default value is immediate mode off. If you are having problems rendering a large dataset you might want to consider using immediate more rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetImmediateModeRendering(System.Int32)">
            <summary>
                <para>Turn on/off flag to control whether data is rendered using immediate mode or note. Immediate mode rendering tends to be slower but it can handle larger datasets. The default value is immediate mode off. If you are having problems rendering a large dataset you might want to consider using immediate more rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetScalarRange">
            <summary>
                <para>Specify range in terms of scalar minimum and maximum (smin,smax). These values are used to map scalars into lookup table. Has no effect when UseLookupTableScalarRange is true.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarRange(System.Double[])">
            <summary>
                <para>Specify range in terms of scalar minimum and maximum (smin,smax). These values are used to map scalars into lookup table. Has no effect when UseLookupTableScalarRange is true.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarRange(System.Double,System.Double)">
            <summary>
                <para>Specify range in terms of scalar minimum and maximum (smin,smax). These values are used to map scalars into lookup table. Has no effect when UseLookupTableScalarRange is true.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.UseLookupTableScalarRangeOff">
            <summary>
                <para>Control whether the mapper sets the lookuptable range based on its own ScalarRange, or whether it will use the LookupTable ScalarRange regardless of it's own setting. By default the Mapper is allowed to set the LookupTable range, but users who are sharing LookupTables between mappers/actors will probably wish to force the mapper to use the LookupTable unchanged.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.UseLookupTableScalarRangeOn">
            <summary>
                <para>Control whether the mapper sets the lookuptable range based on its own ScalarRange, or whether it will use the LookupTable ScalarRange regardless of it's own setting. By default the Mapper is allowed to set the LookupTable range, but users who are sharing LookupTables between mappers/actors will probably wish to force the mapper to use the LookupTable unchanged.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetUseLookupTableScalarRange">
            <summary>
                <para>Control whether the mapper sets the lookuptable range based on its own ScalarRange, or whether it will use the LookupTable ScalarRange regardless of it's own setting. By default the Mapper is allowed to set the LookupTable range, but users who are sharing LookupTables between mappers/actors will probably wish to force the mapper to use the LookupTable unchanged.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetUseLookupTableScalarRange(System.Int32)">
            <summary>
                <para>Control whether the mapper sets the lookuptable range based on its own ScalarRange, or whether it will use the LookupTable ScalarRange regardless of it's own setting. By default the Mapper is allowed to set the LookupTable range, but users who are sharing LookupTables between mappers/actors will probably wish to force the mapper to use the LookupTable unchanged.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.InterpolateScalarsBeforeMappingOff">
            <summary>
                <para>By default, vertex color is used to map colors to a surface. Colors are interpolated after being mapped. This option avoids color interpolation by using a one dimensional texture map for the colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.InterpolateScalarsBeforeMappingOn">
            <summary>
                <para>By default, vertex color is used to map colors to a surface. Colors are interpolated after being mapped. This option avoids color interpolation by using a one dimensional texture map for the colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetInterpolateScalarsBeforeMapping">
            <summary>
                <para>By default, vertex color is used to map colors to a surface. Colors are interpolated after being mapped. This option avoids color interpolation by using a one dimensional texture map for the colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetInterpolateScalarsBeforeMapping(System.Int32)">
            <summary>
                <para>By default, vertex color is used to map colors to a surface. Colors are interpolated after being mapped. This option avoids color interpolation by using a one dimensional texture map for the colors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetColorModeAsString">
            <summary>
                <para>Return the method of coloring scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetColorModeToMapScalars">
            <summary>
                <para>Control how the scalar data is mapped to colors.  By default (ColorModeToDefault), unsigned char scalars are treated as colors, and NOT mapped through the lookup table, while everything else is. Setting ColorModeToMapScalars means that all scalar data will be mapped through the lookup table.  (Note that for multi-component scalars, the particular component to use for mapping can be specified using the SelectColorArray() method.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetColorModeToDefault">
            <summary>
                <para>Control how the scalar data is mapped to colors.  By default (ColorModeToDefault), unsigned char scalars are treated as colors, and NOT mapped through the lookup table, while everything else is. Setting ColorModeToMapScalars means that all scalar data will be mapped through the lookup table.  (Note that for multi-component scalars, the particular component to use for mapping can be specified using the SelectColorArray() method.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetColorMode">
            <summary>
                <para>Control how the scalar data is mapped to colors.  By default (ColorModeToDefault), unsigned char scalars are treated as colors, and NOT mapped through the lookup table, while everything else is. Setting ColorModeToMapScalars means that all scalar data will be mapped through the lookup table.  (Note that for multi-component scalars, the particular component to use for mapping can be specified using the SelectColorArray() method.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetColorMode(System.Int32)">
            <summary>
                <para>Control how the scalar data is mapped to colors.  By default (ColorModeToDefault), unsigned char scalars are treated as colors, and NOT mapped through the lookup table, while everything else is. Setting ColorModeToMapScalars means that all scalar data will be mapped through the lookup table.  (Note that for multi-component scalars, the particular component to use for mapping can be specified using the SelectColorArray() method.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.StaticOff">
            <summary>
                <para>Turn on/off flag to control whether the mapper's data is static. Static data means that the mapper does not propagate updates down the pipeline, greatly decreasing the time it takes to update many mappers. This should only be used if the data never changes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.StaticOn">
            <summary>
                <para>Turn on/off flag to control whether the mapper's data is static. Static data means that the mapper does not propagate updates down the pipeline, greatly decreasing the time it takes to update many mappers. This should only be used if the data never changes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetStatic">
            <summary>
                <para>Turn on/off flag to control whether the mapper's data is static. Static data means that the mapper does not propagate updates down the pipeline, greatly decreasing the time it takes to update many mappers. This should only be used if the data never changes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetStatic(System.Int32)">
            <summary>
                <para>Turn on/off flag to control whether the mapper's data is static. Static data means that the mapper does not propagate updates down the pipeline, greatly decreasing the time it takes to update many mappers. This should only be used if the data never changes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.ScalarVisibilityOff">
            <summary>
                <para>Turn on/off flag to control whether scalar data is used to color objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.ScalarVisibilityOn">
            <summary>
                <para>Turn on/off flag to control whether scalar data is used to color objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetScalarVisibility">
            <summary>
                <para>Turn on/off flag to control whether scalar data is used to color objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetScalarVisibility(System.Int32)">
            <summary>
                <para>Turn on/off flag to control whether scalar data is used to color objects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.CreateDefaultLookupTable">
            <summary>
                <para>Create default lookup table. Generally used to create one when none is available with the scalar data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetLookupTable">
            <summary>
                <para>Specify a lookup table for the mapper to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.SetLookupTable(vtk.vtkScalarsToColors)">
            <summary>
                <para>Specify a lookup table for the mapper to use.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this mapper. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.Render(vtk.vtkRenderer,vtk.vtkActor)">
            <summary>
                <para>Method initiates the mapping process. Generally sent by the actor  as each frame is rendered.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.GetMTime">
            <summary>
                <para>Overload standard modified time function. If lookup table is modified, then this object is modified as well.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkMapper.ShallowCopy(vtk.vtkAbstractMapper)">
            <summary>
                <para>Make a shallow copy of this mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractVolumeMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAbstractVolumeMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAbstractVolumeMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractVolumeMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractVolumeMapper.GetBounds(System.Double[])">
            <summary>
                <para>Return bounding box (array of six doubles) of data expressed as (xmin,xmax, ymin,ymax, zmin,zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractVolumeMapper.GetDataSetInput">
            <summary>
                <para>Set/Get the input data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractVolumeMapper.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Set/Get the input data</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLODProp3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this vtkLODProp3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AutomaticPickLODSelectionOff">
            <summary>
                <para>Turn on / off automatic selection of picking LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AutomaticPickLODSelectionOn">
            <summary>
                <para>Turn on / off automatic selection of picking LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetAutomaticPickLODSelection">
            <summary>
                <para>Turn on / off automatic selection of picking LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetAutomaticPickLODSelectionMaxValue">
            <summary>
                <para>Turn on / off automatic selection of picking LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetAutomaticPickLODSelectionMinValue">
            <summary>
                <para>Turn on / off automatic selection of picking LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetAutomaticPickLODSelection(System.Int32)">
            <summary>
                <para>Turn on / off automatic selection of picking LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetSelectedPickLODID">
            <summary>
                <para>Set the id of the LOD that is to be used for picking when  automatic  LOD pick selection is turned off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetSelectedPickLODID(System.Int32)">
            <summary>
                <para>Set the id of the LOD that is to be used for picking when  automatic  LOD pick selection is turned off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetActors(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetPickLODID">
            <summary>
                <para>Get the ID of the appropriate pick LOD index</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetLastRenderedLODID">
            <summary>
                <para>Get the ID of the previously (during the last render) selected LOD index</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetSelectedLODID">
            <summary>
                <para>Set the id of the LOD that is to be drawn when automatic LOD selection is turned off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetSelectedLODID(System.Int32)">
            <summary>
                <para>Set the id of the LOD that is to be drawn when automatic LOD selection is turned off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AutomaticLODSelectionOff">
            <summary>
                <para>Turn on / off automatic selection of LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AutomaticLODSelectionOn">
            <summary>
                <para>Turn on / off automatic selection of LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetAutomaticLODSelection">
            <summary>
                <para>Turn on / off automatic selection of LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetAutomaticLODSelectionMaxValue">
            <summary>
                <para>Turn on / off automatic selection of LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetAutomaticLODSelectionMinValue">
            <summary>
                <para>Turn on / off automatic selection of LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetAutomaticLODSelection(System.Int32)">
            <summary>
                <para>Turn on / off automatic selection of LOD.  This is on by default. If it is off, then the SelectedLODID is  rendered regardless of rendering time or desired update rate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetLODIndexEstimatedRenderTime(System.Int32)">
            <summary>
                <para>Access method that can be used to find out the estimated render time (the thing used to select an LOD) for a given LOD ID or index.  Value is returned in seconds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetLODEstimatedRenderTime(System.Int32)">
            <summary>
                <para>Access method that can be used to find out the estimated render time (the thing used to select an LOD) for a given LOD ID or index.  Value is returned in seconds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetLODIndexLevel(System.Int32)">
            <summary>
                <para>Set the level of a particular LOD. When a LOD is selected for rendering because it has the largest render time that fits within the allocated time, all LOD are then checked to see if any one can render faster but has a lower (more resolution/better) level. This quantity is a double to ensure that a level can be inserted  between 2 and 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetLODLevel(System.Int32)">
            <summary>
                <para>Set the level of a particular LOD. When a LOD is selected for rendering because it has the largest render time that fits within the allocated time, all LOD are then checked to see if any one can render faster but has a lower (more resolution/better) level. This quantity is a double to ensure that a level can be inserted  between 2 and 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetLODLevel(System.Int32,System.Double)">
            <summary>
                <para>Set the level of a particular LOD. When a LOD is selected for rendering because it has the largest render time that fits within the allocated time, all LOD are then checked to see if any one can render faster but has a lower (more resolution/better) level. This quantity is a double to ensure that a level can be inserted  between 2 and 3.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.IsLODEnabled(System.Int32)">
            <summary>
                <para>Enable / disable a particular LOD. If it is disabled, it will not be used during automatic selection, but can be selected as the LOD if automatic LOD selection is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.DisableLOD(System.Int32)">
            <summary>
                <para>Enable / disable a particular LOD. If it is disabled, it will not be used during automatic selection, but can be selected as the LOD if automatic LOD selection is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.EnableLOD(System.Int32)">
            <summary>
                <para>Enable / disable a particular LOD. If it is disabled, it will not be used during automatic selection, but can be selected as the LOD if automatic LOD selection is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetLODTexture(System.Int32,vtk.vtkTexture)">
            <summary>
                <para>Methods to set / get the texture of an LOD. This method is only valid for LOD ids that are Actors (not Volumes)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetLODBackfaceProperty(System.Int32,vtk.vtkProperty)">
            <summary>
                <para>Methods to set / get the backface property of an LOD. This method is only valid for LOD ids that are Actors (not Volumes)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetLODMapper(System.Int32)">
            <summary>
                <para>Get the LODMapper as an vtkAbstractMapper3D.  It is the user's respondibility to safe down cast this to a vtkMapper or vtkVolumeMapper as appropriate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetLODMapper(System.Int32,vtk.vtkAbstractVolumeMapper)">
            <summary>
                <para>Methods to set / get the mapper of an LOD. Since the LOD could be a volume or an actor, you have to pass in the pointer to the mapper to get it. The returned mapper will be NULL if the id is not valid, or the mapper is of the wrong type for the corresponding Prop3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetLODMapper(System.Int32,vtk.vtkMapper)">
            <summary>
                <para>Methods to set / get the mapper of an LOD. Since the LOD could be a volume or an actor, you have to pass in the pointer to the mapper to get it. The returned mapper will be NULL if the id is not valid, or the mapper is of the wrong type for the corresponding Prop3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetLODProperty(System.Int32,vtk.vtkVolumeProperty)">
            <summary>
                <para>Methods to set / get the property of an LOD. Since the LOD could be a volume or an actor, you have to pass in the pointer to the property to get it. The returned property will be NULL if the id is not valid, or the property is of the wrong type for the corresponding Prop3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.SetLODProperty(System.Int32,vtk.vtkProperty)">
            <summary>
                <para>Methods to set / get the property of an LOD. Since the LOD could be a volume or an actor, you have to pass in the pointer to the property to get it. The returned property will be NULL if the id is not valid, or the property is of the wrong type for the corresponding Prop3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.RemoveLOD(System.Int32)">
            <summary>
                <para>Delete a level of detail given an ID. This is the ID returned by the AddLOD method</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetCurrentIndex">
            <summary>
                <para>Get the current index, used to determine the ID of the next LOD that is added.  Useful for guessing what IDs have been used (with NumberOfLODs, without depending on the constructor initialization to 1000.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetNumberOfLODs">
            <summary>
                <para>Get the current number of LODs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AddLOD(vtk.vtkAbstractVolumeMapper,System.Double)">
            <summary>
                <para>Add a level of detail with a given mapper, property, backface property, texture, and guess of rendering time.  The property and texture fields can be set to NULL (the other methods are included for script access where null variables are not allowed). The time field can be set to 0.0 indicating that no initial guess for rendering time is being supplied. The returned integer value is an ID that can be used later to delete this LOD, or set it as the selected LOD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AddLOD(vtk.vtkAbstractVolumeMapper,vtk.vtkVolumeProperty,System.Double)">
            <summary>
                <para>Add a level of detail with a given mapper, property, backface property, texture, and guess of rendering time.  The property and texture fields can be set to NULL (the other methods are included for script access where null variables are not allowed). The time field can be set to 0.0 indicating that no initial guess for rendering time is being supplied. The returned integer value is an ID that can be used later to delete this LOD, or set it as the selected LOD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AddLOD(vtk.vtkMapper,System.Double)">
            <summary>
                <para>Add a level of detail with a given mapper, property, backface property, texture, and guess of rendering time.  The property and texture fields can be set to NULL (the other methods are included for script access where null variables are not allowed). The time field can be set to 0.0 indicating that no initial guess for rendering time is being supplied. The returned integer value is an ID that can be used later to delete this LOD, or set it as the selected LOD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AddLOD(vtk.vtkMapper,vtk.vtkTexture,System.Double)">
            <summary>
                <para>Add a level of detail with a given mapper, property, backface property, texture, and guess of rendering time.  The property and texture fields can be set to NULL (the other methods are included for script access where null variables are not allowed). The time field can be set to 0.0 indicating that no initial guess for rendering time is being supplied. The returned integer value is an ID that can be used later to delete this LOD, or set it as the selected LOD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AddLOD(vtk.vtkMapper,vtk.vtkProperty,System.Double)">
            <summary>
                <para>Add a level of detail with a given mapper, property, backface property, texture, and guess of rendering time.  The property and texture fields can be set to NULL (the other methods are included for script access where null variables are not allowed). The time field can be set to 0.0 indicating that no initial guess for rendering time is being supplied. The returned integer value is an ID that can be used later to delete this LOD, or set it as the selected LOD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AddLOD(vtk.vtkMapper,vtk.vtkProperty,vtk.vtkProperty,System.Double)">
            <summary>
                <para>Add a level of detail with a given mapper, property, backface property, texture, and guess of rendering time.  The property and texture fields can be set to NULL (the other methods are included for script access where null variables are not allowed). The time field can be set to 0.0 indicating that no initial guess for rendering time is being supplied. The returned integer value is an ID that can be used later to delete this LOD, or set it as the selected LOD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AddLOD(vtk.vtkMapper,vtk.vtkProperty,vtk.vtkTexture,System.Double)">
            <summary>
                <para>Add a level of detail with a given mapper, property, backface property, texture, and guess of rendering time.  The property and texture fields can be set to NULL (the other methods are included for script access where null variables are not allowed). The time field can be set to 0.0 indicating that no initial guess for rendering time is being supplied. The returned integer value is an ID that can be used later to delete this LOD, or set it as the selected LOD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.AddLOD(vtk.vtkMapper,vtk.vtkProperty,vtk.vtkProperty,vtk.vtkTexture,System.Double)">
            <summary>
                <para>Add a level of detail with a given mapper, property, backface property, texture, and guess of rendering time.  The property and texture fields can be set to NULL (the other methods are included for script access where null variables are not allowed). The time field can be set to 0.0 indicating that no initial guess for rendering time is being supplied. The returned integer value is an ID that can be used later to delete this LOD, or set it as the selected LOD.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetBounds(System.Double[])">
            <summary>
                <para>Standard vtkProp method to get 3D bounds of a 3D prop</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLODProp3D.GetBounds">
            <summary>
                <para>Standard vtkProp method to get 3D bounds of a 3D prop</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.GetShouldRerender">
            <summary>
                <para>Set/get whether to re-render the input window. (This option makes no difference if Magnification &gt; 1.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.SetShouldRerender(System.Int32)">
            <summary>
                <para>Set/get whether to re-render the input window. (This option makes no difference if Magnification &gt; 1.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.ShouldRerenderOff">
            <summary>
                <para>Set/get whether to re-render the input window. (This option makes no difference if Magnification &gt; 1.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.ShouldRerenderOn">
            <summary>
                <para>Set/get whether to re-render the input window. (This option makes no difference if Magnification &gt; 1.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.SetReadFrontBuffer(System.Int32)">
            <summary>
                <para>Set/Get the flag that determines which buffer to read from. The default is to read from the front buffer.   </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.GetReadFrontBuffer">
            <summary>
                <para>Set/Get the flag that determines which buffer to read from. The default is to read from the front buffer.   </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.ReadFrontBufferOff">
            <summary>
                <para>Set/Get the flag that determines which buffer to read from. The default is to read from the front buffer.   </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.ReadFrontBufferOn">
            <summary>
                <para>Set/Get the flag that determines which buffer to read from. The default is to read from the front buffer.   </para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.GetMagnification">
            <summary>
                <para>The magnification of the current render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.GetMagnificationMaxValue">
            <summary>
                <para>The magnification of the current render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.GetMagnificationMinValue">
            <summary>
                <para>The magnification of the current render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.SetMagnification(System.Int32)">
            <summary>
                <para>The magnification of the current render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.GetInput">
            <summary>
                <para>Returns which renderer is being used as the source for the pixel data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWindowToImageFilter.SetInput(vtk.vtkWindow)">
            <summary>
                <para>Indicates what renderer to get the pixel data from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.OnMouseWheelBackward">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.OnMouseWheelForward">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.OnRightButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.OnRightButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.OnMiddleButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.OnMiddleButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.OnLeftButtonUp">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.OnLeftButtonDown">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleTrackballCamera.OnMouseMove">
            <summary>
                <para>Event bindings controlling the effects of pressing mouse buttons or moving the mouse.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTextActor3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this text actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.GetTextProperty">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.SetTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.GetInput">
            <summary>
                <para>Set the text string to be displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor3D.SetInput(System.String)">
            <summary>
                <para>Set the text string to be displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeCollection.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVolumeCollection.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVolume.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVolume.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVolume.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVolume.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVolume.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this vtkVolume. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetRedrawMTime">
            <summary>
                <para>Return the mtime of anything that would cause the rendered image to  appear differently. Usually this involves checking the mtime of the  prop plus anything else it depends on such as properties, mappers, etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetMTime">
            <summary>
                <para>Return the MTime also considering the property etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetMaxZBound">
            <summary>
                <para>Get the bounds - either all six at once  (xmin, xmax, ymin, ymax, zmin, zmax) or one at a time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetMinZBound">
            <summary>
                <para>Get the bounds - either all six at once  (xmin, xmax, ymin, ymax, zmin, zmax) or one at a time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetMaxYBound">
            <summary>
                <para>Get the bounds - either all six at once  (xmin, xmax, ymin, ymax, zmin, zmax) or one at a time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetMinYBound">
            <summary>
                <para>Get the bounds - either all six at once  (xmin, xmax, ymin, ymax, zmin, zmax) or one at a time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetMaxXBound">
            <summary>
                <para>Get the bounds - either all six at once  (xmin, xmax, ymin, ymax, zmin, zmax) or one at a time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetMinXBound">
            <summary>
                <para>Get the bounds - either all six at once  (xmin, xmax, ymin, ymax, zmin, zmax) or one at a time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetBounds(System.Double[])">
            <summary>
                <para>Get the bounds - either all six at once  (xmin, xmax, ymin, ymax, zmin, zmax) or one at a time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetBounds">
            <summary>
                <para>Get the bounds - either all six at once  (xmin, xmax, ymin, ymax, zmin, zmax) or one at a time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.Update">
            <summary>
                <para>Update the volume rendering pipeline by updating the volume mapper</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetVolumes(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. This method is used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetProperty">
            <summary>
                <para>Set/Get the volume property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.SetProperty(vtk.vtkVolumeProperty)">
            <summary>
                <para>Set/Get the volume property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.GetMapper">
            <summary>
                <para>Set/Get the volume mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolume.SetMapper(vtk.vtkAbstractVolumeMapper)">
            <summary>
                <para>Set/Get the volume mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.IsARenderIntoImageMapper">
            <summary>
                <para>Is this a "render into image" mapper? A subclass would return 1 if the mapper produces an image by rendering into a software image buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.IsARayCastMapper">
            <summary>
                <para>Is this a ray cast mapper? A subclass would return 1 if the ray caster is needed to generate an image from this mapper.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.GetLength">
            <summary>
                <para>Return the diagonal length of this mappers bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.GetCenter(System.Double[])">
            <summary>
                <para>Return the Center of this mapper's data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.GetCenter">
            <summary>
                <para>Return the Center of this mapper's data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.GetBounds(System.Double[])">
            <summary>
                <para>Get the bounds for this mapper as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractMapper3D.GetBounds">
            <summary>
                <para>Return bounding box (array of six doubles) of data expressed as (xmin,xmax, ymin,ymax, zmin,zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBJExporter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOBJExporter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOBJExporter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOBJExporter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOBJExporter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOBJExporter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOBJExporter.GetFilePrefix">
            <summary>
                <para>Specify the prefix of the files to write out. The resulting filenames will have .obj and .mtl appended to them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOBJExporter.SetFilePrefix(System.String)">
            <summary>
                <para>Specify the prefix of the files to write out. The resulting filenames will have .obj and .mtl appended to them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExporter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExporter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExporter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExporter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExporter.GetMTime">
            <summary>
                <para>Returns the MTime also considering the RenderWindow.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExporter.GetInput">
            <summary>
                <para>These methods are provided for backward compatibility. Will disappear soon.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExporter.SetInput(vtk.vtkRenderWindow)">
            <summary>
                <para>These methods are provided for backward compatibility. Will disappear soon.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExporter.GetRenderWindow">
            <summary>
                <para>Set/Get the rendering window that contains the scene to be written.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExporter.SetRenderWindow(vtk.vtkRenderWindow)">
            <summary>
                <para>Set/Get the rendering window that contains the scene to be written.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExporter.Update">
            <summary>
                <para>Convenient alias for Write() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExporter.Write">
            <summary>
                <para>Write data to output. Method executes subclasses WriteData() method, as  well as StartWrite() and EndWrite() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.SetCurrentRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Overridden from vtkInteractorObserver because the interactor styles used by this class must also be updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.SetDefaultRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Overridden from vtkInteractorObserver because the interactor styles used by this class must also be updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.OnChar">
            <summary>
                <para>Only care about the char event, which is used to switch between different styles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.SetCurrentStyleToTrackballCamera">
            <summary>
                <para>Set/Get current style</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.SetCurrentStyleToTrackballActor">
            <summary>
                <para>Set/Get current style</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.SetCurrentStyleToJoystickCamera">
            <summary>
                <para>Set/Get current style</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.SetCurrentStyleToJoystickActor">
            <summary>
                <para>Set/Get current style</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.GetCurrentStyle">
            <summary>
                <para>Set/Get current style</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.SetAutoAdjustCameraClippingRange(System.Int32)">
            <summary>
                <para>We must override this method in order to pass the setting down to the underlying styles</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyleSwitch.SetInteractor(vtk.vtkRenderWindowInteractor)">
            <summary>
                <para>The sub styles need the interactor too.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorStyle.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.GetMouseWheelMotionFactor">
            <summary>
                <para>Set/Get the mouse wheel motion factor. Default to 1.0. Set it to a  different value to emphasize or de-emphasize the action triggered by mouse wheel motion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.SetMouseWheelMotionFactor(System.Double)">
            <summary>
                <para>Set/Get the mouse wheel motion factor. Default to 1.0. Set it to a  different value to emphasize or de-emphasize the action triggered by mouse wheel motion.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.GetPickColor">
            <summary>
                <para>Set/Get the pick color (used by default to color vtkActor2D's). The color is expressed as red/green/blue values between (0.0,1.0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.SetPickColor(System.Double[])">
            <summary>
                <para>Set/Get the pick color (used by default to color vtkActor2D's). The color is expressed as red/green/blue values between (0.0,1.0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.SetPickColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the pick color (used by default to color vtkActor2D's). The color is expressed as red/green/blue values between (0.0,1.0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.HighlightProp3D(vtk.vtkProp3D)">
            <summary>
                <para>When picking successfully selects an actor, this method highlights the picked prop appropriately. Currently this is done by placing a bounding  box around a picked vtkProp3D, and using the PickColor to highlight a vtkProp2D. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.HighlightActor2D(vtk.vtkActor2D)">
            <summary>
                <para>When picking successfully selects an actor, this method highlights the picked prop appropriately. Currently this is done by placing a bounding  box around a picked vtkProp3D, and using the PickColor to highlight a vtkProp2D. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.HighlightProp(vtk.vtkProp)">
            <summary>
                <para>When picking successfully selects an actor, this method highlights the picked prop appropriately. Currently this is done by placing a bounding  box around a picked vtkProp3D, and using the PickColor to highlight a vtkProp2D. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.EndTimer">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StartTimer">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.EndUniformScale">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StartUniformScale">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.EndDolly">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StartDolly">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.EndSpin">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StartSpin">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.EndPan">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StartPan">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.EndZoom">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StartZoom">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.EndRotate">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StartRotate">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StopAnimate">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StartAnimate">
            <summary>
                <para>Interaction mode entry points used internally.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StopState">
            <summary>
                <para>utility routines used by state changes</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.StartState(System.Int32)">
            <summary>
                <para>utility routines used by state changes</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.UniformScale">
            <summary>
                <para>These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.Zoom">
            <summary>
                <para>These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.Dolly">
            <summary>
                <para>These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.Pan">
            <summary>
                <para>These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.Spin">
            <summary>
                <para>These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.Rotate">
            <summary>
                <para>These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnTimer">
            <summary>
                <para>OnTimer calls Rotate, Rotate etc which should be overridden by style subclasses.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnLeave">
            <summary>
                <para>These are more esoteric events, but are useful in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnEnter">
            <summary>
                <para>These are more esoteric events, but are useful in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnConfigure">
            <summary>
                <para>These are more esoteric events, but are useful in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnExpose">
            <summary>
                <para>These are more esoteric events, but are useful in some cases.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnKeyRelease">
            <summary>
                <para>OnChar implements keyboard functions, but subclasses can override this  behavior</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnKeyPress">
            <summary>
                <para>OnChar implements keyboard functions, but subclasses can override this  behavior</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnKeyUp">
            <summary>
                <para>OnChar implements keyboard functions, but subclasses can override this  behavior</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnKeyDown">
            <summary>
                <para>OnChar implements keyboard functions, but subclasses can override this  behavior</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnChar">
            <summary>
                <para>OnChar implements keyboard functions, but subclasses can override this  behavior</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnMouseWheelBackward">
            <summary>
                <para>Generic event bindings must be overridden in subclasses</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnMouseWheelForward">
            <summary>
                <para>Generic event bindings must be overridden in subclasses</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnRightButtonUp">
            <summary>
                <para>Generic event bindings must be overridden in subclasses</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnRightButtonDown">
            <summary>
                <para>Generic event bindings must be overridden in subclasses</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnMiddleButtonUp">
            <summary>
                <para>Generic event bindings must be overridden in subclasses</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnMiddleButtonDown">
            <summary>
                <para>Generic event bindings must be overridden in subclasses</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnLeftButtonUp">
            <summary>
                <para>Generic event bindings must be overridden in subclasses</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnLeftButtonDown">
            <summary>
                <para>Generic event bindings must be overridden in subclasses</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.OnMouseMove">
            <summary>
                <para>Generic event bindings must be overridden in subclasses</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.HandleObserversOff">
            <summary>
                <para>Does ProcessEvents handle observers on this class or not</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.HandleObserversOn">
            <summary>
                <para>Does ProcessEvents handle observers on this class or not</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.GetHandleObservers">
            <summary>
                <para>Does ProcessEvents handle observers on this class or not</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.SetHandleObservers(System.Int32)">
            <summary>
                <para>Does ProcessEvents handle observers on this class or not</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.UseTimersOff">
            <summary>
                <para>Set/Get timer hint</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.UseTimersOn">
            <summary>
                <para>Set/Get timer hint</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.SetUseTimers(System.Int32)">
            <summary>
                <para>Set/Get timer hint</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.GetUseTimers">
            <summary>
                <para>Set/Get timer hint</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.GetState">
            <summary>
                <para>Some useful information for interaction</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.FindPokedRenderer(System.Int32,System.Int32)">
            <summary>
                <para>When an event occurs, we must determine which Renderer the event occurred within, since one RenderWindow may contain multiple renderers. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.AutoAdjustCameraClippingRangeOff">
            <summary>
                <para>If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.AutoAdjustCameraClippingRangeOn">
            <summary>
                <para>If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.GetAutoAdjustCameraClippingRange">
            <summary>
                <para>If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.GetAutoAdjustCameraClippingRangeMaxValue">
            <summary>
                <para>If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.GetAutoAdjustCameraClippingRangeMinValue">
            <summary>
                <para>If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.SetAutoAdjustCameraClippingRange(System.Int32)">
            <summary>
                <para>If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.SetEnabled(System.Int32)">
            <summary>
                <para>Turn on/off this interactor. Interactor styles operate a little bit differently than other types of interactor observers. When the SetInteractor() method is invoked, the automatically enable themselves. This is a legacy requirement, and convenient for the user.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorStyle.SetInteractor(vtk.vtkRenderWindowInteractor)">
            <summary>
                <para>Set/Get the Interactor wrapper being controlled by this object. (Satisfy superclass API.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkInteractorObserver.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.SetCurrentRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Set/Get the current renderer. Normally when the widget is activated  (SetEnabled(1) or when keypress activation takes place), the renderer over which the mouse pointer is positioned is used and assigned to this Ivar. Alternatively, you might want to set the CurrentRenderer explicitly. WARNING: note that if the DefaultRenderer Ivar is set (see above),  it will always override the parameter passed to SetCurrentRenderer, unless it is NULL. (i.e., SetCurrentRenderer(foo) = SetCurrentRenderer(DefaultRenderer).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.GetCurrentRenderer">
            <summary>
                <para>Set/Get the current renderer. Normally when the widget is activated  (SetEnabled(1) or when keypress activation takes place), the renderer over which the mouse pointer is positioned is used and assigned to this Ivar. Alternatively, you might want to set the CurrentRenderer explicitly. WARNING: note that if the DefaultRenderer Ivar is set (see above),  it will always override the parameter passed to SetCurrentRenderer, unless it is NULL. (i.e., SetCurrentRenderer(foo) = SetCurrentRenderer(DefaultRenderer).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.SetDefaultRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Set/Get the default renderer to use when activating the interactor  observer. Normally when the widget is activated (SetEnabled(1) or when  keypress activation takes place), the renderer over which the mouse pointer is positioned is used. Alternatively, you can specify the renderer to bind the interactor to when the interactor observer is activated. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.GetDefaultRenderer">
            <summary>
                <para>Set/Get the default renderer to use when activating the interactor  observer. Normally when the widget is activated (SetEnabled(1) or when  keypress activation takes place), the renderer over which the mouse pointer is positioned is used. Alternatively, you can specify the renderer to bind the interactor to when the interactor observer is activated. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.GetKeyPressActivationValue">
            <summary>
                <para>Specify which key press value to use to activate the interactor observer (if key press activation is enabled). By default, the key press activation value is 'i'. Note: once the SetInteractor() method is invoked, changing the key press activation value will not affect the key press until SetInteractor(NULL)/SetInteractor(iren) is called.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.SetKeyPressActivationValue(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
            <summary>
                <para>Specify which key press value to use to activate the interactor observer (if key press activation is enabled). By default, the key press activation value is 'i'. Note: once the SetInteractor() method is invoked, changing the key press activation value will not affect the key press until SetInteractor(NULL)/SetInteractor(iren) is called.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.KeyPressActivationOff">
            <summary>
                <para>Enable/Disable of the use of a keypress to turn on and off the interactor observer. (By default, the keypress is 'i' for "interactor observer".)  Set the KeyPressActivationValue to change which key activates the widget.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.KeyPressActivationOn">
            <summary>
                <para>Enable/Disable of the use of a keypress to turn on and off the interactor observer. (By default, the keypress is 'i' for "interactor observer".)  Set the KeyPressActivationValue to change which key activates the widget.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.GetKeyPressActivation">
            <summary>
                <para>Enable/Disable of the use of a keypress to turn on and off the interactor observer. (By default, the keypress is 'i' for "interactor observer".)  Set the KeyPressActivationValue to change which key activates the widget.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.SetKeyPressActivation(System.Int32)">
            <summary>
                <para>Enable/Disable of the use of a keypress to turn on and off the interactor observer. (By default, the keypress is 'i' for "interactor observer".)  Set the KeyPressActivationValue to change which key activates the widget.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.GetPriority">
            <summary>
                <para>Set/Get the priority at which events are processed. This is used when multiple interactor observers are used simultaneously. The default value is 0.0 (lowest priority.) Note that when multiple interactor observer have the same priority, then the last observer added will process the event first. (Note: once the SetInteractor() method has been called, changing the priority does not effect event processing. You will have to SetInteractor(NULL), change priority, and then SetInteractor(iren) to have the priority take effect.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.GetPriorityMaxValue">
            <summary>
                <para>Set/Get the priority at which events are processed. This is used when multiple interactor observers are used simultaneously. The default value is 0.0 (lowest priority.) Note that when multiple interactor observer have the same priority, then the last observer added will process the event first. (Note: once the SetInteractor() method has been called, changing the priority does not effect event processing. You will have to SetInteractor(NULL), change priority, and then SetInteractor(iren) to have the priority take effect.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.GetPriorityMinValue">
            <summary>
                <para>Set/Get the priority at which events are processed. This is used when multiple interactor observers are used simultaneously. The default value is 0.0 (lowest priority.) Note that when multiple interactor observer have the same priority, then the last observer added will process the event first. (Note: once the SetInteractor() method has been called, changing the priority does not effect event processing. You will have to SetInteractor(NULL), change priority, and then SetInteractor(iren) to have the priority take effect.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.SetPriority(System.Single)">
            <summary>
                <para>Set/Get the priority at which events are processed. This is used when multiple interactor observers are used simultaneously. The default value is 0.0 (lowest priority.) Note that when multiple interactor observer have the same priority, then the last observer added will process the event first. (Note: once the SetInteractor() method has been called, changing the priority does not effect event processing. You will have to SetInteractor(NULL), change priority, and then SetInteractor(iren) to have the priority take effect.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.GetInteractor">
            <summary>
                <para>This method is used to associate the widget with the render window interactor.  Observers of the appropriate events invoked in the render window interactor are set up as a result of this method invocation. The SetInteractor() method must be invoked prior to enabling the vtkInteractorObserver.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.SetInteractor(vtk.vtkRenderWindowInteractor)">
            <summary>
                <para>This method is used to associate the widget with the render window interactor.  Observers of the appropriate events invoked in the render window interactor are set up as a result of this method invocation. The SetInteractor() method must be invoked prior to enabling the vtkInteractorObserver.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.Off">
            <summary>
                <para>This method is used to associate the widget with the render window interactor.  Observers of the appropriate events invoked in the render window interactor are set up as a result of this method invocation. The SetInteractor() method must be invoked prior to enabling the vtkInteractorObserver.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.On">
            <summary>
                <para>Methods for turning the interactor observer on and off, and determining its state. All subclasses must provide the SetEnabled() method. Enabling a vtkInteractorObserver has the side effect of adding observers; disabling it removes the observers. Prior to enabling the vtkInteractorObserver you must set the render window interactor (via SetInteractor()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.EnabledOff">
            <summary>
                <para>Methods for turning the interactor observer on and off, and determining its state. All subclasses must provide the SetEnabled() method. Enabling a vtkInteractorObserver has the side effect of adding observers; disabling it removes the observers. Prior to enabling the vtkInteractorObserver you must set the render window interactor (via SetInteractor()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.EnabledOn">
            <summary>
                <para>Methods for turning the interactor observer on and off, and determining its state. All subclasses must provide the SetEnabled() method. Enabling a vtkInteractorObserver has the side effect of adding observers; disabling it removes the observers. Prior to enabling the vtkInteractorObserver you must set the render window interactor (via SetInteractor()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.GetEnabled">
            <summary>
                <para>Methods for turning the interactor observer on and off, and determining its state. All subclasses must provide the SetEnabled() method. Enabling a vtkInteractorObserver has the side effect of adding observers; disabling it removes the observers. Prior to enabling the vtkInteractorObserver you must set the render window interactor (via SetInteractor()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkInteractorObserver.SetEnabled(System.Int32)">
            <summary>
                <para>Methods for turning the interactor observer on and off, and determining its state. All subclasses must provide the SetEnabled() method. Enabling a vtkInteractorObserver has the side effect of adding observers; disabling it removes the observers. Prior to enabling the vtkInteractorObserver you must set the render window interactor (via SetInteractor()).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLCamera.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLCamera.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLCamera.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLCamera.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLCamera.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLCamera.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLCamera.Render(vtk.vtkRenderer)">
            <summary>
                <para>Implement base class method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkOpenGLLight.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLLight.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLLight.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkOpenGLLight.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkOpenGLLight.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLLight.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkOpenGLLight.Render(vtk.vtkRenderer,System.Int32)">
            <summary>
                <para>Implement base class method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.SetInterpolationTypeToLinear">
            <summary>
                <para>Specify which type of function to use for interpolation. By default (SetInterpolationFunctionToSpline()), cubic spline interpolation using a modifed Kochanek basis is employed. Otherwise, if SetInterpolationFunctionToLinear() is invoked, linear spherical interpolation is used between each pair of quaternions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.GetInterpolationType">
            <summary>
                <para>Specify which type of function to use for interpolation. By default (SetInterpolationFunctionToSpline()), cubic spline interpolation using a modifed Kochanek basis is employed. Otherwise, if SetInterpolationFunctionToLinear() is invoked, linear spherical interpolation is used between each pair of quaternions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.GetInterpolationTypeMaxValue">
            <summary>
                <para>Specify which type of function to use for interpolation. By default (SetInterpolationFunctionToSpline()), cubic spline interpolation using a modifed Kochanek basis is employed. Otherwise, if SetInterpolationFunctionToLinear() is invoked, linear spherical interpolation is used between each pair of quaternions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.GetInterpolationTypeMinValue">
            <summary>
                <para>Specify which type of function to use for interpolation. By default (SetInterpolationFunctionToSpline()), cubic spline interpolation using a modifed Kochanek basis is employed. Otherwise, if SetInterpolationFunctionToLinear() is invoked, linear spherical interpolation is used between each pair of quaternions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.SetInterpolationType(System.Int32)">
            <summary>
                <para>Specify which type of function to use for interpolation. By default (SetInterpolationFunctionToSpline()), cubic spline interpolation using a modifed Kochanek basis is employed. Otherwise, if SetInterpolationFunctionToLinear() is invoked, linear spherical interpolation is used between each pair of quaternions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.InterpolateQuaternion(System.Double,System.Double[])">
            <summary>
                <para>Interpolate the list of quaternions and determine a new quaternion (i.e., fill in the quaternion provided). If t is outside the range of (min,max) values, then t is clamped to lie within the range. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.RemoveQuaternion(System.Double)">
            <summary>
                <para>Delete the quaternion at a particular parameter t. If there is no quaternion tuple defined at t, then the method does nothing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.AddQuaternion(System.Double,System.Double[])">
            <summary>
                <para>Add another quaternion to the list of quaternions to be interpolated. Note that using the same time t value more than once replaces the previous quaternion at t.  At least one quaternions must be added to define an interpolation functios.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.Initialize">
            <summary>
                <para>Reset the class so that it contains no data; i.e., the array of (t,q[4]) information is discarded.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.GetMaximumT">
            <summary>
                <para>Obtain some information about the interpolation range. The numbers returned (corresponding to parameter t, usually thought of as time) are undefined if the list of transforms is empty. This is a convenience method for interpolation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.GetMinimumT">
            <summary>
                <para>Obtain some information about the interpolation range. The numbers returned (corresponding to parameter t, usually thought of as time) are undefined if the list of transforms is empty. This is a convenience method for interpolation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkQuaternionInterpolator.GetNumberOfQuaternions">
            <summary>
                <para>Return the number of quaternions in the list of quaternions to be interpolated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetMTime">
            <summary>
                <para>Override GetMTime() because we depend on the interpolators which may be modified outside of this class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetRotationInterpolator">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the orientation portion of the transformation matrix. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.SetRotationInterpolator(vtk.vtkQuaternionInterpolator)">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the orientation portion of the transformation matrix. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetScaleInterpolator">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the scale portion of the transformation matrix. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.SetScaleInterpolator(vtk.vtkTupleInterpolator)">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the scale portion of the transformation matrix. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetPositionInterpolator">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the position portion of the transformation matrix. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.SetPositionInterpolator(vtk.vtkTupleInterpolator)">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the position portion of the transformation matrix. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.SetInterpolationTypeToManual">
            <summary>
                <para>Set/Get the tuple interpolator used to interpolate the position portion of the transformation matrix. Note that you can modify the behavior of the interpolator (linear vs spline interpolation; change spline basis) by manipulating the interpolator instances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.SetInterpolationTypeToSpline">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the position, scale and orientation interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.SetInterpolationTypeToLinear">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the position, scale and orientation interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetInterpolationType">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the position, scale and orientation interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetInterpolationTypeMaxValue">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the position, scale and orientation interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetInterpolationTypeMinValue">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the position, scale and orientation interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.SetInterpolationType(System.Int32)">
            <summary>
                <para>These are convenience methods to switch between linear and spline interpolation. The methods simply forward the request for linear or spline interpolation to the position, scale and orientation interpolators. Note that if the InterpolationType is set to "Manual", then the interpolators are expected to be directly manipulated and this class does not forward the request for interpolation type to its interpolators.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.InterpolateTransform(System.Double,vtk.vtkTransform)">
            <summary>
                <para>Interpolate the list of transforms and determine a new transform (i.e., fill in the transformation provided). If t is outside the range of (min,max) values, then t is clamped.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.RemoveTransform(System.Double)">
            <summary>
                <para>Delete the transform at a particular parameter t. If there is no transform defined at location t, then the method does nothing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.AddTransform(System.Double,vtk.vtkProp3D)">
            <summary>
                <para>Add another transform to the list of transformations defining the transform function. Note that using the same time t value more than once replaces the previous transform value at t. At least two transforms must be added to define a function. There are variants to this method depending on whether you are adding a vtkTransform, vtkMaxtirx4x4, and/or vtkProp3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.AddTransform(System.Double,vtk.vtkMatrix4x4)">
            <summary>
                <para>Add another transform to the list of transformations defining the transform function. Note that using the same time t value more than once replaces the previous transform value at t. At least two transforms must be added to define a function. There are variants to this method depending on whether you are adding a vtkTransform, vtkMaxtirx4x4, and/or vtkProp3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.AddTransform(System.Double,vtk.vtkTransform)">
            <summary>
                <para>Add another transform to the list of transformations defining the transform function. Note that using the same time t value more than once replaces the previous transform value at t. At least two transforms must be added to define a function. There are variants to this method depending on whether you are adding a vtkTransform, vtkMaxtirx4x4, and/or vtkProp3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.Initialize">
            <summary>
                <para>Clear the list of transforms.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetMaximumT">
            <summary>
                <para>Obtain some information about the interpolation range. The numbers returned (corresponding to parameter t, usually thought of as time) are undefined if the list of transforms is empty.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetMinimumT">
            <summary>
                <para>Obtain some information about the interpolation range. The numbers returned (corresponding to parameter t, usually thought of as time) are undefined if the list of transforms is empty.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformInterpolator.GetNumberOfTransforms">
            <summary>
                <para>Return the number of transforms in the list of transforms.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetInput">
            <summary>
                <para>Remove a dataset from the list of data to append.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.SetInput(vtk.vtkDataObject)">
            <summary>
                <para>Set the input to the parallel coordinates actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Set the input to the parallel coordinates actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.RenderOverlay(vtk.vtkViewport)">
            <summary>
                <para>Draw the parallel coordinates plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Draw the parallel coordinates plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetLabelTextProperty">
            <summary>
                <para>Set/Get the labels text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.SetLabelTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the labels text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetTitleTextProperty">
            <summary>
                <para>Set/Get the title text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.SetTitleTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the title text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetLabelFormat">
            <summary>
                <para>Set/Get the format with which to print the labels on the axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.SetLabelFormat(System.String)">
            <summary>
                <para>Set/Get the format with which to print the labels on the axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetNumberOfLabels">
            <summary>
                <para>Set/Get the number of annotation labels to show along each axis. This values is a suggestion: the number of labels may vary depending on the particulars of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetNumberOfLabelsMaxValue">
            <summary>
                <para>Set/Get the number of annotation labels to show along each axis. This values is a suggestion: the number of labels may vary depending on the particulars of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetNumberOfLabelsMinValue">
            <summary>
                <para>Set/Get the number of annotation labels to show along each axis. This values is a suggestion: the number of labels may vary depending on the particulars of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.SetNumberOfLabels(System.Int32)">
            <summary>
                <para>Set/Get the number of annotation labels to show along each axis. This values is a suggestion: the number of labels may vary depending on the particulars of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetTitle">
            <summary>
                <para>Set/Get the title of the parallel coordinates plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.SetTitle(System.String)">
            <summary>
                <para>Set/Get the title of the parallel coordinates plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.SetIndependentVariablesToRows">
            <summary>
                <para>Specify whether to use the rows or columns as independent variables. If columns, then each row represents a separate point. If rows, then  each column represents a separate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.SetIndependentVariablesToColumns">
            <summary>
                <para>Specify whether to use the rows or columns as independent variables. If columns, then each row represents a separate point. If rows, then  each column represents a separate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetIndependentVariables">
            <summary>
                <para>Specify whether to use the rows or columns as independent variables. If columns, then each row represents a separate point. If rows, then  each column represents a separate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetIndependentVariablesMaxValue">
            <summary>
                <para>Specify whether to use the rows or columns as independent variables. If columns, then each row represents a separate point. If rows, then  each column represents a separate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.GetIndependentVariablesMinValue">
            <summary>
                <para>Specify whether to use the rows or columns as independent variables. If columns, then each row represents a separate point. If rows, then  each column represents a separate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkParallelCoordinatesActor.SetIndependentVariables(System.Int32)">
            <summary>
                <para>Specify whether to use the rows or columns as independent variables. If columns, then each row represents a separate point. If rows, then  each column represents a separate point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTextActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTextProperty.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTextProperty.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTextProperty.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTextProperty.ShallowCopy(vtk.vtkTextProperty)">
            <summary>
                <para>Shallow copy of a text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetLineOffset">
            <summary>
                <para>Set/Get the vertical offset (measured in pixels).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetLineOffset(System.Double)">
            <summary>
                <para>Set/Get the vertical offset (measured in pixels).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetLineSpacing">
            <summary>
                <para>Set/Get the (extra) spacing between lines,  expressed as a text height multiplication factor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetLineSpacing(System.Double)">
            <summary>
                <para>Set/Get the (extra) spacing between lines,  expressed as a text height multiplication factor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetOrientation">
            <summary>
                <para>Set/Get the text's orientation (in degrees).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetOrientation(System.Double)">
            <summary>
                <para>Set/Get the text's orientation (in degrees).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetVerticalJustificationAsString">
            <summary>
                <para>Set/Get the vertical justification to bottom (default), middle, or top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetVerticalJustificationToTop">
            <summary>
                <para>Set/Get the vertical justification to bottom (default), middle, or top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetVerticalJustificationToCentered">
            <summary>
                <para>Set/Get the vertical justification to bottom (default), middle, or top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetVerticalJustificationToBottom">
            <summary>
                <para>Set/Get the vertical justification to bottom (default), middle, or top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetVerticalJustification">
            <summary>
                <para>Set/Get the vertical justification to bottom (default), middle, or top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetVerticalJustificationMaxValue">
            <summary>
                <para>Set/Get the vertical justification to bottom (default), middle, or top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetVerticalJustificationMinValue">
            <summary>
                <para>Set/Get the vertical justification to bottom (default), middle, or top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetVerticalJustification(System.Int32)">
            <summary>
                <para>Set/Get the vertical justification to bottom (default), middle, or top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetJustificationAsString">
            <summary>
                <para>Set/Get the horizontal justification to left (default), centered, or right.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetJustificationToRight">
            <summary>
                <para>Set/Get the horizontal justification to left (default), centered, or right.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetJustificationToCentered">
            <summary>
                <para>Set/Get the horizontal justification to left (default), centered, or right.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetJustificationToLeft">
            <summary>
                <para>Set/Get the horizontal justification to left (default), centered, or right.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetJustification">
            <summary>
                <para>Set/Get the horizontal justification to left (default), centered, or right.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetJustificationMaxValue">
            <summary>
                <para>Set/Get the horizontal justification to left (default), centered, or right.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetJustificationMinValue">
            <summary>
                <para>Set/Get the horizontal justification to left (default), centered, or right.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetJustification(System.Int32)">
            <summary>
                <para>Set/Get the horizontal justification to left (default), centered, or right.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetShadowColor(System.Double[])">
            <summary>
                <para>Get the shadow color. It is computed from the Color ivar</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetShadowOffset">
            <summary>
                <para>Set/Get the shadow offset, i.e. the distance from the text to its shadow, in the same unit as FontSize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetShadowOffset(System.Int32[])">
            <summary>
                <para>Set/Get the shadow offset, i.e. the distance from the text to its shadow, in the same unit as FontSize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetShadowOffset(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the shadow offset, i.e. the distance from the text to its shadow, in the same unit as FontSize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.ShadowOff">
            <summary>
                <para>Enable/disable text shadow.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.ShadowOn">
            <summary>
                <para>Enable/disable text shadow.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetShadow">
            <summary>
                <para>Enable/disable text shadow.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetShadow(System.Int32)">
            <summary>
                <para>Enable/disable text shadow.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.ItalicOff">
            <summary>
                <para>Enable/disable text italic.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.ItalicOn">
            <summary>
                <para>Enable/disable text italic.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetItalic">
            <summary>
                <para>Enable/disable text italic.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetItalic(System.Int32)">
            <summary>
                <para>Enable/disable text italic.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.BoldOff">
            <summary>
                <para>Enable/disable text bolding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.BoldOn">
            <summary>
                <para>Enable/disable text bolding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetBold">
            <summary>
                <para>Enable/disable text bolding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetBold(System.Int32)">
            <summary>
                <para>Enable/disable text bolding.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetFontSize">
            <summary>
                <para>Set/Get the font size (in points).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetFontSizeMaxValue">
            <summary>
                <para>Set/Get the font size (in points).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetFontSizeMinValue">
            <summary>
                <para>Set/Get the font size (in points).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetFontSize(System.Int32)">
            <summary>
                <para>Set/Get the font size (in points).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetFontFamilyAsString(System.Int32)">
            <summary>
                <para>Set/Get the font family. Three font types are allowed: Arial (VTK_ARIAL), Courier (VTK_COURIER), and Times (VTK_TIMES).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetFontFamilyAsString">
            <summary>
                <para>Set/Get the font family. Three font types are allowed: Arial (VTK_ARIAL), Courier (VTK_COURIER), and Times (VTK_TIMES).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetFontFamilyToTimes">
            <summary>
                <para>Set/Get the font family. Three font types are allowed: Arial (VTK_ARIAL), Courier (VTK_COURIER), and Times (VTK_TIMES).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetFontFamilyToCourier">
            <summary>
                <para>Set/Get the font family. Three font types are allowed: Arial (VTK_ARIAL), Courier (VTK_COURIER), and Times (VTK_TIMES).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetFontFamilyToArial">
            <summary>
                <para>Set/Get the font family. Three font types are allowed: Arial (VTK_ARIAL), Courier (VTK_COURIER), and Times (VTK_TIMES).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetFontFamily">
            <summary>
                <para>Set/Get the font family. Three font types are allowed: Arial (VTK_ARIAL), Courier (VTK_COURIER), and Times (VTK_TIMES).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetFontFamilyMaxValue">
            <summary>
                <para>Set/Get the font family. Three font types are allowed: Arial (VTK_ARIAL), Courier (VTK_COURIER), and Times (VTK_TIMES).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetFontFamilyMinValue">
            <summary>
                <para>Set/Get the font family. Three font types are allowed: Arial (VTK_ARIAL), Courier (VTK_COURIER), and Times (VTK_TIMES).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetFontFamily(System.Int32)">
            <summary>
                <para>Set/Get the font family. Three font types are allowed: Arial (VTK_ARIAL), Courier (VTK_COURIER), and Times (VTK_TIMES).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetOpacity">
            <summary>
                <para>Set/Get the text's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetOpacity(System.Double)">
            <summary>
                <para>Set/Get the text's opacity. 1.0 is totally opaque and 0.0 is completely transparent.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.GetColor">
            <summary>
                <para>Set the color of the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetColor(System.Double[])">
            <summary>
                <para>Set the color of the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextProperty.SetColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the color of the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTextMapper.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTextMapper.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTextMapper.GetSystemFontSize(System.Int32)">
            <summary>
                <para>Get the available system font size matching a font size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.SetConstrainedFontSize(vtk.vtkViewport,System.Int32,System.Int32)">
            <summary>
                <para>Set and return the font size required to make this mapper fit in a given  target rectangle (width * height, in pixels).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.GetNumberOfLines(System.String)">
            <summary>
                <para>Determine the number of lines in the Input string (delimited by "\n").</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.ShallowCopy(vtk.vtkTextMapper)">
            <summary>
                <para>Shallow copy of an actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.GetTextProperty">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.SetTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.GetInput">
            <summary>
                <para>Set the input text string to the mapper.  The mapper recognizes "\n" as a carriage return/linefeed (line separator).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.SetInput(System.String)">
            <summary>
                <para>Set the input text string to the mapper.  The mapper recognizes "\n" as a carriage return/linefeed (line separator).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.GetHeight(vtk.vtkViewport)">
            <summary>
                <para>Return the size[2]/width/height of the rectangle required to draw this mapper (in pixels).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.GetWidth(vtk.vtkViewport)">
            <summary>
                <para>Return the size[2]/width/height of the rectangle required to draw this mapper (in pixels).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextMapper.GetSize(vtk.vtkViewport,System.Int32[])">
            <summary>
                <para>Return the size[2]/width/height of the rectangle required to draw this mapper (in pixels).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTextActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTextActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTextActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTextActor.SetNonLinearFontScale(System.Double,System.Int32)">
            <summary>
                <para>Enable non-linear scaling of font sizes. This is useful in combination with scaled text. With small windows you want to use the entire scaled text area. With larger windows you want to reduce the font size some so that the entire area is not used. These values modify the computed font  size as follows:     newFontSize = pow(FontSize,exponent)*pow(target,1.0 - exponent) typically exponent should be around 0.7 and target should be around 10</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.GetTextProperty">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.SetTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.GetActualPositionCoordinate">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.GetAlignmentPoint">
            <summary>
                <para>Set/Get the Alignment point for unscaled (fixed fontsize) text if zero (default), the text aligns itself to the bottom left corner (which is defined by the PositionCoordinate) otherwise the text aligns itself to corner/midpoint or centre @verbatim      6   7   8    Otherwise the text aligns itself to corner/midpoint      3   4   5    or centre of the box defined by the position 1 &amp; 2      0   1   2    coordinates according to the diagram on the left. @endverbatim</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.GetAlignmentPointMaxValue">
            <summary>
                <para>Set/Get the Alignment point for unscaled (fixed fontsize) text if zero (default), the text aligns itself to the bottom left corner (which is defined by the PositionCoordinate) otherwise the text aligns itself to corner/midpoint or centre @verbatim      6   7   8    Otherwise the text aligns itself to corner/midpoint      3   4   5    or centre of the box defined by the position 1 &amp; 2      0   1   2    coordinates according to the diagram on the left. @endverbatim</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.GetAlignmentPointMinValue">
            <summary>
                <para>Set/Get the Alignment point for unscaled (fixed fontsize) text if zero (default), the text aligns itself to the bottom left corner (which is defined by the PositionCoordinate) otherwise the text aligns itself to corner/midpoint or centre @verbatim      6   7   8    Otherwise the text aligns itself to corner/midpoint      3   4   5    or centre of the box defined by the position 1 &amp; 2      0   1   2    coordinates according to the diagram on the left. @endverbatim</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.SetAlignmentPoint(System.Int32)">
            <summary>
                <para>Set/Get the Alignment point for unscaled (fixed fontsize) text if zero (default), the text aligns itself to the bottom left corner (which is defined by the PositionCoordinate) otherwise the text aligns itself to corner/midpoint or centre @verbatim      6   7   8    Otherwise the text aligns itself to corner/midpoint      3   4   5    or centre of the box defined by the position 1 &amp; 2      0   1   2    coordinates according to the diagram on the left. @endverbatim</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.ScaledTextOff">
            <summary>
                <para>Turn on or off the ScaledText option. When text is scaled, the bounding rectangle is used to fit the text When ScaledText is off, the text is rendered at a fixed font size</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.ScaledTextOn">
            <summary>
                <para>Turn on or off the ScaledText option. When text is scaled, the bounding rectangle is used to fit the text When ScaledText is off, the text is rendered at a fixed font size</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.GetScaledText">
            <summary>
                <para>Turn on or off the ScaledText option. When text is scaled, the bounding rectangle is used to fit the text When ScaledText is off, the text is rendered at a fixed font size</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.SetScaledText(System.Int32)">
            <summary>
                <para>Turn on or off the ScaledText option. When text is scaled, the bounding rectangle is used to fit the text When ScaledText is off, the text is rendered at a fixed font size</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.GetMaximumLineHeight">
            <summary>
                <para>Set/Get the maximum height of a line of text as a percentage of the vertical area allocated to this scaled text actor. Defaults to 1.0. Not valid when ScaledText = false</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.SetMaximumLineHeight(System.Single)">
            <summary>
                <para>Set/Get the maximum height of a line of text as a percentage of the vertical area allocated to this scaled text actor. Defaults to 1.0. Not valid when ScaledText = false</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.GetMinimumSize">
            <summary>
                <para>Set/Get the minimum size in pixels for this actor. Defaults to 10,10. Not valid when ScaledText = false</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.SetMinimumSize(System.Int32[])">
            <summary>
                <para>Set/Get the minimum size in pixels for this actor. Defaults to 10,10. Not valid when ScaledText = false</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.SetMinimumSize(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the minimum size in pixels for this actor. Defaults to 10,10. Not valid when ScaledText = false</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.GetInput">
            <summary>
                <para>Set the text string to be displayed. "\n" is recognized as a carriage return/linefeed (line separator). Convenience method to the underlying mapper</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.SetInput(System.String)">
            <summary>
                <para>Set the text string to be displayed. "\n" is recognized as a carriage return/linefeed (line separator). Convenience method to the underlying mapper</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.SetMapper(vtk.vtkTextMapper)">
            <summary>
                <para>Override the vtkTextMapper that defines the text to be drawn. One will be created by default if none is supplied</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTextActor.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this text actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.GetInterpolatingSpline">
            <summary>
                <para>If the InterpolationType is set to spline, then this method applies. By default Kochanek interpolation is used, but you can specify any instance of vtkSpline to use. Note that the actual interpolating splines are created by invoking NewInstance() followed by DeepCopy() on the interpolating spline specified here, for each tuple component to interpolate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.SetInterpolatingSpline(vtk.vtkSpline)">
            <summary>
                <para>If the InterpolationType is set to spline, then this method applies. By default Kochanek interpolation is used, but you can specify any instance of vtkSpline to use. Note that the actual interpolating splines are created by invoking NewInstance() followed by DeepCopy() on the interpolating spline specified here, for each tuple component to interpolate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.SetInterpolationTypeToSpline">
            <summary>
                <para>If the InterpolationType is set to spline, then this method applies. By default Kochanek interpolation is used, but you can specify any instance of vtkSpline to use. Note that the actual interpolating splines are created by invoking NewInstance() followed by DeepCopy() on the interpolating spline specified here, for each tuple component to interpolate.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.SetInterpolationTypeToLinear">
            <summary>
                <para>Specify which type of function to use for interpolation. By default spline interpolation (SetInterpolationFunctionToSpline()) is used (i.e., a Kochanek spline) and the InterpolatingSpline instance variable is used to birth the actual interpolation splines via a combination of NewInstance() and DeepCopy(). You may also choose to use linear interpolation by invoking SetInterpolationFunctionToLinear(). Note that changing the type of interpolation causes previously inserted data to be discarded.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.GetInterpolationType">
            <summary>
                <para>Specify which type of function to use for interpolation. By default spline interpolation (SetInterpolationFunctionToSpline()) is used (i.e., a Kochanek spline) and the InterpolatingSpline instance variable is used to birth the actual interpolation splines via a combination of NewInstance() and DeepCopy(). You may also choose to use linear interpolation by invoking SetInterpolationFunctionToLinear(). Note that changing the type of interpolation causes previously inserted data to be discarded.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.SetInterpolationType(System.Int32)">
            <summary>
                <para>Specify which type of function to use for interpolation. By default spline interpolation (SetInterpolationFunctionToSpline()) is used (i.e., a Kochanek spline) and the InterpolatingSpline instance variable is used to birth the actual interpolation splines via a combination of NewInstance() and DeepCopy(). You may also choose to use linear interpolation by invoking SetInterpolationFunctionToLinear(). Note that changing the type of interpolation causes previously inserted data to be discarded.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.InterpolateTuple(System.Double,System.Double[])">
            <summary>
                <para>Interpolate the list of tuples and determine a new tuple (i.e., fill in the tuple provided). If t is outside the range of (min,max) values, then t is clamped. Note that each component of tuple[] is interpolated independently.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.RemoveTuple(System.Double)">
            <summary>
                <para>Delete the tuple at a particular parameter t. If there is no tuple defined at t, then the method does nothing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.AddTuple(System.Double,System.Double[])">
            <summary>
                <para>Add another tuple to the list of tuples to be interpolated.  Note that using the same time t value more than once replaces the previous tuple value at t.  At least two tuples must be added to define an interpolation function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.Initialize">
            <summary>
                <para>Reset the class so that it contains no (t,tuple) information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.GetMaximumT">
            <summary>
                <para>Obtain some information about the interpolation range. The numbers returned (corresponding to parameter t, usually thought of as time) are undefined if the list of transforms is empty. This is a convenience method for interpolation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.GetMinimumT">
            <summary>
                <para>Obtain some information about the interpolation range. The numbers returned (corresponding to parameter t, usually thought of as time) are undefined if the list of transforms is empty. This is a convenience method for interpolation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.GetNumberOfTuples">
            <summary>
                <para>Return the number of tuples in the list of tuples to be interpolated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.GetNumberOfComponents">
            <summary>
                <para>Specify the number of tuple components to interpolate. Note that setting this value discards any previously inserted data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTupleInterpolator.SetNumberOfComponents(System.Int32)">
            <summary>
                <para>Specify the number of tuple components to interpolate. Note that setting this value discards any previously inserted data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFollower.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFollower.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFollower.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFollower.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFollower.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFollower.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFollower.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of a follower. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFollower.GetMatrix">
            <summary>
                <para>Shallow copy of a follower. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFollower.GetMatrix(System.Double[])">
            <summary>
                <para>Copy the follower's composite 4x4 matrix into the matrix provided.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFollower.GetMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>Copy the follower's composite 4x4 matrix into the matrix provided.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFollower.Render(vtk.vtkRenderer)">
            <summary>
                <para>This causes the actor to be rendered. It in turn will render the actor's property, texture map and then mapper. If a property hasn't been assigned, then the actor will create one automatically. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkFollower.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>This causes the actor to be rendered. It in turn will render the actor's property, texture map and then mapper. If a property hasn't been assigned, then the actor will create one automatically. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkFollower.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>This causes the actor to be rendered. It in turn will render the actor's property, texture map and then mapper. If a property hasn't been assigned, then the actor will create one automatically. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkFollower.GetCamera">
            <summary>
                <para>Set/Get the camera to follow. If this is not set, then the follower won't know who to follow.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFollower.SetCamera(vtk.vtkCamera)">
            <summary>
                <para>Set/Get the camera to follow. If this is not set, then the follower won't know who to follow.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkActor.GetNumberOfParts">
            <summary>
                <para>The following methods are for compatibility. The methods will be deprecated in the near future. Use vtkProp::GetNextPath() (and related functionality) to get the parts in an assembly (or more correctly, the paths in the assembly).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetNextPart">
            <summary>
                <para>The following methods are for compatibility. The methods will be deprecated in the near future. Use vtkProp::GetNextPath() (and related functionality) to get the parts in an assembly (or more correctly, the paths in the assembly).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.InitPartTraversal">
            <summary>
                <para>The following methods are for compatibility. The methods will be deprecated in the near future. Use vtkProp::GetNextPath() (and related functionality) to get the parts in an assembly (or more correctly, the paths in the assembly).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetRedrawMTime">
            <summary>
                <para>Return the mtime of anything that would cause the rendered image to  appear differently. Usually this involves checking the mtime of the  prop plus anything else it depends on such as properties, textures etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetMTime">
            <summary>
                <para>Get the actors mtime plus consider its properties and texture if set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.ApplyProperties">
            <summary>
                <para>Apply the current properties to all parts that compose this actor. This method is overloaded in vtkAssembly to apply the assemblies' properties to all its parts in a recursive manner. Typically the use of this method is to set the desired properties in the assembly, and then push the properties down to the assemblies parts with ApplyProperties().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetBounds">
            <summary>
                <para>Get the bounds for this Actor as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax). (The method GetBounds(double bounds[6]) is available from the superclass.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetBounds(System.Double[])">
            <summary>
                <para>Get the bounds for this Actor as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax). (The method GetBounds(double bounds[6]) is available from the superclass.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetMapper">
            <summary>
                <para>Returns the Mapper that this actor is getting its data from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.SetMapper(vtk.vtkMapper)">
            <summary>
                <para>This is the method that is used to connect an actor to the end of a visualization pipeline, i.e. the mapper. This should be a subclass of vtkMapper. Typically vtkPolyDataMapper and vtkDataSetMapper will be used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetTexture">
            <summary>
                <para>Set/Get the texture object to control rendering texture maps.  This will be a vtkTexture object. An actor does not need to have an associated texture map and multiple actors can share one texture.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.SetTexture(vtk.vtkTexture)">
            <summary>
                <para>Set/Get the texture object to control rendering texture maps.  This will be a vtkTexture object. An actor does not need to have an associated texture map and multiple actors can share one texture.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetBackfaceProperty">
            <summary>
                <para>Set/Get the property object that controls this actors backface surface properties.  This should be an instance of a vtkProperty object. If one isn't specified, then the front face properties will be used.  Multiple actors can share one property object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.SetBackfaceProperty(vtk.vtkProperty)">
            <summary>
                <para>Set/Get the property object that controls this actors backface surface properties.  This should be an instance of a vtkProperty object. If one isn't specified, then the front face properties will be used.  Multiple actors can share one property object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.MakeProperty">
            <summary>
                <para>Create a new property sutible for use with this type of Actor. For example, a vtkMesaActor should create a vtkMesaProperty  in this function.   The default is to just call vtkProperty::New.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetProperty">
            <summary>
                <para>Set/Get the property object that controls this actors surface properties.  This should be an instance of a vtkProperty object.  Every actor must have a property associated with it.  If one isn't specified, then one will be generated automatically. Multiple actors can share one property object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.SetProperty(vtk.vtkProperty)">
            <summary>
                <para>Set/Get the property object that controls this actors surface properties.  This should be an instance of a vtkProperty object.  Every actor must have a property associated with it.  If one isn't specified, then one will be generated automatically. Multiple actors can share one property object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of an actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.Render(vtk.vtkRenderer,vtk.vtkMapper)">
            <summary>
                <para>This causes the actor to be rendered. It in turn will render the actor's property, texture map and then mapper. If a property hasn't been assigned, then the actor will create one automatically. Note that a side effect of this method is that the pipeline will be updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActor.GetActors(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProp3D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProp3D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProp3D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetIsIdentity">
            <summary>
                <para>Is the matrix for this actor identity</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetMatrix">
            <summary>
                <para>Is the matrix for this actor identity</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.ComputeMatrix">
            <summary>
                <para>Generate the matrix based on ivars</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetUserTransformMatrixMTime">
            <summary>
                <para>Get the modified time of the user matrix or user transform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetMTime">
            <summary>
                <para>Get the vtkProp3D's mtime </para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.InitPathTraversal">
            <summary>
                <para>Overload vtkProp's method for setting up assembly paths. See the documentation for vtkProp.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.PokeMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>This method modifies the vtkProp3D so that its transformation state is set to the matrix specified. The method does this by setting appropriate transformation-related ivars to initial values (i.e., not transformed), and placing the user-supplied matrix into the UserMatrix of this vtkProp3D. If the method is called again with a NULL matrix, then the original state of the vtkProp3D will be restored. This method is used to support picking and assembly structures.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.AddOrientation(System.Double[])">
            <summary>
                <para>Add to the current orientation. See SetOrientation and GetOrientation for more details. This basically does a GetOrientation, adds the passed in arguments, and then calls SetOrientation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.AddOrientation(System.Double,System.Double,System.Double)">
            <summary>
                <para>Add to the current orientation. See SetOrientation and GetOrientation for more details. This basically does a GetOrientation, adds the passed in arguments, and then calls SetOrientation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetOrientationWXYZ">
            <summary>
                <para>Returns the WXYZ orientation of the Prop3D. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetOrientation(System.Double[])">
            <summary>
                <para>Returns the orientation of the Prop3D as s vector of X,Y and Z rotation. The ordering in which these rotations must be done to generate the  same matrix is RotateZ, RotateX, and finally RotateY. See also  SetOrientation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetOrientation">
            <summary>
                <para>Returns the orientation of the Prop3D as s vector of X,Y and Z rotation. The ordering in which these rotations must be done to generate the  same matrix is RotateZ, RotateX, and finally RotateY. See also  SetOrientation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetOrientation(System.Double[])">
            <summary>
                <para>Sets the orientation of the Prop3D.  Orientation is specified as X,Y and Z rotations in that order, but they are performed as RotateZ, RotateX, and finally RotateY.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetOrientation(System.Double,System.Double,System.Double)">
            <summary>
                <para>Sets the orientation of the Prop3D.  Orientation is specified as X,Y and Z rotations in that order, but they are performed as RotateZ, RotateX, and finally RotateY.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.RotateWXYZ(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Rotate the Prop3D in degrees about an arbitrary axis specified by the last three arguments. The axis is specified in world coordinates. To rotate an about its model axes, use RotateX, RotateY, RotateZ.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.RotateZ(System.Double)">
            <summary>
                <para>Rotate the Prop3D in degrees about the Z axis using the right hand rule. The axis is the Prop3D's Z axis, which can change as other rotations are performed.  To rotate about the world Z axis use RotateWXYZ (angle, 0, 0, 1). This rotation is applied before all others in the current transformation matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.RotateY(System.Double)">
            <summary>
                <para>Rotate the Prop3D in degrees about the Y axis using the right hand rule. The axis is the Prop3D's Y axis, which can change as other rotations are performed.  To rotate about the world Y axis use RotateWXYZ (angle, 0, 1, 0). This rotation is applied before all others in the current transformation matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.RotateX(System.Double)">
            <summary>
                <para>Rotate the Prop3D in degrees about the X axis using the right hand rule. The axis is the Prop3D's X axis, which can change as other rotations are performed.  To rotate about the world X axis use RotateWXYZ (angle, 1, 0, 0). This rotation is applied before all others in the current transformation matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetLength">
            <summary>
                <para>Get the length of the diagonal of the bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetZRange">
            <summary>
                <para>Get the Prop3D's z range in world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetYRange">
            <summary>
                <para>Get the Prop3D's y range in world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetXRange">
            <summary>
                <para>Get the Prop3D's x range in world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetCenter">
            <summary>
                <para>Get the center of the bounding box in world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetBounds">
            <summary>
                <para>Get the bounds for this Prop3D as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetBounds(System.Double[])">
            <summary>
                <para>Get the bounds for this Prop3D as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetMatrix(System.Double[])">
            <summary>
                <para>Return a reference to the Prop3D's 4x4 composite matrix. Get the matrix from the position, origin, scale and orientation This matrix is cached, so multiple GetMatrix() calls will be efficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>Return a reference to the Prop3D's 4x4 composite matrix. Get the matrix from the position, origin, scale and orientation This matrix is cached, so multiple GetMatrix() calls will be efficient.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetUserMatrix">
            <summary>
                <para>The UserMatrix can be used in place of UserTransform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetUserMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>The UserMatrix can be used in place of UserTransform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetUserTransform">
            <summary>
                <para>In addition to the instance variables such as position and orientation, you can add an additional transformation for your own use.  This  transformation is concatenated with the actor's internal transformation, which you implicitly create through the use of SetPosition(),  SetOrigin() and SetOrientation().   </para>
                <para>If the internal transformation is identity (i.e. if you don't set the Position, Origin, or  Orientation) then the actors final transformation will be the UserTransform, concatenated with the UserMatrix if the UserMatrix is present.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetUserTransform(vtk.vtkLinearTransform)">
            <summary>
                <para>In addition to the instance variables such as position and orientation, you can add an additional transformation for your own use.  This  transformation is concatenated with the actor's internal transformation, which you implicitly create through the use of SetPosition(),  SetOrigin() and SetOrientation().   </para>
                <para>If the internal transformation is identity (i.e. if you don't set the Position, Origin, or  Orientation) then the actors final transformation will be the UserTransform, concatenated with the UserMatrix if the UserMatrix is present.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetScale(System.Double)">
            <summary>
                <para>Method to set the scale isotropically</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetScale">
            <summary>
                <para>Set/Get the scale of the actor. Scaling in performed independently on the X, Y and Z axis. A scale of zero is illegal and will be replaced with one.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetScale(System.Double[])">
            <summary>
                <para>Set/Get the scale of the actor. Scaling in performed independently on the X, Y and Z axis. A scale of zero is illegal and will be replaced with one.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetScale(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the scale of the actor. Scaling in performed independently on the X, Y and Z axis. A scale of zero is illegal and will be replaced with one.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetOrigin">
            <summary>
                <para>Set/Get the origin of the Prop3D. This is the point about which all  rotations take place.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetOrigin(System.Double[])">
            <summary>
                <para>Set/Get the origin of the Prop3D. This is the point about which all  rotations take place.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the origin of the Prop3D. This is the point about which all  rotations take place.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.AddPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get/Add the position of the Prop3D in world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.AddPosition(System.Double[])">
            <summary>
                <para>Set/Get/Add the position of the Prop3D in world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.GetPosition">
            <summary>
                <para>Set/Get/Add the position of the Prop3D in world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetPosition(System.Double[])">
            <summary>
                <para>Set/Get/Add the position of the Prop3D in world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.SetPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get/Add the position of the Prop3D in world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProp3D.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this vtkProp3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.GetOffScreenOnlyMode">
            <summary>
                <para>This option enables the off-screen only mode. In this mode no X calls will be made even when interactor is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.SetOffScreenOnlyMode(System.Int32)">
            <summary>
                <para>This option enables the off-screen only mode. In this mode no X calls will be made even when interactor is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.GetUseMesaClasses">
            <summary>
                <para>This option enables the creation of Mesa classes instead of the OpenGL classes when using mangled Mesa.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.SetUseMesaClasses(System.Int32)">
            <summary>
                <para>This option enables the creation of Mesa classes instead of the OpenGL classes when using mangled Mesa.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.GetRenderLibrary">
            <summary>
                <para>What rendering library has the user requested</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGraphicsFactory.CreateInstance(System.String)">
            <summary>
                <para>Create and return an instance of the named vtk object. This method first checks the vtkObjectFactory to support dynamic loading. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCuller.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCuller.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.DestroyTimer">
            <summary>
                <para>Allow users of the class to add callbacks to handle the creation and  destruction of timers.   CreateTimer should create a timer event of 10 milliseconds, and at the end of that time, it should call TimerEvent on this class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.CreateTimer(System.Int32)">
            <summary>
                <para>Allow users of the class to add callbacks to handle the creation and  destruction of timers.   CreateTimer should create a timer event of 10 milliseconds, and at the end of that time, it should call TimerEvent on this class.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.ExitEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.CharEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.KeyReleaseEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.KeyPressEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.TimerEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.LeaveEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.EnterEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.ConfigureEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.ExposeEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.MouseWheelBackwardEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.MouseWheelForwardEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.MiddleButtonReleaseEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.MiddleButtonPressEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.LeftButtonReleaseEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.LeftButtonPressEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.RightButtonReleaseEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.RightButtonPressEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGenericRenderWindowInteractor.MouseMoveEvent">
            <summary>
                <para>Fire various events, SetEventInformation should be called just prior to calling any of these methods.  This methods will Invoke the  corresponding vtk event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.FindPokedRenderer(System.Int32,System.Int32)">
            <summary>
                <para>When an event occurs, we must determine which Renderer the event occurred within, since one RenderWindow may contain multiple renderers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetEventSize">
            <summary>
                <para>This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize  (Expose event, for example).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetEventSize(System.Int32[])">
            <summary>
                <para>This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize  (Expose event, for example).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetEventSize(System.Int32,System.Int32)">
            <summary>
                <para>This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize  (Expose event, for example).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetSize">
            <summary>
                <para>This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize  (Expose event, for example).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetSize(System.Int32[])">
            <summary>
                <para>This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize  (Expose event, for example).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetSize(System.Int32,System.Int32)">
            <summary>
                <para>This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize  (Expose event, for example).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetKeyEventInformation(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32,System.String)">
            <summary>
                <para>This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize  (Expose event, for example).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetEventInformationFlipY(System.Int32,System.Int32,System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32,System.String)">
            <summary>
                <para>Set all the keyboard-related event information in one call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetEventInformation(System.Int32,System.Int32,System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Int32,System.String)">
            <summary>
                <para>Calls SetEventInformation, but flips the Y based on the current Size[1]  value (i.e. y = this-&gt;Size[1] - y - 1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetKeySym">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetKeySym(System.String)">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetRepeatCount">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetRepeatCount(System.Int32)">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetKeyCode">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetKeyCode(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetShiftKey">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetShiftKey(System.Int32)">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetControlKey">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetControlKey(System.Int32)">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetEventPositionFlipY(System.Int32[])">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetEventPositionFlipY(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetEventPosition(System.Int32[])">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetEventPosition(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetLastEventPosition(System.Int32[])">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetLastEventPosition(System.Int32,System.Int32)">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetLastEventPosition">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetEventPosition">
            <summary>
                <para>Set/Get information about the current event.  The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method.  The other information is about key board input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetDolly">
            <summary>
                <para>Set the total Dolly value to use when flying to (FlyTo()) a specified point. Negative values fly away from the point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetDolly(System.Double)">
            <summary>
                <para>Set the total Dolly value to use when flying to (FlyTo()) a specified point. Negative values fly away from the point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetNumberOfFlyFrames">
            <summary>
                <para>Set the number of frames to fly to when FlyTo is invoked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetNumberOfFlyFramesMaxValue">
            <summary>
                <para>Set the number of frames to fly to when FlyTo is invoked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetNumberOfFlyFramesMinValue">
            <summary>
                <para>Set the number of frames to fly to when FlyTo is invoked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetNumberOfFlyFrames(System.Int32)">
            <summary>
                <para>Set the number of frames to fly to when FlyTo is invoked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.FlyToImage(vtk.vtkRenderer,System.Double[])">
            <summary>
                <para>Set the number of frames to fly to when FlyTo is invoked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.FlyToImage(vtk.vtkRenderer,System.Double,System.Double)">
            <summary>
                <para>Given a position x, move the current camera's focal point to x. The movement is animated over the number of frames specified in NumberOfFlyFrames. The LOD desired frame rate is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.FlyTo(vtk.vtkRenderer,System.Double[])">
            <summary>
                <para>Given a position x, move the current camera's focal point to x. The movement is animated over the number of frames specified in NumberOfFlyFrames. The LOD desired frame rate is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.FlyTo(vtk.vtkRenderer,System.Double,System.Double,System.Double)">
            <summary>
                <para>Given a position x, move the current camera's focal point to x. The movement is animated over the number of frames specified in NumberOfFlyFrames. The LOD desired frame rate is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.Render">
            <summary>
                <para>Render the scene. Just pass the render call on to the  associated vtkRenderWindow.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.ShowCursor">
            <summary>
                <para>Hide or show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.HideCursor">
            <summary>
                <para>Hide or show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetMousePosition(System.Int32[],System.Int32[])">
            <summary>
                <para>Hide or show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.EndPickCallback">
            <summary>
                <para>These methods correspond to the the Exit, User and Pick callbacks. They allow for the Style to invoke them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.StartPickCallback">
            <summary>
                <para>These methods correspond to the the Exit, User and Pick callbacks. They allow for the Style to invoke them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.UserCallback">
            <summary>
                <para>These methods correspond to the the Exit, User and Pick callbacks. They allow for the Style to invoke them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.ExitCallback">
            <summary>
                <para>These methods correspond to the the Exit, User and Pick callbacks. They allow for the Style to invoke them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.CreateDefaultPicker">
            <summary>
                <para>Create default picker. Used to create one when none is specified. Default is an instance of vtkPropPicker.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetPicker">
            <summary>
                <para>Set/Get the object used to perform pick operations. In order to pick instances of vtkProp, the picker must be a subclass of  vtkAbstractPropPicker, meaning that it can identify a particular  instance of vtkProp.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetPicker(vtk.vtkAbstractPicker)">
            <summary>
                <para>Set/Get the object used to perform pick operations. In order to pick instances of vtkProp, the picker must be a subclass of  vtkAbstractPropPicker, meaning that it can identify a particular  instance of vtkProp.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetInitialized">
            <summary>
                <para>See whether interactor has been initialized yet.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetStillUpdateRate">
            <summary>
                <para>Set/Get the desired update rate when movement has stopped. See the SetDesiredUpdateRate method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetStillUpdateRateMaxValue">
            <summary>
                <para>Set/Get the desired update rate when movement has stopped. See the SetDesiredUpdateRate method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetStillUpdateRateMinValue">
            <summary>
                <para>Set/Get the desired update rate when movement has stopped. See the SetDesiredUpdateRate method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetStillUpdateRate(System.Double)">
            <summary>
                <para>Set/Get the desired update rate when movement has stopped. See the SetDesiredUpdateRate method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetDesiredUpdateRate">
            <summary>
                <para>Set/Get the desired update rate. This is used by vtkLODActor's to tell them how quickly they need to render.  This update is in effect only when the camera is being rotated, or zoomed.  When the interactor is still, the StillUpdateRate is used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetDesiredUpdateRateMaxValue">
            <summary>
                <para>Set/Get the desired update rate. This is used by vtkLODActor's to tell them how quickly they need to render.  This update is in effect only when the camera is being rotated, or zoomed.  When the interactor is still, the StillUpdateRate is used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetDesiredUpdateRateMinValue">
            <summary>
                <para>Set/Get the desired update rate. This is used by vtkLODActor's to tell them how quickly they need to render.  This update is in effect only when the camera is being rotated, or zoomed.  When the interactor is still, the StillUpdateRate is used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetDesiredUpdateRate(System.Double)">
            <summary>
                <para>Set/Get the desired update rate. This is used by vtkLODActor's to tell them how quickly they need to render.  This update is in effect only when the camera is being rotated, or zoomed.  When the interactor is still, the StillUpdateRate is used instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.LightFollowCameraOff">
            <summary>
                <para>Turn on/off the automatic repositioning of lights as the camera moves.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.LightFollowCameraOn">
            <summary>
                <para>Turn on/off the automatic repositioning of lights as the camera moves.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetLightFollowCamera">
            <summary>
                <para>Turn on/off the automatic repositioning of lights as the camera moves.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetLightFollowCamera(System.Int32)">
            <summary>
                <para>Turn on/off the automatic repositioning of lights as the camera moves.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetInteractorStyle">
            <summary>
                <para>External switching between joystick/trackball/new? modes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetInteractorStyle(vtk.vtkInteractorObserver)">
            <summary>
                <para>External switching between joystick/trackball/new? modes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.TerminateApp">
            <summary>
                <para>This function is called on 'q','e' keypress if exitmethod is not specified and should be overridden by platform dependent subclasses to provide a termination procedure if one is required.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.DestroyTimer">
            <summary>
                <para>Timer methods must be overridden by platform dependent subclasses. flag is passed to indicate if this is first timer set or an update as Win32 uses repeating timers, whereas X uses One shot more timer if flag==VTKXI_TIMER_FIRST Win32 and X should createtimer otherwise Win32 should exit and X should perform AddTimeOut()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.CreateTimer(System.Int32)">
            <summary>
                <para>Timer methods must be overridden by platform dependent subclasses. flag is passed to indicate if this is first timer set or an update as Win32 uses repeating timers, whereas X uses One shot more timer if flag==VTKXI_TIMER_FIRST Win32 and X should createtimer otherwise Win32 should exit and X should perform AddTimeOut()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.UpdateSize(System.Int32,System.Int32)">
            <summary>
                <para>Event loop notification member for Window size change</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetRenderWindow">
            <summary>
                <para>Set/Get the rendering window being controlled by this object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.SetRenderWindow(vtk.vtkRenderWindow)">
            <summary>
                <para>Set/Get the rendering window being controlled by this object.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.GetEnabled">
            <summary>
                <para>Enable/Disable interactions.  By default interactors are enabled when initialized.  Initialize() must be called prior to enabling/disabling interaction. These methods are used when a window/widget is being shared by multiple renderers and interactors.  This allows a "modal" display where one interactor is active when its data is to be displayed and all other interactors associated with the widget are disabled when their data is not displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.Disable">
            <summary>
                <para>Enable/Disable interactions.  By default interactors are enabled when initialized.  Initialize() must be called prior to enabling/disabling interaction. These methods are used when a window/widget is being shared by multiple renderers and interactors.  This allows a "modal" display where one interactor is active when its data is to be displayed and all other interactors associated with the widget are disabled when their data is not displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.Enable">
            <summary>
                <para>Enable/Disable interactions.  By default interactors are enabled when initialized.  Initialize() must be called prior to enabling/disabling interaction. These methods are used when a window/widget is being shared by multiple renderers and interactors.  This allows a "modal" display where one interactor is active when its data is to be displayed and all other interactors associated with the widget are disabled when their data is not displayed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.Start">
            <summary>
                <para>Start the event loop. This is provided so that you do not have to implement your own event loop. You still can use your own event loop if you want. Initialize should be called before Start.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>This Method detects loops of RenderWindow-Interactor, so objects are freed properly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.ReInitialize">
            <summary>
                <para>This Method detects loops of RenderWindow-Interactor, so objects are freed properly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindowInteractor.Initialize">
            <summary>
                <para>Prepare for handling events. This must be called before the interactor will work.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAbstractPicker.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.DeletePickList(vtk.vtkProp)">
            <summary>
                <para>Delete an actor from the pick list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.AddPickList(vtk.vtkProp)">
            <summary>
                <para>Add an actor to the pick list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.InitializePickList">
            <summary>
                <para>Initialize list of actors in pick list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.PickFromListOff">
            <summary>
                <para>Use these methods to control whether to limit the picking to this list (rather than renderer's actors). Make sure that the pick list contains  actors that referred to by the picker's renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.PickFromListOn">
            <summary>
                <para>Use these methods to control whether to limit the picking to this list (rather than renderer's actors). Make sure that the pick list contains  actors that referred to by the picker's renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.GetPickFromList">
            <summary>
                <para>Use these methods to control whether to limit the picking to this list (rather than renderer's actors). Make sure that the pick list contains  actors that referred to by the picker's renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.SetPickFromList(System.Int32)">
            <summary>
                <para>Use these methods to control whether to limit the picking to this list (rather than renderer's actors). Make sure that the pick list contains  actors that referred to by the picker's renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.Pick(System.Double[],vtk.vtkRenderer)">
            <summary>
                <para>provided. Normally the first two values for the selection point are x-y pixel coordinate, and the third value is =0. Return non-zero if something was successfully picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.Pick(System.Double,System.Double,System.Double,vtk.vtkRenderer)">
            <summary>
                <para>Perform pick operation with selection point provided. Normally the  first two values for the selection point are x-y pixel coordinate, and the third value is =0. Return non-zero if something was successfully  picked.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.GetPickPosition">
            <summary>
                <para>Return position in global coordinates of pick point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.GetSelectionPoint">
            <summary>
                <para>Get the selection point in screen (pixel) coordinates. The third value is related to z-buffer depth. (Normally should be =0.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAbstractPicker.GetRenderer">
            <summary>
                <para>Get the renderer in which pick event occurred.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRenderer.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVolumeCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVolumeCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVolumeCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVolumeCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVolumeCollection.GetNextItem">
            <summary>
                <para>Access routine provided for compatibility with previous versions of VTK.  Please use the GetNextVolume() variant where possible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeCollection.GetNextVolume">
            <summary>
                <para>Get the next Volume in the list. Return NULL when at the end of the  list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVolumeCollection.AddItem(vtk.vtkVolume)">
            <summary>
                <para>Add a Volume to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRenderWindow.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetDepthBufferSize">
            <summary>
                <para>This method should be defined by the subclass. How many bits of precision are there in the zbuffer?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.IsDirect">
            <summary>
                <para>Is this render window using hardware acceleration? 0-false, 1-true</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SupportsOpenGL">
            <summary>
                <para>Does this render window support OpenGL? 0-false, 1-true</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.ReportCapabilities">
            <summary>
                <para>Get report of capabilities for the render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetForceMakeCurrent">
            <summary>
                <para>If called, allow MakeCurrent() to skip cache-check when called. MakeCurrent() reverts to original behavior of cache-checking on the next render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.MakeCurrent">
            <summary>
                <para>Make this the current window. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetParentInfo(System.String)">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetNextWindowInfo(System.String)">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetWindowInfo(System.String)">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetGenericDrawable">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetGenericContext">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetGenericParentId">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetGenericWindowId">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetGenericDisplayId">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetParentId(System.IntPtr)">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetNextWindowId(System.IntPtr)">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetWindowId(System.IntPtr)">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetDisplayId(System.IntPtr)">
            <summary>
                <para>Dummy stubs for vtkWindow API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.UnRegister(vtk.vtkObjectBase)">
            <summary>
                <para>This Method detects loops of RenderWindow&lt;-&gt;Interactor, so objects are freed properly.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetInteractor(vtk.vtkRenderWindowInteractor)">
            <summary>
                <para>Set the interactor to the render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetInteractor">
            <summary>
                <para>Get the interactor associated with this render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetNumberOfLayersMaxValue">
            <summary>
                <para>Get the number of layers for renderers.  Each renderer should have its layer set individually.  Some algorithms iterate through all layers, so it is not wise to set the number of layers to be exorbitantly large (say bigger than 100).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetNumberOfLayersMinValue">
            <summary>
                <para>Get the number of layers for renderers.  Each renderer should have its layer set individually.  Some algorithms iterate through all layers, so it is not wise to set the number of layers to be exorbitantly large (say bigger than 100).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetNumberOfLayers(System.Int32)">
            <summary>
                <para>Get the number of layers for renderers.  Each renderer should have its layer set individually.  Some algorithms iterate through all layers, so it is not wise to set the number of layers to be exorbitantly large (say bigger than 100).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetNumberOfLayers">
            <summary>
                <para>Get the number of layers for renderers.  Each renderer should have its layer set individually.  Some algorithms iterate through all layers, so it is not wise to set the number of layers to be exorbitantly large (say bigger than 100).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetDesiredUpdateRate">
            <summary>
                <para>Set/Get the desired update rate. This is used with the vtkLODActor class. When using level of detail actors you need to specify what update rate you require. The LODActors then will pick the correct resolution to meet your desired update rate in frames per second. A value of zero indicates that they can use all the time they want to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetDesiredUpdateRate(System.Double)">
            <summary>
                <para>Set/Get the desired update rate. This is used with the vtkLODActor class. When using level of detail actors you need to specify what update rate you require. The LODActors then will pick the correct resolution to meet your desired update rate in frames per second. A value of zero indicates that they can use all the time they want to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.ClearInRenderStatus">
            <summary>
                <para>Set/Get the desired update rate. This is used with the vtkLODActor class. When using level of detail actors you need to specify what update rate you require. The LODActors then will pick the correct resolution to meet your desired update rate in frames per second. A value of zero indicates that they can use all the time they want to.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.CheckInRenderStatus">
            <summary>
                <para>Clear status (after an exception was thrown for example)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetEventPending">
            <summary>
                <para>Check to see if a mouse button has been pressed.  All other events are ignored by this method.  Ideally, you want to abort the render on any event which causes the DesiredUpdateRate to switch from a high-quality rate to a more interactive rate.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.CheckAbortStatus">
            <summary>
                <para>This is a flag that can be set to interrupt a rendering that is in progress.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetInAbortCheck(System.Int32)">
            <summary>
                <para>This is a flag that can be set to interrupt a rendering that is in progress.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetInAbortCheck">
            <summary>
                <para>This is a flag that can be set to interrupt a rendering that is in progress.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetAbortRender(System.Int32)">
            <summary>
                <para>This is a flag that can be set to interrupt a rendering that is in progress.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetAbortRender">
            <summary>
                <para>This is a flag that can be set to interrupt a rendering that is in progress.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetNeverRendered">
            <summary>
                <para>This flag is set if the window hasn't rendered since it was created</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetSubFrames(System.Int32)">
            <summary>
                <para>Set the number of sub frames for doing motion blur. The default is zero. Once this is set greater than one, you will no longer see a new frame for every Render().  If you set this to five, you will need to do  five Render() invocations before seeing the result. This isn't very impressive unless something is changing between the Renders. Changing this value may reset the current subframe count.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetSubFrames">
            <summary>
                <para>Set the number of sub frames for doing motion blur. The default is zero. Once this is set greater than one, you will no longer see a new frame for every Render().  If you set this to five, you will need to do  five Render() invocations before seeing the result. This isn't very impressive unless something is changing between the Renders. Changing this value may reset the current subframe count.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetFDFrames(System.Int32)">
            <summary>
                <para>Set the number of frames for doing focal depth. The default is zero. Depending on how your scene is organized you can get away with as few as four frames for focal depth or you might need thirty. One thing to note is that if you are using focal depth frames, then you will not need many (if any) frames for antialiasing. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetFDFrames">
            <summary>
                <para>Set the number of frames for doing focal depth. The default is zero. Depending on how your scene is organized you can get away with as few as four frames for focal depth or you might need thirty. One thing to note is that if you are using focal depth frames, then you will not need many (if any) frames for antialiasing. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetAAFrames(System.Int32)">
            <summary>
                <para>Set the number of frames for doing antialiasing. The default is zero. Typically five or six will yield reasonable results without taking too long.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetAAFrames">
            <summary>
                <para>Set the number of frames for doing antialiasing. The default is zero. Typically five or six will yield reasonable results without taking too long.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetZbufferData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkFloatArray)">
            <summary>
                <para>Set/Get the zbuffer data from the frame buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetZbufferData(System.Int32,System.Int32,System.Int32,System.Int32,System.Single[])">
            <summary>
                <para>Set/Get the zbuffer data from the frame buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetZbufferData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkFloatArray)">
            <summary>
                <para>Set/Get the zbuffer data from the frame buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetZbufferData(System.Int32,System.Int32,System.Int32,System.Int32,System.Single[])">
            <summary>
                <para>Set/Get the zbuffer data from the frame buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetRGBACharPixelData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkUnsignedCharArray,System.Int32,System.Int32)">
            <summary>
                <para>Same as Get/SetPixelData except that the image also contains an alpha component. The image is transmitted as RGBARGBARGBA... each of which is a float value. The "blend" parameter controls whether the SetRGBAPixelData method blends the data with the previous contents of the frame buffer or completely replaces the frame buffer data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetRGBACharPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
                <para>Same as Get/SetPixelData except that the image also contains an alpha component. The image is transmitted as RGBARGBARGBA... each of which is a float value. The "blend" parameter controls whether the SetRGBAPixelData method blends the data with the previous contents of the frame buffer or completely replaces the frame buffer data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetRGBACharPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkUnsignedCharArray)">
            <summary>
                <para>Same as Get/SetPixelData except that the image also contains an alpha component. The image is transmitted as RGBARGBARGBA... each of which is a float value. The "blend" parameter controls whether the SetRGBAPixelData method blends the data with the previous contents of the frame buffer or completely replaces the frame buffer data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.ReleaseRGBAPixelData(System.Single[])">
            <summary>
                <para>Same as Get/SetPixelData except that the image also contains an alpha component. The image is transmitted as RGBARGBARGBA... each of which is a float value. The "blend" parameter controls whether the SetRGBAPixelData method blends the data with the previous contents of the frame buffer or completely replaces the frame buffer data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetRGBAPixelData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkFloatArray,System.Int32,System.Int32)">
            <summary>
                <para>Same as Get/SetPixelData except that the image also contains an alpha component. The image is transmitted as RGBARGBARGBA... each of which is a float value. The "blend" parameter controls whether the SetRGBAPixelData method blends the data with the previous contents of the frame buffer or completely replaces the frame buffer data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetRGBAPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Int32)">
            <summary>
                <para>Same as Get/SetPixelData except that the image also contains an alpha component. The image is transmitted as RGBARGBARGBA... each of which is a float value. The "blend" parameter controls whether the SetRGBAPixelData method blends the data with the previous contents of the frame buffer or completely replaces the frame buffer data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetRGBAPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkFloatArray)">
            <summary>
                <para>Same as Get/SetPixelData except that the image also contains an alpha component. The image is transmitted as RGBARGBARGBA... each of which is a float value. The "blend" parameter controls whether the SetRGBAPixelData method blends the data with the previous contents of the frame buffer or completely replaces the frame buffer data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetPixelData(System.Int32,System.Int32,System.Int32,System.Int32,vtk.vtkUnsignedCharArray,System.Int32)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBRGBRGB. The front argument indicates if the front buffer should be used or the back  buffer. It is the caller's responsibility to delete the resulting  array. It is very important to realize that the memory in this array is organized from the bottom of the window to the top. The origin of the screen is in the lower left corner. The y axis increases as you go up the screen. So the storage of pixels is from left to right and from bottom to top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetPixelData(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
                <para>Set/Get the pixel data of an image, transmitted as RGBRGBRGB. The front argument indicates if the front buffer should be used or the back  buffer. It is the caller's responsibility to delete the resulting  array. It is very important to realize that the memory in this array is organized from the bottom of the window to the top. The origin of the screen is in the lower left corner. The y axis increases as you go up the screen. So the storage of pixels is from left to right and from bottom to top.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SwapBuffersOff">
            <summary>
                <para>Turn on/off buffer swapping between images. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SwapBuffersOn">
            <summary>
                <para>Turn on/off buffer swapping between images. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetSwapBuffers">
            <summary>
                <para>Turn on/off buffer swapping between images. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetSwapBuffers(System.Int32)">
            <summary>
                <para>Turn on/off buffer swapping between images. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.WindowRemap">
            <summary>
                <para>Remap the rendering window. This probably only works on UNIX right now. It is useful for changing properties that can't normally be changed once the window is up.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.StereoRenderComplete">
            <summary>
                <para>Handles work required once both views have been rendered when using stereo rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.StereoMidpoint">
            <summary>
                <para>Intermediate method performs operations required between the rendering of the left and right eye.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.StereoUpdate">
            <summary>
                <para>Update the system, if needed, due to stereo rendering. For some stereo  methods, subclasses might need to switch some hardware settings here.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetStereoTypeAsString">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoTypeToAnaglyph">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoTypeToDresden">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoTypeToRight">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoTypeToLeft">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoTypeToInterlaced">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoTypeToRedBlue">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoTypeToCrystalEyes">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoType(System.Int32)">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetStereoType">
            <summary>
                <para>Set/Get what type of stereo rendering to use.  CrystalEyes mode uses frame-sequential capabilities available in OpenGL to drive LCD shutter glasses and stereo projectors.  RedBlue mode is a simple type of stereo for use with red-blue glasses. Anaglyph mode is a superset of RedBlue mode, but the color output channels can be configured using the AnaglyphColorMask and the color of the original image can be (somewhat) maintained using AnaglyphColorSaturation;  the default colors for Anaglyph mode is red-cyan.  Interlaced stereo mode produces a composite image where horizontal lines alternate between left and right views.  StereoLeft and StereoRight modes choose one or the other stereo view.  Dresden mode is yet another stereoscopic  interleaving.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.PolygonSmoothingOff">
            <summary>
                <para>Turn on/off polygon smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.PolygonSmoothingOn">
            <summary>
                <para>Turn on/off polygon smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetPolygonSmoothing">
            <summary>
                <para>Turn on/off polygon smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetPolygonSmoothing(System.Int32)">
            <summary>
                <para>Turn on/off polygon smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.LineSmoothingOff">
            <summary>
                <para>Turn on/off line smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.LineSmoothingOn">
            <summary>
                <para>Turn on/off line smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetLineSmoothing">
            <summary>
                <para>Turn on/off line smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetLineSmoothing(System.Int32)">
            <summary>
                <para>Turn on/off line smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.PointSmoothingOff">
            <summary>
                <para>Turn on/off point smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.PointSmoothingOn">
            <summary>
                <para>Turn on/off point smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetPointSmoothing">
            <summary>
                <para>Turn on/off point smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetPointSmoothing(System.Int32)">
            <summary>
                <para>Turn on/off point smoothing. Default is off. This must be applied before the first Render.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.AlphaBitPlanesOff">
            <summary>
                <para>Turn on/off the use of alpha bitplanes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.AlphaBitPlanesOn">
            <summary>
                <para>Turn on/off the use of alpha bitplanes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetAlphaBitPlanes">
            <summary>
                <para>Turn on/off the use of alpha bitplanes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetAlphaBitPlanes(System.Int32)">
            <summary>
                <para>Turn on/off the use of alpha bitplanes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.StereoRenderOff">
            <summary>
                <para>Turn on/off stereo rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.StereoRenderOn">
            <summary>
                <para>Turn on/off stereo rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoRender(System.Int32)">
            <summary>
                <para>Turn on/off stereo rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetStereoRender">
            <summary>
                <para>Turn on/off stereo rendering.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetStereoCapableWindow(System.Int32)">
            <summary>
                <para>Prescribe that the window be created in a stereo-capable mode. This method must be called before the window is realized. Default is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.StereoCapableWindowOff">
            <summary>
                <para>Prescribe that the window be created in a stereo-capable mode. This method must be called before the window is realized. Default is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.StereoCapableWindowOn">
            <summary>
                <para>Prescribe that the window be created in a stereo-capable mode. This method must be called before the window is realized. Default is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetStereoCapableWindow">
            <summary>
                <para>Prescribe that the window be created in a stereo-capable mode. This method must be called before the window is realized. Default is off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.BordersOff">
            <summary>
                <para>Turn on/off window manager borders. Typically, you shouldn't turn the  borders off, because that bypasses the window manager and can cause undesirable behavior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.BordersOn">
            <summary>
                <para>Turn on/off window manager borders. Typically, you shouldn't turn the  borders off, because that bypasses the window manager and can cause undesirable behavior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetBorders">
            <summary>
                <para>Turn on/off window manager borders. Typically, you shouldn't turn the  borders off, because that bypasses the window manager and can cause undesirable behavior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetBorders(System.Int32)">
            <summary>
                <para>Turn on/off window manager borders. Typically, you shouldn't turn the  borders off, because that bypasses the window manager and can cause undesirable behavior.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.FullScreenOff">
            <summary>
                <para>Turn on/off rendering full screen window size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.FullScreenOn">
            <summary>
                <para>Turn on/off rendering full screen window size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetFullScreen">
            <summary>
                <para>Turn on/off rendering full screen window size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetFullScreen(System.Int32)">
            <summary>
                <para>Turn on/off rendering full screen window size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetCurrentCursor">
            <summary>
                <para>Change the shape of the cursor</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetCurrentCursor(System.Int32)">
            <summary>
                <para>Change the shape of the cursor</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.SetCursorPosition(System.Int32,System.Int32)">
            <summary>
                <para>Hide or Show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead. Set cursor position in window (note that (0,0) is the lower left  corner).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.ShowCursor">
            <summary>
                <para>Hide or Show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead. Set cursor position in window (note that (0,0) is the lower left  corner).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.HideCursor">
            <summary>
                <para>Hide or Show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead. Set cursor position in window (note that (0,0) is the lower left  corner).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.MakeRenderWindowInteractor">
            <summary>
                <para>Create an interactor to control renderers in this window. We need to know what type of interactor to create, because we might be in X Windows or MS Windows. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.CopyResultFrame">
            <summary>
                <para>Performed at the end of the rendering process to generate image. This is typically done right before swapping buffers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.Frame">
            <summary>
                <para>A termination method performed at the end of the rendering process to do things like swapping buffers (if necessary) or similar actions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.FinalizeWrap">
            <summary>
                <para>Finalize the rendering process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.Start">
            <summary>
                <para>Initialize the rendering process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.Render">
            <summary>
                <para>Ask each renderer owned by this RenderWindow to render its image and  synchronize this process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetRenderers">
            <summary>
                <para>Return the collection of renderers in the render window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.GetRenderLibrary">
            <summary>
                <para>What rendering library has the user requested</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.HasRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Query if a renderer is in the list of renderers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.RemoveRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Remove a renderer from the list of renderers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderWindow.AddRenderer(vtk.vtkRenderer)">
            <summary>
                <para>Add a renderer to the list of renderers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLightCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLightCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLightCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLightCollection.GetNextItem">
            <summary>
                <para>Get the next light in the list. NULL is returned when the collection is  exhausted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLightCollection.AddItem(vtk.vtkLight)">
            <summary>
                <para>Add a light to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLight.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLight.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLight.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLight.LightTypeIsCameraLight">
            <summary>
                <para>Query the type of the light.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.LightTypeIsSceneLight">
            <summary>
                <para>Query the type of the light.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.LightTypeIsHeadlight">
            <summary>
                <para>Query the type of the light.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetLightTypeToCameraLight">
            <summary>
                <para>Query the type of the light.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetLightTypeToSceneLight">
            <summary>
                <para>Set/Get the type of the light. A SceneLight is a light located in the world coordinate space.  A light is initially created as a scene light.</para>
                <para>A Headlight is always located at the camera and is pointed at the  camera's focal point.  The renderer is free to modify the position and focal point of the camera at any time.</para>
                <para>A CameraLight is also attached to the camera, but is not necessarily located at the camera's position.  CameraLights are defined in a  coordinate space where the camera is located at (0, 0, 1), looking towards (0, 0, 0) at a distance of 1, with up being (0, 1, 0).</para>
                <para>Note: Use SetLightTypeToSceneLight, rather than SetLightType(3), since the former clears the light's transform matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetLightTypeToHeadlight">
            <summary>
                <para>Set/Get the type of the light. A SceneLight is a light located in the world coordinate space.  A light is initially created as a scene light.</para>
                <para>A Headlight is always located at the camera and is pointed at the  camera's focal point.  The renderer is free to modify the position and focal point of the camera at any time.</para>
                <para>A CameraLight is also attached to the camera, but is not necessarily located at the camera's position.  CameraLights are defined in a  coordinate space where the camera is located at (0, 0, 1), looking towards (0, 0, 0) at a distance of 1, with up being (0, 1, 0).</para>
                <para>Note: Use SetLightTypeToSceneLight, rather than SetLightType(3), since the former clears the light's transform matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetLightType">
            <summary>
                <para>Set/Get the type of the light. A SceneLight is a light located in the world coordinate space.  A light is initially created as a scene light.</para>
                <para>A Headlight is always located at the camera and is pointed at the  camera's focal point.  The renderer is free to modify the position and focal point of the camera at any time.</para>
                <para>A CameraLight is also attached to the camera, but is not necessarily located at the camera's position.  CameraLights are defined in a  coordinate space where the camera is located at (0, 0, 1), looking towards (0, 0, 0) at a distance of 1, with up being (0, 1, 0).</para>
                <para>Note: Use SetLightTypeToSceneLight, rather than SetLightType(3), since the former clears the light's transform matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetLightType(System.Int32)">
            <summary>
                <para>Set/Get the type of the light. A SceneLight is a light located in the world coordinate space.  A light is initially created as a scene light.</para>
                <para>A Headlight is always located at the camera and is pointed at the  camera's focal point.  The renderer is free to modify the position and focal point of the camera at any time.</para>
                <para>A CameraLight is also attached to the camera, but is not necessarily located at the camera's position.  CameraLights are defined in a  coordinate space where the camera is located at (0, 0, 1), looking towards (0, 0, 0) at a distance of 1, with up being (0, 1, 0).</para>
                <para>Note: Use SetLightTypeToSceneLight, rather than SetLightType(3), since the former clears the light's transform matrix.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.DeepCopy(vtk.vtkLight)">
            <summary>
                <para>Perform deep copy of this light.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetDirectionAngle(System.Double[])">
            <summary>
                <para>Set the position and focal point of a light based on elevation and azimuth.  The light is moved so it is shining from the given angle. Angles are given in degrees.  If the light is a positional light, it is made directional instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetDirectionAngle(System.Double,System.Double)">
            <summary>
                <para>Set the position and focal point of a light based on elevation and azimuth.  The light is moved so it is shining from the given angle. Angles are given in degrees.  If the light is a positional light, it is made directional instead.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetTransformedFocalPoint">
            <summary>
                <para>Get the focal point of the light, modified by the transformation matrix (if it exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetTransformedFocalPoint(System.Double[])">
            <summary>
                <para>Get the focal point of the light, modified by the transformation matrix (if it exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetTransformedFocalPoint(System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>Get the focal point of the light, modified by the transformation matrix (if it exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetTransformedPosition">
            <summary>
                <para>Get the position of the light, modified by the transformation matrix (if it exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetTransformedPosition(System.Double[])">
            <summary>
                <para>Get the position of the light, modified by the transformation matrix (if it exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetTransformedPosition(System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>Get the position of the light, modified by the transformation matrix (if it exists).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetTransformMatrix">
            <summary>
                <para>Set/Get the light's transformation matrix.  If a matrix is set for a light, the light's parameters (position and focal point) are  transformed by the matrix before being rendered.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetTransformMatrix(vtk.vtkMatrix4x4)">
            <summary>
                <para>Set/Get the light's transformation matrix.  If a matrix is set for a light, the light's parameters (position and focal point) are  transformed by the matrix before being rendered.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetAttenuationValues">
            <summary>
                <para>Set/Get the quadratic attenuation constants. They are specified as constant, linear, and quadratic, in that order.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetAttenuationValues(System.Double[])">
            <summary>
                <para>Set/Get the quadratic attenuation constants. They are specified as constant, linear, and quadratic, in that order.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetAttenuationValues(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the quadratic attenuation constants. They are specified as constant, linear, and quadratic, in that order.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetConeAngle">
            <summary>
                <para>Set/Get the lighting cone angle of a positional light in degrees. A value of 180 indicates that you want no spot lighting effects just a positional light.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetConeAngle(System.Double)">
            <summary>
                <para>Set/Get the lighting cone angle of a positional light in degrees. A value of 180 indicates that you want no spot lighting effects just a positional light.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetExponent">
            <summary>
                <para>Set/Get the exponent of the cosine used in positional lighting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetExponent(System.Double)">
            <summary>
                <para>Set/Get the exponent of the cosine used in positional lighting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.PositionalOff">
            <summary>
                <para>Turn positional lighting on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.PositionalOn">
            <summary>
                <para>Turn positional lighting on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetPositional">
            <summary>
                <para>Turn positional lighting on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetPositional(System.Int32)">
            <summary>
                <para>Turn positional lighting on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SwitchOff">
            <summary>
                <para>Turn the light on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SwitchOn">
            <summary>
                <para>Turn the light on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetSwitch">
            <summary>
                <para>Turn the light on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetSwitch(System.Int32)">
            <summary>
                <para>Turn the light on or off.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetIntensity">
            <summary>
                <para>Set/Get the brightness of the light (from one to zero).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetIntensity(System.Double)">
            <summary>
                <para>Set/Get the brightness of the light (from one to zero).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetFocalPoint(System.Single[])">
            <summary>
                <para>Set/Get the point at which the light is shining. Note: The focal point of the light is defined in the coordinate space indicated by its transformation matrix (if it exists). Thus, to get the light's world space focal point, use  vtkGetTransformedFocalPoint() instead of vtkGetFocalPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetFocalPoint">
            <summary>
                <para>Set/Get the point at which the light is shining. Note: The focal point of the light is defined in the coordinate space indicated by its transformation matrix (if it exists). Thus, to get the light's world space focal point, use  vtkGetTransformedFocalPoint() instead of vtkGetFocalPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetFocalPoint(System.Double[])">
            <summary>
                <para>Set/Get the point at which the light is shining. Note: The focal point of the light is defined in the coordinate space indicated by its transformation matrix (if it exists). Thus, to get the light's world space focal point, use  vtkGetTransformedFocalPoint() instead of vtkGetFocalPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetFocalPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the point at which the light is shining. Note: The focal point of the light is defined in the coordinate space indicated by its transformation matrix (if it exists). Thus, to get the light's world space focal point, use  vtkGetTransformedFocalPoint() instead of vtkGetFocalPoint().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetPosition(System.Single[])">
            <summary>
                <para>Set/Get the position of the light. Note: The position of the light is defined in the coordinate space indicated by its transformation matrix (if it exists). Thus, to get the light's world space position, use  vtkGetTransformedPosition() instead of vtkGetPosition().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetPosition">
            <summary>
                <para>Set/Get the position of the light. Note: The position of the light is defined in the coordinate space indicated by its transformation matrix (if it exists). Thus, to get the light's world space position, use  vtkGetTransformedPosition() instead of vtkGetPosition().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetPosition(System.Double[])">
            <summary>
                <para>Set/Get the position of the light. Note: The position of the light is defined in the coordinate space indicated by its transformation matrix (if it exists). Thus, to get the light's world space position, use  vtkGetTransformedPosition() instead of vtkGetPosition().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the position of the light. Note: The position of the light is defined in the coordinate space indicated by its transformation matrix (if it exists). Thus, to get the light's world space position, use  vtkGetTransformedPosition() instead of vtkGetPosition().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetColor">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetColor(System.Double[])">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetColor(System.Double[])">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetSpecularColor">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetSpecularColor(System.Double[])">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetSpecularColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetDiffuseColor">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetDiffuseColor(System.Double[])">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetDiffuseColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.GetAmbientColor">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetAmbientColor(System.Double[])">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.SetAmbientColor(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the color of the light. It is possible to set the ambient, diffuse and specular colors separately. The SetColor() method sets the diffuse and specular colors to the same color (this is a feature to preserve backward compatbility.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLight.Render(vtk.vtkRenderer,System.Int32)">
            <summary>
                <para>Abstract interface to renderer. Each concrete subclass of vtkLight will load its data into the graphics system in response to this method invocation. The actual loading is performed by a vtkLightDevice subclass, which will get created automatically.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCullerCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCullerCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCullerCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCullerCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCullerCollection.GetLastItem">
            <summary>
                <para>Get the last Culler in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCullerCollection.GetNextItem">
            <summary>
                <para>Get the next Culler in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCullerCollection.AddItem(vtk.vtkCuller)">
            <summary>
                <para>Add an Culler to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCuller.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCuller.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCuller.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCuller.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCamera.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCamera.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCamera.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCamera.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCamera.GetCameraLightTransformMatrix">
            <summary>
                <para>Returns a transformation matrix for a coordinate frame attached to the camera, where the camera is located at (0, 0, 1) looking at the focal point at (0, 0, 0), with up being (0, 1, 0).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.ComputeViewPlaneNormal">
            <summary>
                <para>This method is called automatically whenever necessary, it should never be used outside of vtkCamera.cxx.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetViewPlaneNormal(System.Double[])">
            <summary>
                <para>These methods have been deprecated.  The view plane normal is  automatically set from the DirectionOfProjection according to the ViewShear.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetViewPlaneNormal(System.Double,System.Double,System.Double)">
            <summary>
                <para>These methods have been deprecated.  The view plane normal is  automatically set from the DirectionOfProjection according to the ViewShear.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetOrientationWXYZ">
            <summary>
                <para>Get the orientation of the camera.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetOrientation">
            <summary>
                <para>Get the orientation of the camera.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetFrustumPlanes(System.Double,System.Double[])">
            <summary>
                <para>Get the plane equations that bound the view frustum. The plane normals point inward. The planes array contains six plane equations of the form (Ax+By+Cz+D=0), the first four values are (A,B,C,D) which repeats for each of the planes. The aspect of the viewport is needed to correctly compute the planes</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.ViewingRaysModified">
            <summary>
                <para>Mark that something has changed which requires the view rays to be recomputed.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetViewingRaysMTime">
            <summary>
                <para>Return the MTime that concerns recomputing the view rays of the camera.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.Render(vtk.vtkRenderer)">
            <summary>
                <para>This method causes the camera to set up whatever is required for viewing the scene. This is actually handled by an subclass of vtkCamera, which is created through New()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetUserTransform">
            <summary>
                <para>In addition to the instance variables such as position and orientation, you can add an additional transformation for your own use.  This  transformation is concatenated to the camera's PerspectiveTransform</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetUserTransform(vtk.vtkHomogeneousTransform)">
            <summary>
                <para>In addition to the instance variables such as position and orientation, you can add an additional transformation for your own use.  This  transformation is concatenated to the camera's PerspectiveTransform</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetCompositePerspectiveTransformMatrix(System.Double,System.Double,System.Double)">
            <summary>
                <para>Return the concatenation of the ViewTransform and the  PerspectiveTransform.  This transform will convert world coordinates to view coordinates.  The 'aspect' is the width/height for the viewport, and the nearz and farz are the Z-buffer values that map to the near and far clipping planes. The view coordinates are in the range ([-1,+1],[-1,+1],[nearz,farz]).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetPerspectiveTransformMatrix(System.Double,System.Double,System.Double)">
            <summary>
                <para>Return the perspective transform matrix, which converts from camera coordinates to viewport coordinates.  The 'aspect' is the width/height for the viewport, and the nearz and farz are the Z-buffer values that map to the near and far clipping planes. The viewport coordinates are in the range ([-1,+1],[-1,+1],[nearz,farz]).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetViewTransformMatrix">
            <summary>
                <para>Return the matrix of the view transform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetFocalDisk">
            <summary>
                <para>Set the size of the cameras lens in world coordinates. This is only  used when the renderer is doing focal depth rendering. When that is  being done the size of the focal disk will effect how significant the depth effects will be.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetFocalDisk(System.Double)">
            <summary>
                <para>Set the size of the cameras lens in world coordinates. This is only  used when the renderer is doing focal depth rendering. When that is  being done the size of the focal disk will effect how significant the depth effects will be.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetEyeAngle">
            <summary>
                <para>Set/Get the separation between eyes (in degrees). This is used when generating stereo images.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetEyeAngle(System.Double)">
            <summary>
                <para>Set/Get the separation between eyes (in degrees). This is used when generating stereo images.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetViewShear">
            <summary>
                <para>Set/get the shear transform of the viewing frustum.  Parameters are dx/dz, dy/dz, and center.  center is a factor that describes where to shear around. The distance dshear from the camera where no shear occurs is given by (dshear = center * FocalDistance).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetViewShear(System.Double[])">
            <summary>
                <para>Set/get the shear transform of the viewing frustum.  Parameters are dx/dz, dy/dz, and center.  center is a factor that describes where to shear around. The distance dshear from the camera where no shear occurs is given by (dshear = center * FocalDistance).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetViewShear(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/get the shear transform of the viewing frustum.  Parameters are dx/dz, dy/dz, and center.  center is a factor that describes where to shear around. The distance dshear from the camera where no shear occurs is given by (dshear = center * FocalDistance).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetViewPlaneNormal">
            <summary>
                <para>Get the ViewPlaneNormal.  This vector will point opposite to the direction of projection, unless you have created an sheared output view using SetViewShear/SetObliqueAngles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.ApplyTransform(vtk.vtkTransform)">
            <summary>
                <para>Apply a transform to the camera.  The camera position, focal-point, and view-up are re-calulated using the transform's matrix to multiply the old points by the new transform.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetObliqueAngles(System.Double,System.Double)">
            <summary>
                <para>Get/Set the oblique viewing angles.  The first angle, alpha, is the angle (measured from the horizontal) that rays along the direction of projection will follow once projected onto the 2D screen.   The second angle, beta, is the angle between the view plane and the direction of projection.  This creates a shear transform x' = x + dz*cos(alpha)/tan(beta), y' = dz*sin(alpha)/tan(beta) where dz is the distance of the point from the focal plane. The angles are (45,90) by default.  Oblique projections  commonly use (30,63.435).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetWindowCenter">
            <summary>
                <para>Set/Get the center of the window in viewport coordinates. The viewport coordinate range is ([-1,+1],[-1,+1]).  This method is for if you have one window which consists of several viewports, or if you have several screens which you want to act together as one large screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetWindowCenter(System.Double,System.Double)">
            <summary>
                <para>Set/Get the center of the window in viewport coordinates. The viewport coordinate range is ([-1,+1],[-1,+1]).  This method is for if you have one window which consists of several viewports, or if you have several screens which you want to act together as one large screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetThickness">
            <summary>
                <para>Set the distance between clipping planes.  This method adjusts the  far clipping plane to be set a distance 'thickness' beyond the near clipping plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetThickness(System.Double)">
            <summary>
                <para>Set the distance between clipping planes.  This method adjusts the  far clipping plane to be set a distance 'thickness' beyond the near clipping plane.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetClippingRange">
            <summary>
                <para>Set/Get the location of the near and far clipping planes along the direction of projection.  Both of these values must be positive. How the clipping planes are set can have a large impact on how  well z-buffering works.  In particular the front clipping plane can make a very big difference. Setting it to 0.01 when it really could be 1.0 can have a big impact on your z-buffer resolution farther away.  The default clipping range is (0.1,1000).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetClippingRange(System.Double[])">
            <summary>
                <para>Set/Get the location of the near and far clipping planes along the direction of projection.  Both of these values must be positive. How the clipping planes are set can have a large impact on how  well z-buffering works.  In particular the front clipping plane can make a very big difference. Setting it to 0.01 when it really could be 1.0 can have a big impact on your z-buffer resolution farther away.  The default clipping range is (0.1,1000).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetClippingRange(System.Double,System.Double)">
            <summary>
                <para>Set/Get the location of the near and far clipping planes along the direction of projection.  Both of these values must be positive. How the clipping planes are set can have a large impact on how  well z-buffering works.  In particular the front clipping plane can make a very big difference. Setting it to 0.01 when it really could be 1.0 can have a big impact on your z-buffer resolution farther away.  The default clipping range is (0.1,1000).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.Zoom(System.Double)">
            <summary>
                <para>In perspective mode, decrease the view angle by the specified factor. In parallel mode, decrease the parallel scale by the specified factor. A value greater than 1 is a zoom-in, a  value less than 1 is a zoom-out.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetParallelScale">
            <summary>
                <para>Set/Get the scaling used for a parallel projection, i.e. the height of the viewport in world-coordinate distances. The default is 1. Note that the "scale" parameter works as an "inverse scale" --- larger numbers produce smaller images. This method has no effect in perspective projection mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetParallelScale(System.Double)">
            <summary>
                <para>Set/Get the scaling used for a parallel projection, i.e. the height of the viewport in world-coordinate distances. The default is 1. Note that the "scale" parameter works as an "inverse scale" --- larger numbers produce smaller images. This method has no effect in perspective projection mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetViewAngle">
            <summary>
                <para>Set/Get the camera view angle, which is the angular height of the camera view measured in degrees.  The default angle is 30 degrees.   This method has no effect in parallel projection mode. The formula for setting the angle up for perfect perspective viewing  is: angle = 2*atan((h/2)/d) where h is the height of the RenderWindow  (measured in mm by holding a ruler up to your screen) and d is the distance from your eyes to the screen. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetViewAngle(System.Double)">
            <summary>
                <para>Set/Get the camera view angle, which is the angular height of the camera view measured in degrees.  The default angle is 30 degrees.   This method has no effect in parallel projection mode. The formula for setting the angle up for perfect perspective viewing  is: angle = 2*atan((h/2)/d) where h is the height of the RenderWindow  (measured in mm by holding a ruler up to your screen) and d is the distance from your eyes to the screen. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.UseHorizontalViewAngleOff">
            <summary>
                <para>Set/Get the value of the UseHorizontalViewAngle instance variable. If set, the camera's view angle represents a horizontal view angle, rather than the default vertical view angle. This is useful if the application uses a display device which whose specs indicate a particular horizontal view angle, or if the application varies the window height but wants to keep the perspective transform unchanges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.UseHorizontalViewAngleOn">
            <summary>
                <para>Set/Get the value of the UseHorizontalViewAngle instance variable. If set, the camera's view angle represents a horizontal view angle, rather than the default vertical view angle. This is useful if the application uses a display device which whose specs indicate a particular horizontal view angle, or if the application varies the window height but wants to keep the perspective transform unchanges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetUseHorizontalViewAngle">
            <summary>
                <para>Set/Get the value of the UseHorizontalViewAngle instance variable. If set, the camera's view angle represents a horizontal view angle, rather than the default vertical view angle. This is useful if the application uses a display device which whose specs indicate a particular horizontal view angle, or if the application varies the window height but wants to keep the perspective transform unchanges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetUseHorizontalViewAngle(System.Int32)">
            <summary>
                <para>Set/Get the value of the UseHorizontalViewAngle instance variable. If set, the camera's view angle represents a horizontal view angle, rather than the default vertical view angle. This is useful if the application uses a display device which whose specs indicate a particular horizontal view angle, or if the application varies the window height but wants to keep the perspective transform unchanges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.ParallelProjectionOff">
            <summary>
                <para>Set/Get the value of the ParallelProjection instance variable. This determines if the camera should do a perspective or parallel projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.ParallelProjectionOn">
            <summary>
                <para>Set/Get the value of the ParallelProjection instance variable. This determines if the camera should do a perspective or parallel projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetParallelProjection">
            <summary>
                <para>Set/Get the value of the ParallelProjection instance variable. This determines if the camera should do a perspective or parallel projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetParallelProjection(System.Int32)">
            <summary>
                <para>Set/Get the value of the ParallelProjection instance variable. This determines if the camera should do a perspective or parallel projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.Pitch(System.Double)">
            <summary>
                <para>Rotate the focal point about the cross product of the view up vector  and the direction of projection, centered at the camera's position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.Elevation(System.Double)">
            <summary>
                <para>Rotate the camera about the cross product of the direction of projection and the view up vector centered on the focal point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.Yaw(System.Double)">
            <summary>
                <para>Rotate the focal point about the view up vector centered at the camera's  position.  Note that the view up vector is not necessarily perpendicular to the direction of projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.Azimuth(System.Double)">
            <summary>
                <para>Rotate the camera about the view up vector centered at the focal point. Note that the view up vector is not necessarily perpendicular to the direction of projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.Roll(System.Double)">
            <summary>
                <para>Rotate the camera about the direction of projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetRoll">
            <summary>
                <para>Set the roll angle of the camera about the direction of projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetRoll(System.Double)">
            <summary>
                <para>Set the roll angle of the camera about the direction of projection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.Dolly(System.Double)">
            <summary>
                <para>Move the position of the camera along the direction of projection. Moving towards the focal point (e.g., greater than 1) is a dolly-in, moving away  from the focal point (e.g., less than 1) is a dolly-out.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetDirectionOfProjection">
            <summary>
                <para>Get the vector in the direction from the camera position to the focal point.  This is usually the opposite of the ViewPlaneNormal, the vector perpendicular to the screen, unless the view is oblique.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetDistance">
            <summary>
                <para>Return the distance from the camera position to the focal point. This distance is positive.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetDistance(System.Double)">
            <summary>
                <para>Move the focal point so that it is the specified distance from the camera position.  This distance must be positive.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.OrthogonalizeViewUp">
            <summary>
                <para>Recompute the ViewUp vector to force it to be perpendicular to camera-&gt;focalpoint vector.  Unless you are going to use Yaw or Azimuth on the camera, there is no need to do this.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetViewUp">
            <summary>
                <para>Set/Get the view up direction for the camera.  The default is (0,1,0).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetViewUp(System.Double[])">
            <summary>
                <para>Set/Get the view up direction for the camera.  The default is (0,1,0).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetViewUp(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the view up direction for the camera.  The default is (0,1,0).  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetFocalPoint">
            <summary>
                <para>Set/Get the focal of the camera in world coordinates. The default focal point is the origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetFocalPoint(System.Double[])">
            <summary>
                <para>Set/Get the focal of the camera in world coordinates. The default focal point is the origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetFocalPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the focal of the camera in world coordinates. The default focal point is the origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.GetPosition">
            <summary>
                <para>Set/Get the position of the camera in world coordinates. The default position is (0,0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetPosition(System.Double[])">
            <summary>
                <para>Set/Get the position of the camera in world coordinates. The default position is (0,0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCamera.SetPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the position of the camera in world coordinates. The default position is (0,0,1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActorCollection.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkActorCollection.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkActorCollection.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkActorCollection.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkActorCollection.ApplyProperties(vtk.vtkProperty)">
            <summary>
                <para>Apply properties to all actors in this collection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActorCollection.GetLastItem">
            <summary>
                <para>Access routines that are provided for compatibility with previous version of VTK.  Please use the GetNextActor(), GetLastActor() variants where possible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActorCollection.GetNextItem">
            <summary>
                <para>Access routines that are provided for compatibility with previous version of VTK.  Please use the GetNextActor(), GetLastActor() variants where possible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActorCollection.GetLastActor">
            <summary>
                <para>Get the last actor in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActorCollection.GetNextActor">
            <summary>
                <para>Get the next actor in the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkActorCollection.AddItem(vtk.vtkActor)">
            <summary>
                <para>Add an actor to the list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRenderer.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRenderer.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRenderer.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetTiledAspectRatio">
            <summary>
                <para>Compute the aspect ratio of this renderer for the current tile. When tiled displays are used the aspect ratio of the renderer for a given tile may be diferent that the aspect ratio of the renderer when rendered in it entirity</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.StereoMidpoint">
            <summary>
                <para>Do anything necessary between rendering the left and right viewpoints in a stereo render. Doesn't do anything except in the derived vtkIceTRenderer in ParaView.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.PickProp(System.Double,System.Double)">
            <summary>
                <para>Return the prop (via a vtkAssemblyPath) that has the highest z value  at the given x, y position in the viewport.  Basically, the top most  prop that renders the pixel at selectionX, selectionY will be returned. If nothing was picked then NULL is returned.  This method selects from  the renderers Prop list.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetNumberOfPropsRendered">
            <summary>
                <para>Should be used internally only during a render Get the number of props that were rendered using a RenderOpaqueGeometry or RenderTranslucentGeometry call. This is used to know if something is in the frame buffer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetLastRenderTimeInSeconds">
            <summary>
                <para>Get the time required, in seconds, for the last Render call.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetMTime">
            <summary>
                <para>Return the MTime of the renderer also considering its ivars.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetZ(System.Int32,System.Int32)">
            <summary>
                <para>Given a pixel location, return the Z value. The z value is normalized (0,1) between the front and back clipping planes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.WorldToView(System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>Convert world point coordinates to view coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ViewToWorld(System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>Convert view point coordinates to world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ViewToWorld">
            <summary>
                <para>Convert view point coordinates to world coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.WorldToView">
            <summary>
                <para>Convert world point coordinates to view coordinates.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.Transparent">
            <summary>
                <para>Returns a boolean indicating if this renderer is transparent.  It is transparent if it is not in the deepest layer of its render window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetLayer">
            <summary>
                <para>Set/Get the layer that this renderer belongs to.  This is only used if there are layered renderers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetLayer(System.Int32)">
            <summary>
                <para>Set/Get the layer that this renderer belongs to.  This is only used if there are layered renderers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.InteractiveOff">
            <summary>
                <para>Turn on/off interactive status.  An interactive renderer is one that  can receive events from an interactor.  Should only be set if there are multiple renderers in the same section of the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.InteractiveOn">
            <summary>
                <para>Turn on/off interactive status.  An interactive renderer is one that  can receive events from an interactor.  Should only be set if there are multiple renderers in the same section of the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetInteractive">
            <summary>
                <para>Turn on/off interactive status.  An interactive renderer is one that  can receive events from an interactor.  Should only be set if there are multiple renderers in the same section of the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetInteractive(System.Int32)">
            <summary>
                <para>Turn on/off interactive status.  An interactive renderer is one that  can receive events from an interactor.  Should only be set if there are multiple renderers in the same section of the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.BackingStoreOff">
            <summary>
                <para>Turn on/off using backing store. This may cause the re-rendering time to be slightly slower when the view changes. But it is much faster when the image has not changed, such as during an expose event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.BackingStoreOn">
            <summary>
                <para>Turn on/off using backing store. This may cause the re-rendering time to be slightly slower when the view changes. But it is much faster when the image has not changed, such as during an expose event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetBackingStore">
            <summary>
                <para>Turn on/off using backing store. This may cause the re-rendering time to be slightly slower when the view changes. But it is much faster when the image has not changed, such as during an expose event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetBackingStore(System.Int32)">
            <summary>
                <para>Turn on/off using backing store. This may cause the re-rendering time to be slightly slower when the view changes. But it is much faster when the image has not changed, such as during an expose event.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetVTKWindow">
            <summary>
                <para>Specify the rendering window in which to draw. This is automatically set when the renderer is created by MakeRenderer.  The user probably shouldn't ever need to call this method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetRenderWindow">
            <summary>
                <para>Specify the rendering window in which to draw. This is automatically set when the renderer is created by MakeRenderer.  The user probably shouldn't ever need to call this method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetRenderWindow(vtk.vtkRenderWindow)">
            <summary>
                <para>Specify the rendering window in which to draw. This is automatically set when the renderer is created by MakeRenderer.  The user probably shouldn't ever need to call this method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ResetCamera(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Alternative version of ResetCamera(bounds[6]);</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ResetCamera(System.Double[])">
            <summary>
                <para>Automatically set up the camera based on a specified bounding box (xmin,xmax, ymin,ymax, zmin,zmax). Camera will reposition itself so that its focal point is the center of the bounding box, and adjust its distance and position to preserve its initial view plane normal  (i.e., vector defined from camera position to focal point). Note: is  the view plane is parallel to the view up axis, the view up axis will be reset to one of the three coordinate axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ResetCamera">
            <summary>
                <para>Automatically set up the camera based on the visible actors. The camera will reposition itself to view the center point of the actors, and move along its initial view plane normal (i.e., vector defined from  camera position to focal point) so that all of the actors can be seen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetNearClippingPlaneTolerance">
            <summary>
                <para>Specify tolerance for near clipping plane distance to the camera as a percentage of the far clipping plane distance. By default this will be set to 0.01 for 16 bit zbuffers and 0.001 for higher depth z buffers</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetNearClippingPlaneToleranceMaxValue">
            <summary>
                <para>Specify tolerance for near clipping plane distance to the camera as a percentage of the far clipping plane distance. By default this will be set to 0.01 for 16 bit zbuffers and 0.001 for higher depth z buffers</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetNearClippingPlaneToleranceMinValue">
            <summary>
                <para>Specify tolerance for near clipping plane distance to the camera as a percentage of the far clipping plane distance. By default this will be set to 0.01 for 16 bit zbuffers and 0.001 for higher depth z buffers</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetNearClippingPlaneTolerance(System.Double)">
            <summary>
                <para>Specify tolerance for near clipping plane distance to the camera as a percentage of the far clipping plane distance. By default this will be set to 0.01 for 16 bit zbuffers and 0.001 for higher depth z buffers</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ResetCameraClippingRange(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Reset the camera clipping range based on a bounding box. This method is called from ResetCameraClippingRange()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ResetCameraClippingRange(System.Double[])">
            <summary>
                <para>Reset the camera clipping range based on a bounding box. This method is called from ResetCameraClippingRange()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ResetCameraClippingRange">
            <summary>
                <para>Reset the camera clipping range based on the bounds of the visible actors. This ensures that no props are cut off</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ComputeVisiblePropBounds">
            <summary>
                <para>Wrapper-friendly version of ComputeVisiblePropBounds </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.ComputeVisiblePropBounds(System.Double[])">
            <summary>
                <para>Compute the bounding box of all the visible props Used in ResetCamera() and ResetCameraClippingRange() </para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.VisibleVolumeCount">
            <summary>
                <para>Returns the number of visible volumes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.VisibleActorCount">
            <summary>
                <para>Returns the number of visible actors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.Clear">
            <summary>
                <para>Clear the image to the background color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.DeviceRender">
            <summary>
                <para>Create an image. Subclasses of vtkRenderer must implement this method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.Render">
            <summary>
                <para>Create an image. This is a superclass method which will in turn  call the DeviceRender method of Subclasses of vtkRenderer</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetTimeFactor">
            <summary>
                <para>Get the ratio between allocated time and actual render time. TimeFactor has been taken out of the render process.   It is still computed in case someone finds it useful. It may be taken away in the future.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetAllocatedRenderTime">
            <summary>
                <para>Set/Get the amount of time this renderer is allowed to spend rendering its scene. This is used by vtkLODActor's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetAllocatedRenderTime(System.Double)">
            <summary>
                <para>Set/Get the amount of time this renderer is allowed to spend rendering its scene. This is used by vtkLODActor's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetAmbient">
            <summary>
                <para>Set the intensity of ambient lighting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetAmbient(System.Double[])">
            <summary>
                <para>Set the intensity of ambient lighting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetAmbient(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the intensity of ambient lighting.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetCullers">
            <summary>
                <para>Return the collection of cullers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.RemoveCuller(vtk.vtkCuller)">
            <summary>
                <para>Remove an actor from the list of cullers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.AddCuller(vtk.vtkCuller)">
            <summary>
                <para>Add an culler to the list of cullers.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.EraseOff">
            <summary>
                <para>When this flag is off, the renderer will not erase the background or the Zbuffer.  It is used to have overlapping renderers. Both the RenderWindow Erase and Render Erase must be on for the camera to clear the renderer.  By default, Erase is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.EraseOn">
            <summary>
                <para>When this flag is off, the renderer will not erase the background or the Zbuffer.  It is used to have overlapping renderers. Both the RenderWindow Erase and Render Erase must be on for the camera to clear the renderer.  By default, Erase is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetErase">
            <summary>
                <para>When this flag is off, the renderer will not erase the background or the Zbuffer.  It is used to have overlapping renderers. Both the RenderWindow Erase and Render Erase must be on for the camera to clear the renderer.  By default, Erase is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetErase(System.Int32)">
            <summary>
                <para>When this flag is off, the renderer will not erase the background or the Zbuffer.  It is used to have overlapping renderers. Both the RenderWindow Erase and Render Erase must be on for the camera to clear the renderer.  By default, Erase is on.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.MakeCamera">
            <summary>
                <para>Create a new Camera sutible for use with this type of Renderer. For example, a vtkMesaRenderer should create a vtkMesaCamera  in this function.   The default is to just call vtkCamera::New.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetActiveCamera">
            <summary>
                <para>Get the current camera. If there is not camera assigned to the renderer already, a new one is created automatically. This does *not* reset the camera.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetActiveCamera(vtk.vtkCamera)">
            <summary>
                <para>Specify the camera to use for this renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetActors">
            <summary>
                <para>Return any actors in this renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetVolumes">
            <summary>
                <para>Return the collection of volumes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.UpdateLightsGeometryToFollowCamera">
            <summary>
                <para>Ask the lights in the scene that are not in world space (for instance, Headlights or CameraLights that are attached to the  camera) to update their geometry to match the active camera.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.AutomaticLightCreationOff">
            <summary>
                <para>Turn on/off a flag which disables the automatic light creation capability. Normally in VTK if no lights are associated with the renderer, then a light is automatically created. However, in special circumstances this feature is undesirable, so the following boolean is provided to disable automatic light creation. (Turn AutomaticLightCreation off if you do not want lights to be created.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.AutomaticLightCreationOn">
            <summary>
                <para>Turn on/off a flag which disables the automatic light creation capability. Normally in VTK if no lights are associated with the renderer, then a light is automatically created. However, in special circumstances this feature is undesirable, so the following boolean is provided to disable automatic light creation. (Turn AutomaticLightCreation off if you do not want lights to be created.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetAutomaticLightCreation(System.Int32)">
            <summary>
                <para>Turn on/off a flag which disables the automatic light creation capability. Normally in VTK if no lights are associated with the renderer, then a light is automatically created. However, in special circumstances this feature is undesirable, so the following boolean is provided to disable automatic light creation. (Turn AutomaticLightCreation off if you do not want lights to be created.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetAutomaticLightCreation">
            <summary>
                <para>Turn on/off a flag which disables the automatic light creation capability. Normally in VTK if no lights are associated with the renderer, then a light is automatically created. However, in special circumstances this feature is undesirable, so the following boolean is provided to disable automatic light creation. (Turn AutomaticLightCreation off if you do not want lights to be created.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.LightFollowCameraOff">
            <summary>
                <para>Turn on/off the automatic repositioning of lights as the camera moves. If LightFollowCamera is on, lights that are designated as Headlights or CameraLights will be adjusted to move with this renderer's camera. If LightFollowCamera is off, the lights will not be adjusted.  </para>
                <para>(Note: In previous versions of vtk, this light-tracking functionality was part of the interactors, not the renderer. For backwards compatibility, the older, more limited interactor behavior is enabled by default. To disable this mode, turn the interactor's LightFollowCamera flag OFF, and leave the renderer's LightFollowCamera flag ON.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.LightFollowCameraOn">
            <summary>
                <para>Turn on/off the automatic repositioning of lights as the camera moves. If LightFollowCamera is on, lights that are designated as Headlights or CameraLights will be adjusted to move with this renderer's camera. If LightFollowCamera is off, the lights will not be adjusted.  </para>
                <para>(Note: In previous versions of vtk, this light-tracking functionality was part of the interactors, not the renderer. For backwards compatibility, the older, more limited interactor behavior is enabled by default. To disable this mode, turn the interactor's LightFollowCamera flag OFF, and leave the renderer's LightFollowCamera flag ON.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetLightFollowCamera">
            <summary>
                <para>Turn on/off the automatic repositioning of lights as the camera moves. If LightFollowCamera is on, lights that are designated as Headlights or CameraLights will be adjusted to move with this renderer's camera. If LightFollowCamera is off, the lights will not be adjusted.  </para>
                <para>(Note: In previous versions of vtk, this light-tracking functionality was part of the interactors, not the renderer. For backwards compatibility, the older, more limited interactor behavior is enabled by default. To disable this mode, turn the interactor's LightFollowCamera flag OFF, and leave the renderer's LightFollowCamera flag ON.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetLightFollowCamera(System.Int32)">
            <summary>
                <para>Turn on/off the automatic repositioning of lights as the camera moves. If LightFollowCamera is on, lights that are designated as Headlights or CameraLights will be adjusted to move with this renderer's camera. If LightFollowCamera is off, the lights will not be adjusted.  </para>
                <para>(Note: In previous versions of vtk, this light-tracking functionality was part of the interactors, not the renderer. For backwards compatibility, the older, more limited interactor behavior is enabled by default. To disable this mode, turn the interactor's LightFollowCamera flag OFF, and leave the renderer's LightFollowCamera flag ON.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.TwoSidedLightingOff">
            <summary>
                <para>Turn on/off two-sided lighting of surfaces. If two-sided lighting is off, then only the side of the surface facing the light(s) will be lit, and the other side dark. If two-sided lighting on, both sides of the  surface will be lit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.TwoSidedLightingOn">
            <summary>
                <para>Turn on/off two-sided lighting of surfaces. If two-sided lighting is off, then only the side of the surface facing the light(s) will be lit, and the other side dark. If two-sided lighting on, both sides of the  surface will be lit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.SetTwoSidedLighting(System.Int32)">
            <summary>
                <para>Turn on/off two-sided lighting of surfaces. If two-sided lighting is off, then only the side of the surface facing the light(s) will be lit, and the other side dark. If two-sided lighting on, both sides of the  surface will be lit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetTwoSidedLighting">
            <summary>
                <para>Turn on/off two-sided lighting of surfaces. If two-sided lighting is off, then only the side of the surface facing the light(s) will be lit, and the other side dark. If two-sided lighting on, both sides of the  surface will be lit.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.MakeLight">
            <summary>
                <para>Create a new Light sutible for use with this type of Renderer. For example, a vtkMesaRenderer should create a vtkMesaLight  in this function.   The default is to just call vtkLight::New.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.CreateLight">
            <summary>
                <para>Create and add a light to renderer.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.GetLights">
            <summary>
                <para>Return the collection of lights.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.RemoveLight(vtk.vtkLight)">
            <summary>
                <para>Remove a light from the list of lights.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.AddLight(vtk.vtkLight)">
            <summary>
                <para>Add a light to the list of lights.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.RemoveVolume(vtk.vtkProp)">
            <summary>
                <para>Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.RemoveActor(vtk.vtkProp)">
            <summary>
                <para>Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.AddVolume(vtk.vtkProp)">
            <summary>
                <para>Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderer.AddActor(vtk.vtkProp)">
            <summary>
                <para>Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.</para>
            </summary>
        </member>
    </members>
</doc>