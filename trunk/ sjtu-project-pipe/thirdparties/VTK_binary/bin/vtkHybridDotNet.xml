<?xml version="1.0"?>
<doc>
    <assembly>
        "vtkHybridDotNet"
    </assembly>
    <members>
        <member name="M:vtk.vtkRenderLargeImage.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.GetInput">
            <summary>
                <para>Returns which renderer is being used as the source for the pixel data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.SetInput(vtk.vtkRenderer)">
            <summary>
                <para>Indicates what renderer to get the pixel data from.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.GetMagnification">
            <summary>
                <para>The magnification of the current render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRenderLargeImage.SetMagnification(System.Int32)">
            <summary>
                <para>The magnification of the current render window</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.GetMTime">
            <summary>
                <para>Return MTime also considering the dependent objects: the camera and/or the prop3D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SortScalarsOff">
            <summary>
                <para>Set/Get a flag that controls the generation of scalar values corresponding to the sort order. If enabled, the output of this filter will include scalar values that range from 0 to (ncells-1), where 0 is closest to the sort direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SortScalarsOn">
            <summary>
                <para>Set/Get a flag that controls the generation of scalar values corresponding to the sort order. If enabled, the output of this filter will include scalar values that range from 0 to (ncells-1), where 0 is closest to the sort direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.GetSortScalars">
            <summary>
                <para>Set/Get a flag that controls the generation of scalar values corresponding to the sort order. If enabled, the output of this filter will include scalar values that range from 0 to (ncells-1), where 0 is closest to the sort direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetSortScalars(System.Int32)">
            <summary>
                <para>Set/Get a flag that controls the generation of scalar values corresponding to the sort order. If enabled, the output of this filter will include scalar values that range from 0 to (ncells-1), where 0 is closest to the sort direction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.GetOrigin">
            <summary>
                <para>Set/Get the sort origin. This ivar only has effect if the sort direction is set to SetDirectionToSpecifiedVector(). The sort occurs in the direction of the vector, with this point specifying the origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetOrigin(System.Double[])">
            <summary>
                <para>Set/Get the sort origin. This ivar only has effect if the sort direction is set to SetDirectionToSpecifiedVector(). The sort occurs in the direction of the vector, with this point specifying the origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the sort origin. This ivar only has effect if the sort direction is set to SetDirectionToSpecifiedVector(). The sort occurs in the direction of the vector, with this point specifying the origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.GetVector">
            <summary>
                <para>Set/Get the sort direction. This ivar only has effect if the sort direction is set to SetDirectionToSpecifiedVector(). The sort occurs in the direction of the vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetVector(System.Double[])">
            <summary>
                <para>Set/Get the sort direction. This ivar only has effect if the sort direction is set to SetDirectionToSpecifiedVector(). The sort occurs in the direction of the vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetVector(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the sort direction. This ivar only has effect if the sort direction is set to SetDirectionToSpecifiedVector(). The sort occurs in the direction of the vector.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.GetProp3D">
            <summary>
                <para>Specify a transformation matrix (via the vtkProp3D::GetMatrix() method) that is used to include the effects of transformation. This ivar only has effect if the direction is set to front-to-back or back-to-front, and a camera is specified. Specifying the vtkProp3D is optional.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetProp3D(vtk.vtkProp3D)">
            <summary>
                <para>Specify a transformation matrix (via the vtkProp3D::GetMatrix() method) that is used to include the effects of transformation. This ivar only has effect if the direction is set to front-to-back or back-to-front, and a camera is specified. Specifying the vtkProp3D is optional.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.GetCamera">
            <summary>
                <para>Specify a camera that is used to define a view direction along which the cells are sorted. This ivar only has effect if the direction is set to front-to-back or back-to-front, and a camera is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetCamera(vtk.vtkCamera)">
            <summary>
                <para>Specify a camera that is used to define a view direction along which the cells are sorted. This ivar only has effect if the direction is set to front-to-back or back-to-front, and a camera is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetDepthSortModeToParametricCenter">
            <summary>
                <para>Specify a camera that is used to define a view direction along which the cells are sorted. This ivar only has effect if the direction is set to front-to-back or back-to-front, and a camera is specified.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetDepthSortModeToBoundsCenter">
            <summary>
                <para>Specify the point to use when sorting. The fastest is to just take the first cell point. Other options are to take the bounding box center or the parametric center of the cell. By default, the first cell point is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetDepthSortModeToFirstPoint">
            <summary>
                <para>Specify the point to use when sorting. The fastest is to just take the first cell point. Other options are to take the bounding box center or the parametric center of the cell. By default, the first cell point is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.GetDepthSortMode">
            <summary>
                <para>Specify the point to use when sorting. The fastest is to just take the first cell point. Other options are to take the bounding box center or the parametric center of the cell. By default, the first cell point is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetDepthSortMode(System.Int32)">
            <summary>
                <para>Specify the point to use when sorting. The fastest is to just take the first cell point. Other options are to take the bounding box center or the parametric center of the cell. By default, the first cell point is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetDirectionToSpecifiedVector">
            <summary>
                <para>Specify the point to use when sorting. The fastest is to just take the first cell point. Other options are to take the bounding box center or the parametric center of the cell. By default, the first cell point is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetDirectionToBackToFront">
            <summary>
                <para>Specify the sort method for the polygonal primitives. By default, the poly data is sorted from back to front.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetDirectionToFrontToBack">
            <summary>
                <para>Specify the sort method for the polygonal primitives. By default, the poly data is sorted from back to front.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.GetDirection">
            <summary>
                <para>Specify the sort method for the polygonal primitives. By default, the poly data is sorted from back to front.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDepthSortPolyData.SetDirection(System.Int32)">
            <summary>
                <para>Specify the sort method for the polygonal primitives. By default, the poly data is sorted from back to front.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRIBProperty.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.GetParameters">
            <summary>
                <para>Get parameters.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.AddParameter(System.String,System.String)">
            <summary>
                <para>Specify parameter values for variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.SetParameter(System.String,System.String)">
            <summary>
                <para>Specify parameter values for variables.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.GetDeclarations">
            <summary>
                <para>Get variable declarations</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.AddVariable(System.String,System.String)">
            <summary>
                <para>Specify declarations for variables..</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.SetVariable(System.String,System.String)">
            <summary>
                <para>Specify declarations for variables..</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.GetDisplacementShader">
            <summary>
                <para>Specify the name of a displacement shader.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.SetDisplacementShader(System.String)">
            <summary>
                <para>Specify the name of a displacement shader.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.GetSurfaceShader">
            <summary>
                <para>Specify the name of a surface shader.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBProperty.SetSurfaceShader(System.String)">
            <summary>
                <para>Specify the name of a surface shader.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVideoSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImplicitModeller.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.EndAppend">
            <summary>
                <para>Method completes the append process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.Append(vtk.vtkDataSet)">
            <summary>
                <para>Append a data set to the existing output. To use this function, you'll have to invoke the StartAppend() method before doing successive appends. It's also a good idea to specify the model bounds; otherwise the input model bounds is used. When you've finished appending, use the EndAppend() method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.StartAppend">
            <summary>
                <para>Initialize the filter for appending data. You must invoke the StartAppend() method before doing successive Appends(). It's also a good idea to manually specify the model bounds; otherwise the input bounds for the data will be used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToChar">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToUnsignedChar">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToUnsignedShort">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToShort">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToUnsignedLong">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToLong">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToUnsignedInt">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToInt">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToDouble">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarTypeToFloat">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetOutputScalarType">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetOutputScalarType(System.Int32)">
            <summary>
                <para>Set the desired output scalar type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetNumberOfThreads">
            <summary>
                <para>Set / Get the number of threads used during Per-Voxel processing mode</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetNumberOfThreadsMaxValue">
            <summary>
                <para>Set / Get the number of threads used during Per-Voxel processing mode</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetNumberOfThreadsMinValue">
            <summary>
                <para>Set / Get the number of threads used during Per-Voxel processing mode</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetNumberOfThreads(System.Int32)">
            <summary>
                <para>Set / Get the number of threads used during Per-Voxel processing mode</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetLocatorMaxLevel">
            <summary>
                <para>Specify the level of the locator to use when using the per voxel process mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetLocatorMaxLevel(System.Int32)">
            <summary>
                <para>Specify the level of the locator to use when using the per voxel process mode.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetProcessModeAsString">
            <summary>
                <para>Specify whether to visit each cell once per append or each voxel once per append.  Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells.  Primitives should not be stripped for best performance of the voxel mode.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetProcessModeToPerCell">
            <summary>
                <para>Specify whether to visit each cell once per append or each voxel once per append.  Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells.  Primitives should not be stripped for best performance of the voxel mode.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetProcessModeToPerVoxel">
            <summary>
                <para>Specify whether to visit each cell once per append or each voxel once per append.  Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells.  Primitives should not be stripped for best performance of the voxel mode.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetProcessMode">
            <summary>
                <para>Specify whether to visit each cell once per append or each voxel once per append.  Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells.  Primitives should not be stripped for best performance of the voxel mode.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetProcessModeMaxValue">
            <summary>
                <para>Specify whether to visit each cell once per append or each voxel once per append.  Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells.  Primitives should not be stripped for best performance of the voxel mode.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetProcessModeMinValue">
            <summary>
                <para>Specify whether to visit each cell once per append or each voxel once per append.  Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells.  Primitives should not be stripped for best performance of the voxel mode.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetProcessMode(System.Int32)">
            <summary>
                <para>Specify whether to visit each cell once per append or each voxel once per append.  Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells.  Primitives should not be stripped for best performance of the voxel mode.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.ScaleToMaximumDistanceOff">
            <summary>
                <para>If a non-floating output type is specified, the output distances can be scaled to use the entire positive scalar range of the output type  specified (up to the CapValue which is equal to the max for the type  unless modified by the user).  For example, if ScaleToMaximumDistance is On and the OutputScalarType is UnsignedChar the distances saved in the output would be linearly scaled between 0 (for distances "very close" to the surface) and 255 (at the specifed maximum distance)... assuming the  CapValue is not changed from 255.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.ScaleToMaximumDistanceOn">
            <summary>
                <para>If a non-floating output type is specified, the output distances can be scaled to use the entire positive scalar range of the output type  specified (up to the CapValue which is equal to the max for the type  unless modified by the user).  For example, if ScaleToMaximumDistance is On and the OutputScalarType is UnsignedChar the distances saved in the output would be linearly scaled between 0 (for distances "very close" to the surface) and 255 (at the specifed maximum distance)... assuming the  CapValue is not changed from 255.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetScaleToMaximumDistance">
            <summary>
                <para>If a non-floating output type is specified, the output distances can be scaled to use the entire positive scalar range of the output type  specified (up to the CapValue which is equal to the max for the type  unless modified by the user).  For example, if ScaleToMaximumDistance is On and the OutputScalarType is UnsignedChar the distances saved in the output would be linearly scaled between 0 (for distances "very close" to the surface) and 255 (at the specifed maximum distance)... assuming the  CapValue is not changed from 255.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetScaleToMaximumDistance(System.Int32)">
            <summary>
                <para>If a non-floating output type is specified, the output distances can be scaled to use the entire positive scalar range of the output type  specified (up to the CapValue which is equal to the max for the type  unless modified by the user).  For example, if ScaleToMaximumDistance is On and the OutputScalarType is UnsignedChar the distances saved in the output would be linearly scaled between 0 (for distances "very close" to the surface) and 255 (at the specifed maximum distance)... assuming the  CapValue is not changed from 255.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetCapValue">
            <summary>
                <para>Specify the capping value to use. The CapValue is also used as an initial distance value at each point in the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetCapValue(System.Double)">
            <summary>
                <para>Specify the capping value to use. The CapValue is also used as an initial distance value at each point in the dataset.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.CappingOff">
            <summary>
                <para>The outer boundary of the structured point set can be assigned a  particular value. This can be used to close or "cap" all surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.CappingOn">
            <summary>
                <para>The outer boundary of the structured point set can be assigned a  particular value. This can be used to close or "cap" all surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetCapping">
            <summary>
                <para>The outer boundary of the structured point set can be assigned a  particular value. This can be used to close or "cap" all surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetCapping(System.Int32)">
            <summary>
                <para>The outer boundary of the structured point set can be assigned a  particular value. This can be used to close or "cap" all surfaces.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetAdjustDistance">
            <summary>
                <para>Specify the amount to grow the model bounds (if the ivar AdjustBounds is set). The value is a fraction of the maximum length of the sides of the box specified by the model bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetAdjustDistanceMaxValue">
            <summary>
                <para>Specify the amount to grow the model bounds (if the ivar AdjustBounds is set). The value is a fraction of the maximum length of the sides of the box specified by the model bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetAdjustDistanceMinValue">
            <summary>
                <para>Specify the amount to grow the model bounds (if the ivar AdjustBounds is set). The value is a fraction of the maximum length of the sides of the box specified by the model bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetAdjustDistance(System.Double)">
            <summary>
                <para>Specify the amount to grow the model bounds (if the ivar AdjustBounds is set). The value is a fraction of the maximum length of the sides of the box specified by the model bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.AdjustBoundsOff">
            <summary>
                <para>Control how the model bounds are computed. If the ivar AdjustBounds is set, then the bounds specified (or computed automatically) is modified by the fraction given by AdjustDistance. This means that the model bounds is expanded in each of the x-y-z directions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.AdjustBoundsOn">
            <summary>
                <para>Control how the model bounds are computed. If the ivar AdjustBounds is set, then the bounds specified (or computed automatically) is modified by the fraction given by AdjustDistance. This means that the model bounds is expanded in each of the x-y-z directions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetAdjustBounds">
            <summary>
                <para>Control how the model bounds are computed. If the ivar AdjustBounds is set, then the bounds specified (or computed automatically) is modified by the fraction given by AdjustDistance. This means that the model bounds is expanded in each of the x-y-z directions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetAdjustBounds(System.Int32)">
            <summary>
                <para>Control how the model bounds are computed. If the ivar AdjustBounds is set, then the bounds specified (or computed automatically) is modified by the fraction given by AdjustDistance. This means that the model bounds is expanded in each of the x-y-z directions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetModelBounds">
            <summary>
                <para>Set / get the region in space in which to perform the sampling. If not specified, it will be computed automatically.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetModelBounds(System.Double[])">
            <summary>
                <para>Set / get the region in space in which to perform the sampling. If not specified, it will be computed automatically.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetModelBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set / get the region in space in which to perform the sampling. If not specified, it will be computed automatically.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetMaximumDistance">
            <summary>
                <para>Set / get the distance away from surface of input geometry to sample. Smaller values make large increases in performance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetMaximumDistanceMaxValue">
            <summary>
                <para>Set / get the distance away from surface of input geometry to sample. Smaller values make large increases in performance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetMaximumDistanceMinValue">
            <summary>
                <para>Set / get the distance away from surface of input geometry to sample. Smaller values make large increases in performance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetMaximumDistance(System.Double)">
            <summary>
                <para>Set / get the distance away from surface of input geometry to sample. Smaller values make large increases in performance.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetSampleDimensions(System.Int32[])">
            <summary>
                <para>Set/Get the i-j-k dimensions on which to sample distance function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.SetSampleDimensions(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set/Get the i-j-k dimensions on which to sample distance function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.GetSampleDimensions">
            <summary>
                <para>Set/Get the i-j-k dimensions on which to sample distance function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImplicitModeller.ComputeModelBounds(vtk.vtkDataSet)">
            <summary>
                <para>Compute ModelBounds from input geometry. If input is not specified, the input of the filter will be used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkDSPFilterGroup.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDSPFilterGroup.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkDSPFilterGroup.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDSPFilterGroup.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDSPFilterGroup.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDSPFilterGroup.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.GetModesRequiredFor(System.Double)">
            <summary>
                <para>Retrieve how many modes are necessary to model the given proportion of the variation. proportion should be between 0 and 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.GetShapeParameters(vtk.vtkPointSet,vtk.vtkFloatArray,System.Int32)">
            <summary>
                <para>Return the bsize parameters b that best model the given shape (in standard deviations).  That is that the given shape will be approximated by:</para>
                <para>shape ~ mean + b[0] * sqrt(eigenvalue[0]) * eigenvector[0]              + b[1] * sqrt(eigenvalue[1]) * eigenvector[1]         ...              + b[bsize-1] * sqrt(eigenvalue[bsize-1]) * eigenvector[bsize-1]</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.GetParameterisedShape(vtk.vtkFloatArray,vtk.vtkPointSet)">
            <summary>
                <para>Fills the shape with:</para>
                <para>mean + b[0] * sqrt(eigenvalue[0]) * eigenvector[0]      + b[1] * sqrt(eigenvalue[1]) * eigenvector[1] ...      + b[sizeb-1] * sqrt(eigenvalue[bsize-1]) * eigenvector[bsize-1]</para>
                <para>here b are the parameters expressed in standard deviations bsize is the number of parameters in the b vector This function assumes that shape is allready allocated with the right size, it just moves the points.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.GetInput(System.Int32)">
            <summary>
                <para>Retrieve the input with index idx (usually only used for pipeline tracing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.SetInput(System.Int32,vtk.vtkPointSet)">
            <summary>
                <para>Specify the input pointset with index idx. Call SetNumberOfInputs before calling this function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.SetNumberOfInputs(System.Int32)">
            <summary>
                <para>Specify how many pointsets are going to be given as input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPCAAnalysisFilter.GetEvals">
            <summary>
                <para>Get the vector of eigenvalues sorted in descending order</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVRMLImporter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.GetFileName">
            <summary>
                <para>Specify the name of the file to read.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.SetFileName(System.String)">
            <summary>
                <para>Specify the name of the file to read.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.useNode(System.String)">
            <summary>
                <para>Needed by the yacc/lex grammar used</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.exitField">
            <summary>
                <para>Needed by the yacc/lex grammar used</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.enterField(System.String)">
            <summary>
                <para>Needed by the yacc/lex grammar used</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.exitNode">
            <summary>
                <para>Needed by the yacc/lex grammar used</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.enterNode(System.String)">
            <summary>
                <para>Needed by the yacc/lex grammar used</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVRMLImporter.GetVRMLDEFObject(System.String)">
            <summary>
                <para>In the VRML spec you can DEF and USE nodes (name them), This routine will return the associated VTK object which was created as a result of the DEF mechanism Send in the name from the VRML file, get the VTK object. You will have to check and correctly cast the object since this only returns vtkObjects.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetMaximumNumberOfLines">
            <summary>
                <para>This instance variable can be used to limit the total number of line segments created during subdivision. Note that the number of input line segments will be the minimum number that cab be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetMaximumNumberOfLinesMaxValue">
            <summary>
                <para>This instance variable can be used to limit the total number of line segments created during subdivision. Note that the number of input line segments will be the minimum number that cab be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetMaximumNumberOfLinesMinValue">
            <summary>
                <para>This instance variable can be used to limit the total number of line segments created during subdivision. Note that the number of input line segments will be the minimum number that cab be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.SetMaximumNumberOfLines(System.Int32)">
            <summary>
                <para>This instance variable can be used to limit the total number of line segments created during subdivision. Note that the number of input line segments will be the minimum number that cab be output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetHeightTolerance">
            <summary>
                <para>This is the allowable variation in the altitude of the path with respect to the variation in the terrain. It only comes into play if the hug projection mode is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetHeightToleranceMaxValue">
            <summary>
                <para>This is the allowable variation in the altitude of the path with respect to the variation in the terrain. It only comes into play if the hug projection mode is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetHeightToleranceMinValue">
            <summary>
                <para>This is the allowable variation in the altitude of the path with respect to the variation in the terrain. It only comes into play if the hug projection mode is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.SetHeightTolerance(System.Double)">
            <summary>
                <para>This is the allowable variation in the altitude of the path with respect to the variation in the terrain. It only comes into play if the hug projection mode is enabled.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetHeightOffset">
            <summary>
                <para>This is the height above (or below) the terrain that the projected path should be. Positive values indicate distances above the terrain; negative values indicate distances below the terrain. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.SetHeightOffset(System.Double)">
            <summary>
                <para>This is the height above (or below) the terrain that the projected path should be. Positive values indicate distances above the terrain; negative values indicate distances below the terrain. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.SetProjectionModeToHug">
            <summary>
                <para>This is the height above (or below) the terrain that the projected path should be. Positive values indicate distances above the terrain; negative values indicate distances below the terrain. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.SetProjectionModeToNonOccluded">
            <summary>
                <para>Determine how to control the projection process. Simple projection just projects the original polyline points. Non-occluded projection insures that the polyline does not intersect the terrain surface. Hug projection is similar to non-occulded projection except that produces a path that is nearly parallel to the terrain (within the user specified height tolerance).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.SetProjectionModeToSimple">
            <summary>
                <para>Determine how to control the projection process. Simple projection just projects the original polyline points. Non-occluded projection insures that the polyline does not intersect the terrain surface. Hug projection is similar to non-occulded projection except that produces a path that is nearly parallel to the terrain (within the user specified height tolerance).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetProjectionMode">
            <summary>
                <para>Determine how to control the projection process. Simple projection just projects the original polyline points. Non-occluded projection insures that the polyline does not intersect the terrain surface. Hug projection is similar to non-occulded projection except that produces a path that is nearly parallel to the terrain (within the user specified height tolerance).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetProjectionModeMaxValue">
            <summary>
                <para>Determine how to control the projection process. Simple projection just projects the original polyline points. Non-occluded projection insures that the polyline does not intersect the terrain surface. Hug projection is similar to non-occulded projection except that produces a path that is nearly parallel to the terrain (within the user specified height tolerance).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetProjectionModeMinValue">
            <summary>
                <para>Determine how to control the projection process. Simple projection just projects the original polyline points. Non-occluded projection insures that the polyline does not intersect the terrain surface. Hug projection is similar to non-occulded projection except that produces a path that is nearly parallel to the terrain (within the user specified height tolerance).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.SetProjectionMode(System.Int32)">
            <summary>
                <para>Determine how to control the projection process. Simple projection just projects the original polyline points. Non-occluded projection insures that the polyline does not intersect the terrain surface. Hug projection is similar to non-occulded projection except that produces a path that is nearly parallel to the terrain (within the user specified height tolerance).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetSource">
            <summary>
                <para>Specify the second input (the terrain) onto which the polyline(s) should be projected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.SetSource(vtk.vtkImageData)">
            <summary>
                <para>Specify the second input (the terrain) onto which the polyline(s) should be projected.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.SafeDownCast(vtk.vtkObject)">
            <summary>
                <para>Standard methids for printing and determining type information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.NewInstance">
            <summary>
                <para>Standard methids for printing and determining type information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.IsA(System.String)">
            <summary>
                <para>Standard methids for printing and determining type information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProjectedTerrainPath.GetClassName">
            <summary>
                <para>Standard methids for printing and determining type information.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkXYPlotActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetMTime">
            <summary>
                <para>Take into account the modified time of internal helper classes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.IsInPlot(vtk.vtkViewport,System.Double,System.Double)">
            <summary>
                <para>Is the specified viewport position within the plot area (as opposed to the region used by the plot plus the labels)?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetViewportCoordinate">
            <summary>
                <para>An alternate form of PlotToViewportCoordinate() above. This method inputs the plot coordinate pair (defined in the ivar PlotCoordinate) and then stores them in the ivar ViewportCoordinate. (This method  can be wrapped.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetViewportCoordinate(System.Double[])">
            <summary>
                <para>An alternate form of PlotToViewportCoordinate() above. This method inputs the plot coordinate pair (defined in the ivar PlotCoordinate) and then stores them in the ivar ViewportCoordinate. (This method  can be wrapped.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetViewportCoordinate(System.Double,System.Double)">
            <summary>
                <para>An alternate form of PlotToViewportCoordinate() above. This method inputs the plot coordinate pair (defined in the ivar PlotCoordinate) and then stores them in the ivar ViewportCoordinate. (This method  can be wrapped.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.PlotToViewportCoordinate(vtk.vtkViewport)">
            <summary>
                <para>An alternate form of PlotToViewportCoordinate() above. This method inputs the plot coordinate pair (defined in the ivar PlotCoordinate) and then stores them in the ivar ViewportCoordinate. (This method  can be wrapped.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.PlotToViewportCoordinate(vtk.vtkViewport,System.Double@,System.Double@)">
            <summary>
                <para>Given a plot coordinate, return the viewpoint position</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetPlotCoordinate">
            <summary>
                <para>An alternate form of ViewportToPlotCoordinate() above. This method inputs the viewport coordinate pair (defined by the ivar  ViewportCoordinate)and then stores them in the ivar PlotCoordinate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetPlotCoordinate(System.Double[])">
            <summary>
                <para>An alternate form of ViewportToPlotCoordinate() above. This method inputs the viewport coordinate pair (defined by the ivar  ViewportCoordinate)and then stores them in the ivar PlotCoordinate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetPlotCoordinate(System.Double,System.Double)">
            <summary>
                <para>An alternate form of ViewportToPlotCoordinate() above. This method inputs the viewport coordinate pair (defined by the ivar  ViewportCoordinate)and then stores them in the ivar PlotCoordinate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.ViewportToPlotCoordinate(vtk.vtkViewport)">
            <summary>
                <para>An alternate form of ViewportToPlotCoordinate() above. This method inputs the viewport coordinate pair (defined by the ivar  ViewportCoordinate)and then stores them in the ivar PlotCoordinate. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.ViewportToPlotCoordinate(vtk.vtkViewport,System.Double@,System.Double@)">
            <summary>
                <para>Given a position within the viewport used by the plot, return the the plot coordinates (XAxis value, YAxis value)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetGlyphSize">
            <summary>
                <para>Set/Get the factor that controls how big glyphs are in the plot. The number is expressed as a fraction of the length of the diagonal of the plot bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetGlyphSizeMaxValue">
            <summary>
                <para>Set/Get the factor that controls how big glyphs are in the plot. The number is expressed as a fraction of the length of the diagonal of the plot bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetGlyphSizeMinValue">
            <summary>
                <para>Set/Get the factor that controls how big glyphs are in the plot. The number is expressed as a fraction of the length of the diagonal of the plot bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetGlyphSize(System.Double)">
            <summary>
                <para>Set/Get the factor that controls how big glyphs are in the plot. The number is expressed as a fraction of the length of the diagonal of the plot bounding box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.PlotLinesOff">
            <summary>
                <para>Set/Get whether the lines are rendered.  The line width can be set in the property object. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.PlotLinesOn">
            <summary>
                <para>Set/Get whether the lines are rendered.  The line width can be set in the property object. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetPlotLines(System.Int32)">
            <summary>
                <para>Set/Get whether the lines are rendered.  The line width can be set in the property object. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetPlotLines">
            <summary>
                <para>Set/Get whether the lines are rendered.  The line width can be set in the property object. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.PlotPointsOff">
            <summary>
                <para>Set/Get whether the points are rendered.  The point size can be set in the property object. This is a global flag which affects the plot only  if per curve symbols are not defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.PlotPointsOn">
            <summary>
                <para>Set/Get whether the points are rendered.  The point size can be set in the property object. This is a global flag which affects the plot only  if per curve symbols are not defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetPlotPoints(System.Int32)">
            <summary>
                <para>Set/Get whether the points are rendered.  The point size can be set in the property object. This is a global flag which affects the plot only  if per curve symbols are not defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetPlotPoints">
            <summary>
                <para>Set/Get whether the points are rendered.  The point size can be set in the property object. This is a global flag which affects the plot only  if per curve symbols are not defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetBorder">
            <summary>
                <para>Set/Get the spacing between the plot window and the plot. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetBorderMaxValue">
            <summary>
                <para>Set/Get the spacing between the plot window and the plot. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetBorderMinValue">
            <summary>
                <para>Set/Get the spacing between the plot window and the plot. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetBorder(System.Int32)">
            <summary>
                <para>Set/Get the spacing between the plot window and the plot. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetLabelFormat">
            <summary>
                <para>Set/Get the format with which to print the labels on the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetLabelFormat(System.String)">
            <summary>
                <para>Set/Get the format with which to print the labels on the scalar bar.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.LogxOff">
            <summary>
                <para>Enable/Disable plotting of Log of x-values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.LogxOn">
            <summary>
                <para>Enable/Disable plotting of Log of x-values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetLogx">
            <summary>
                <para>Enable/Disable plotting of Log of x-values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetLogx(System.Int32)">
            <summary>
                <para>Enable/Disable plotting of Log of x-values.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetAxisLabelTextProperty">
            <summary>
                <para>Set/Get the labels text property of all axes. Note that each axis can be controlled individually through the GetX/YAxisActor2D() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetAxisLabelTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the labels text property of all axes. Note that each axis can be controlled individually through the GetX/YAxisActor2D() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetAxisTitleTextProperty">
            <summary>
                <para>Set/Get the title text property of all axes. Note that each axis can be controlled individually through the GetX/YAxisActor2D() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetAxisTitleTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the title text property of all axes. Note that each axis can be controlled individually through the GetX/YAxisActor2D() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetTitleTextProperty">
            <summary>
                <para>Set/Get the title text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetTitleTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the title text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetLegendPosition2">
            <summary>
                <para>Use these methods to control the position of the legend. The variables LegendPosition and LegendPosition2 define the lower-left and upper-right position of the legend. The coordinates are expressed as normalized values with respect to the rectangle defined by PositionCoordinate and Position2Coordinate. Note that LegendPosition2 is relative to LegendPosition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetLegendPosition2(System.Double[])">
            <summary>
                <para>Use these methods to control the position of the legend. The variables LegendPosition and LegendPosition2 define the lower-left and upper-right position of the legend. The coordinates are expressed as normalized values with respect to the rectangle defined by PositionCoordinate and Position2Coordinate. Note that LegendPosition2 is relative to LegendPosition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetLegendPosition2(System.Double,System.Double)">
            <summary>
                <para>Use these methods to control the position of the legend. The variables LegendPosition and LegendPosition2 define the lower-left and upper-right position of the legend. The coordinates are expressed as normalized values with respect to the rectangle defined by PositionCoordinate and Position2Coordinate. Note that LegendPosition2 is relative to LegendPosition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetLegendPosition">
            <summary>
                <para>Use these methods to control the position of the legend. The variables LegendPosition and LegendPosition2 define the lower-left and upper-right position of the legend. The coordinates are expressed as normalized values with respect to the rectangle defined by PositionCoordinate and Position2Coordinate. Note that LegendPosition2 is relative to LegendPosition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetLegendPosition(System.Double[])">
            <summary>
                <para>Use these methods to control the position of the legend. The variables LegendPosition and LegendPosition2 define the lower-left and upper-right position of the legend. The coordinates are expressed as normalized values with respect to the rectangle defined by PositionCoordinate and Position2Coordinate. Note that LegendPosition2 is relative to LegendPosition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetLegendPosition(System.Double,System.Double)">
            <summary>
                <para>Use these methods to control the position of the legend. The variables LegendPosition and LegendPosition2 define the lower-left and upper-right position of the legend. The coordinates are expressed as normalized values with respect to the rectangle defined by PositionCoordinate and Position2Coordinate. Note that LegendPosition2 is relative to LegendPosition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.LegendOff">
            <summary>
                <para>Enable/Disable the creation of a legend. If on, the legend labels will be created automatically unless the per plot legend symbol has been set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.LegendOn">
            <summary>
                <para>Enable/Disable the creation of a legend. If on, the legend labels will be created automatically unless the per plot legend symbol has been set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetLegend">
            <summary>
                <para>Enable/Disable the creation of a legend. If on, the legend labels will be created automatically unless the per plot legend symbol has been set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetLegend(System.Int32)">
            <summary>
                <para>Enable/Disable the creation of a legend. If on, the legend labels will be created automatically unless the per plot legend symbol has been set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetNumberOfLabels(System.Int32)">
            <summary>
                <para>Enable/Disable the creation of a legend. If on, the legend labels will be created automatically unless the per plot legend symbol has been set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetNumberOfYLabels">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x and y axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data. The convenience method  SetNumberOfLables() sets the number of x and y labels to the same value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetNumberOfYLabelsMaxValue">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x and y axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data. The convenience method  SetNumberOfLables() sets the number of x and y labels to the same value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetNumberOfYLabelsMinValue">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x and y axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data. The convenience method  SetNumberOfLables() sets the number of x and y labels to the same value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetNumberOfYLabels(System.Int32)">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x and y axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data. The convenience method  SetNumberOfLables() sets the number of x and y labels to the same value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetNumberOfXLabels">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x and y axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data. The convenience method  SetNumberOfLables() sets the number of x and y labels to the same value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetNumberOfXLabelsMaxValue">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x and y axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data. The convenience method  SetNumberOfLables() sets the number of x and y labels to the same value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetNumberOfXLabelsMinValue">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x and y axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data. The convenience method  SetNumberOfLables() sets the number of x and y labels to the same value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetNumberOfXLabels(System.Int32)">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x and y axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data. The convenience method  SetNumberOfLables() sets the number of x and y labels to the same value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetPlotRange(System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x and y axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data. The convenience method  SetNumberOfLables() sets the number of x and y labels to the same value.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetYRange">
            <summary>
                <para>Set the plot range (range of independent and dependent variables) to plot. Data outside of the range will be clipped. If the plot range of either the x or y variables is set to (v1,v2), where v1 == v2, then the range will be computed automatically. Note that the x-range values should be consistent with the way the independent variable is created (via INDEX, DISTANCE, or ARC_LENGTH).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetYRange(System.Double[])">
            <summary>
                <para>Set the plot range (range of independent and dependent variables) to plot. Data outside of the range will be clipped. If the plot range of either the x or y variables is set to (v1,v2), where v1 == v2, then the range will be computed automatically. Note that the x-range values should be consistent with the way the independent variable is created (via INDEX, DISTANCE, or ARC_LENGTH).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetYRange(System.Double,System.Double)">
            <summary>
                <para>Set the plot range (range of independent and dependent variables) to plot. Data outside of the range will be clipped. If the plot range of either the x or y variables is set to (v1,v2), where v1 == v2, then the range will be computed automatically. Note that the x-range values should be consistent with the way the independent variable is created (via INDEX, DISTANCE, or ARC_LENGTH).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetXRange">
            <summary>
                <para>Set the plot range (range of independent and dependent variables) to plot. Data outside of the range will be clipped. If the plot range of either the x or y variables is set to (v1,v2), where v1 == v2, then the range will be computed automatically. Note that the x-range values should be consistent with the way the independent variable is created (via INDEX, DISTANCE, or ARC_LENGTH).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetXRange(System.Double[])">
            <summary>
                <para>Set the plot range (range of independent and dependent variables) to plot. Data outside of the range will be clipped. If the plot range of either the x or y variables is set to (v1,v2), where v1 == v2, then the range will be computed automatically. Note that the x-range values should be consistent with the way the independent variable is created (via INDEX, DISTANCE, or ARC_LENGTH).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetXRange(System.Double,System.Double)">
            <summary>
                <para>Set the plot range (range of independent and dependent variables) to plot. Data outside of the range will be clipped. If the plot range of either the x or y variables is set to (v1,v2), where v1 == v2, then the range will be computed automatically. Note that the x-range values should be consistent with the way the independent variable is created (via INDEX, DISTANCE, or ARC_LENGTH).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetYAxisActor2D">
            <summary>
                <para>Set the plot range (range of independent and dependent variables) to plot. Data outside of the range will be clipped. If the plot range of either the x or y variables is set to (v1,v2), where v1 == v2, then the range will be computed automatically. Note that the x-range values should be consistent with the way the independent variable is created (via INDEX, DISTANCE, or ARC_LENGTH).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetXAxisActor2D">
            <summary>
                <para>Retrieve handles to the X and Y axis (so that you can set their text properties for example)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetYTitle">
            <summary>
                <para>Set/Get the title of the x-y plot, and the title along the  x and y axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetYTitle(System.String)">
            <summary>
                <para>Set/Get the title of the x-y plot, and the title along the  x and y axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetXTitle">
            <summary>
                <para>Set/Get the title of the x-y plot, and the title along the  x and y axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetXTitle(System.String)">
            <summary>
                <para>Set/Get the title of the x-y plot, and the title along the  x and y axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetTitle">
            <summary>
                <para>Set/Get the title of the x-y plot, and the title along the  x and y axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetTitle(System.String)">
            <summary>
                <para>Set/Get the title of the x-y plot, and the title along the  x and y axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetGlyphSource">
            <summary>
                <para>Retrieve handles to the legend box and glyph source. This is useful if you would like to change the default behavior of the legend box or glyph source. For example, the default glyph can be changed from a line to a vertex plus line, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetLegendActor">
            <summary>
                <para>Retrieve handles to the legend box and glyph source. This is useful if you would like to change the default behavior of the legend box or glyph source. For example, the default glyph can be changed from a line to a vertex plus line, etc.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.ReverseYAxisOff">
            <summary>
                <para>Normally the y-axis is plotted from minimum to maximum. Setting this instance variable causes the y-axis to be plotted from maximum to minimum. Note that boolean always applies to the y-axis even if ExchangeAxes is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.ReverseYAxisOn">
            <summary>
                <para>Normally the y-axis is plotted from minimum to maximum. Setting this instance variable causes the y-axis to be plotted from maximum to minimum. Note that boolean always applies to the y-axis even if ExchangeAxes is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetReverseYAxis">
            <summary>
                <para>Normally the y-axis is plotted from minimum to maximum. Setting this instance variable causes the y-axis to be plotted from maximum to minimum. Note that boolean always applies to the y-axis even if ExchangeAxes is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetReverseYAxis(System.Int32)">
            <summary>
                <para>Normally the y-axis is plotted from minimum to maximum. Setting this instance variable causes the y-axis to be plotted from maximum to minimum. Note that boolean always applies to the y-axis even if ExchangeAxes is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.ReverseXAxisOff">
            <summary>
                <para>Normally the x-axis is plotted from minimum to maximum. Setting this instance variable causes the x-axis to be plotted from maximum to minimum. Note that boolean always applies to the x-axis even if ExchangeAxes is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.ReverseXAxisOn">
            <summary>
                <para>Normally the x-axis is plotted from minimum to maximum. Setting this instance variable causes the x-axis to be plotted from maximum to minimum. Note that boolean always applies to the x-axis even if ExchangeAxes is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetReverseXAxis">
            <summary>
                <para>Normally the x-axis is plotted from minimum to maximum. Setting this instance variable causes the x-axis to be plotted from maximum to minimum. Note that boolean always applies to the x-axis even if ExchangeAxes is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetReverseXAxis(System.Int32)">
            <summary>
                <para>Normally the x-axis is plotted from minimum to maximum. Setting this instance variable causes the x-axis to be plotted from maximum to minimum. Note that boolean always applies to the x-axis even if ExchangeAxes is set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.ExchangeAxesOff">
            <summary>
                <para>Enable/Disable exchange of the x-y axes (i.e., what was x becomes y, and vice-versa). Exchanging axes affects the labeling as well.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.ExchangeAxesOn">
            <summary>
                <para>Enable/Disable exchange of the x-y axes (i.e., what was x becomes y, and vice-versa). Exchanging axes affects the labeling as well.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetExchangeAxes">
            <summary>
                <para>Enable/Disable exchange of the x-y axes (i.e., what was x becomes y, and vice-versa). Exchanging axes affects the labeling as well.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetExchangeAxes(System.Int32)">
            <summary>
                <para>Enable/Disable exchange of the x-y axes (i.e., what was x becomes y, and vice-versa). Exchanging axes affects the labeling as well.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetDataObjectYComponent(System.Int32)">
            <summary>
                <para>Specify which component of the input data object to use as the dependent variable for the ith input data object. (This ivar is ignored if plotting the index.) Note that the value is interpreted differently depending on DataObjectPlotMode. If the mode is Rows, then the value of DataObjectYComponent is the row number; otherwise it's the column number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetDataObjectYComponent(System.Int32,System.Int32)">
            <summary>
                <para>Specify which component of the input data object to use as the dependent variable for the ith input data object. (This ivar is ignored if plotting the index.) Note that the value is interpreted differently depending on DataObjectPlotMode. If the mode is Rows, then the value of DataObjectYComponent is the row number; otherwise it's the column number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetDataObjectXComponent(System.Int32)">
            <summary>
                <para>Specify which component of the input data object to use as the independent variable for the ith input data object. (This ivar is ignored if plotting the index.) Note that the value is interpreted differently depending on DataObjectPlotMode. If the mode is Rows, then the value of DataObjectXComponent is the row number; otherwise it's the column number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetDataObjectXComponent(System.Int32,System.Int32)">
            <summary>
                <para>Specify which component of the input data object to use as the independent variable for the ith input data object. (This ivar is ignored if plotting the index.) Note that the value is interpreted differently depending on DataObjectPlotMode. If the mode is Rows, then the value of DataObjectXComponent is the row number; otherwise it's the column number.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetDataObjectPlotModeAsString">
            <summary>
                <para>Indicate whether to plot rows or columns. If plotting rows, then the dependent variables is taken from a specified row, versus rows (y). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetDataObjectPlotModeToColumns">
            <summary>
                <para>Indicate whether to plot rows or columns. If plotting rows, then the dependent variables is taken from a specified row, versus rows (y). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetDataObjectPlotModeToRows">
            <summary>
                <para>Indicate whether to plot rows or columns. If plotting rows, then the dependent variables is taken from a specified row, versus rows (y). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetDataObjectPlotMode">
            <summary>
                <para>Indicate whether to plot rows or columns. If plotting rows, then the dependent variables is taken from a specified row, versus rows (y). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetDataObjectPlotModeMaxValue">
            <summary>
                <para>Indicate whether to plot rows or columns. If plotting rows, then the dependent variables is taken from a specified row, versus rows (y). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetDataObjectPlotModeMinValue">
            <summary>
                <para>Indicate whether to plot rows or columns. If plotting rows, then the dependent variables is taken from a specified row, versus rows (y). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetDataObjectPlotMode(System.Int32)">
            <summary>
                <para>Indicate whether to plot rows or columns. If plotting rows, then the dependent variables is taken from a specified row, versus rows (y). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetDataObjectInputList">
            <summary>
                <para>Indicate whether to plot rows or columns. If plotting rows, then the dependent variables is taken from a specified row, versus rows (y). </para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.RemoveDataObjectInput(vtk.vtkDataObject)">
            <summary>
                <para>Remove a dataset from the list of data to append.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.AddDataObjectInput(vtk.vtkDataObject)">
            <summary>
                <para>Add a dataset to the list of data to append.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetXValuesAsString">
            <summary>
                <para>Specify how the independent (x) variable is computed from the points. The independent variable can be the scalar/point index (i.e., point id), the accumulated arc length along the points, the normalized arc length, or by component value. If plotting datasets (e.g., points), the value that is used is specified by the PointComponent ivar.  (Note: these methods also control how field data is plotted. Field data is usually plotted by value or index, if plotting length 1-dimensional length measures are used.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetXValuesToValue">
            <summary>
                <para>Specify how the independent (x) variable is computed from the points. The independent variable can be the scalar/point index (i.e., point id), the accumulated arc length along the points, the normalized arc length, or by component value. If plotting datasets (e.g., points), the value that is used is specified by the PointComponent ivar.  (Note: these methods also control how field data is plotted. Field data is usually plotted by value or index, if plotting length 1-dimensional length measures are used.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetXValuesToNormalizedArcLength">
            <summary>
                <para>Specify how the independent (x) variable is computed from the points. The independent variable can be the scalar/point index (i.e., point id), the accumulated arc length along the points, the normalized arc length, or by component value. If plotting datasets (e.g., points), the value that is used is specified by the PointComponent ivar.  (Note: these methods also control how field data is plotted. Field data is usually plotted by value or index, if plotting length 1-dimensional length measures are used.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetXValuesToArcLength">
            <summary>
                <para>Specify how the independent (x) variable is computed from the points. The independent variable can be the scalar/point index (i.e., point id), the accumulated arc length along the points, the normalized arc length, or by component value. If plotting datasets (e.g., points), the value that is used is specified by the PointComponent ivar.  (Note: these methods also control how field data is plotted. Field data is usually plotted by value or index, if plotting length 1-dimensional length measures are used.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetXValuesToIndex">
            <summary>
                <para>Specify how the independent (x) variable is computed from the points. The independent variable can be the scalar/point index (i.e., point id), the accumulated arc length along the points, the normalized arc length, or by component value. If plotting datasets (e.g., points), the value that is used is specified by the PointComponent ivar.  (Note: these methods also control how field data is plotted. Field data is usually plotted by value or index, if plotting length 1-dimensional length measures are used.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetXValues">
            <summary>
                <para>Specify how the independent (x) variable is computed from the points. The independent variable can be the scalar/point index (i.e., point id), the accumulated arc length along the points, the normalized arc length, or by component value. If plotting datasets (e.g., points), the value that is used is specified by the PointComponent ivar.  (Note: these methods also control how field data is plotted. Field data is usually plotted by value or index, if plotting length 1-dimensional length measures are used.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetXValuesMaxValue">
            <summary>
                <para>Specify how the independent (x) variable is computed from the points. The independent variable can be the scalar/point index (i.e., point id), the accumulated arc length along the points, the normalized arc length, or by component value. If plotting datasets (e.g., points), the value that is used is specified by the PointComponent ivar.  (Note: these methods also control how field data is plotted. Field data is usually plotted by value or index, if plotting length 1-dimensional length measures are used.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetXValuesMinValue">
            <summary>
                <para>Specify how the independent (x) variable is computed from the points. The independent variable can be the scalar/point index (i.e., point id), the accumulated arc length along the points, the normalized arc length, or by component value. If plotting datasets (e.g., points), the value that is used is specified by the PointComponent ivar.  (Note: these methods also control how field data is plotted. Field data is usually plotted by value or index, if plotting length 1-dimensional length measures are used.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetXValues(System.Int32)">
            <summary>
                <para>Specify how the independent (x) variable is computed from the points. The independent variable can be the scalar/point index (i.e., point id), the accumulated arc length along the points, the normalized arc length, or by component value. If plotting datasets (e.g., points), the value that is used is specified by the PointComponent ivar.  (Note: these methods also control how field data is plotted. Field data is usually plotted by value or index, if plotting length 1-dimensional length measures are used.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetPointComponent(System.Int32)">
            <summary>
                <para>If plotting points by value, which component to use to determine the value. This sets a value per each input dataset (i.e., the ith dataset).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.SetPointComponent(System.Int32,System.Int32)">
            <summary>
                <para>If plotting points by value, which component to use to determine the value. This sets a value per each input dataset (i.e., the ith dataset).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.GetInputList">
            <summary>
                <para>If plotting points by value, which component to use to determine the value. This sets a value per each input dataset (i.e., the ith dataset).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.RemoveAllInputs">
            <summary>
                <para>This removes all of the data set inputs,  but does not change the data object inputs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.RemoveInput(vtk.vtkDataSet)">
            <summary>
                <para>This removes all of the data set inputs,  but does not change the data object inputs.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.RemoveInput(vtk.vtkDataSet,System.String,System.Int32)">
            <summary>
                <para>Remove a dataset from the list of data to append.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.AddInput(vtk.vtkDataSet)">
            <summary>
                <para>Remove a dataset from the list of data to append.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkXYPlotActor.AddInput(vtk.vtkDataSet,System.String,System.Int32)">
            <summary>
                <para>Add a dataset to the list of data to append. The array name specifies which point array to plot.  If the array name is NULL, then the default scalars are used.  The array can have multiple components, but only the first component is ploted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPExodusReader.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.GetNumberOfFiles">
            <summary>
                <para>Return the number of files to be read.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.GetNumberOfFileNames">
            <summary>
                <para>Return the number of files to be read.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.GetFileRange">
            <summary>
                <para>Set the range of files that are being loaded. The range for single file should add to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.SetFileRange(System.Int32[])">
            <summary>
                <para>Set the range of files that are being loaded. The range for single file should add to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.SetFileRange(System.Int32,System.Int32)">
            <summary>
                <para>Set the range of files that are being loaded. The range for single file should add to 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.GetFilePrefix">
            <summary>
                <para>These methods tell the reader that the data is ditributed across multiple files. This is for distributed execution. It this case, pieces are mapped to files. The pattern should have one %d to format the file number. FileNumberRange is used to generate file numbers. I was thinking of having an arbitrary list of file numbers. This may happen in the future. (That is why there is no GetFileNumberRange method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.SetFilePrefix(System.String)">
            <summary>
                <para>These methods tell the reader that the data is ditributed across multiple files. This is for distributed execution. It this case, pieces are mapped to files. The pattern should have one %d to format the file number. FileNumberRange is used to generate file numbers. I was thinking of having an arbitrary list of file numbers. This may happen in the future. (That is why there is no GetFileNumberRange method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.GetFilePattern">
            <summary>
                <para>These methods tell the reader that the data is ditributed across multiple files. This is for distributed execution. It this case, pieces are mapped to files. The pattern should have one %d to format the file number. FileNumberRange is used to generate file numbers. I was thinking of having an arbitrary list of file numbers. This may happen in the future. (That is why there is no GetFileNumberRange method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPExodusReader.SetFilePattern(System.String)">
            <summary>
                <para>These methods tell the reader that the data is ditributed across multiple files. This is for distributed execution. It this case, pieces are mapped to files. The pattern should have one %d to format the file number. FileNumberRange is used to generate file numbers. I was thinking of having an arbitrary list of file numbers. This may happen in the future. (That is why there is no GetFileNumberRange method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this scaled text actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.ScalarVisibilityOff">
            <summary>
                <para>Turn on/off flag to control whether the symbol's scalar data is used to color the symbol. If off, the color of the  vtkLegendBoxActor is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.ScalarVisibilityOn">
            <summary>
                <para>Turn on/off flag to control whether the symbol's scalar data is used to color the symbol. If off, the color of the  vtkLegendBoxActor is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetScalarVisibility">
            <summary>
                <para>Turn on/off flag to control whether the symbol's scalar data is used to color the symbol. If off, the color of the  vtkLegendBoxActor is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetScalarVisibility(System.Int32)">
            <summary>
                <para>Turn on/off flag to control whether the symbol's scalar data is used to color the symbol. If off, the color of the  vtkLegendBoxActor is used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetPadding">
            <summary>
                <para>Set/Get the padding between the legend entries and the border. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetPaddingMaxValue">
            <summary>
                <para>Set/Get the padding between the legend entries and the border. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetPaddingMinValue">
            <summary>
                <para>Set/Get the padding between the legend entries and the border. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetPadding(System.Int32)">
            <summary>
                <para>Set/Get the padding between the legend entries and the border. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetBoxProperty">
            <summary>
                <para>Get the box vtkProperty2D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.BoxOff">
            <summary>
                <para>Set/Get the flag that controls whether a box will be drawn/filled corresponding to the legend box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.BoxOn">
            <summary>
                <para>Set/Get the flag that controls whether a box will be drawn/filled corresponding to the legend box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetBox">
            <summary>
                <para>Set/Get the flag that controls whether a box will be drawn/filled corresponding to the legend box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetBox(System.Int32)">
            <summary>
                <para>Set/Get the flag that controls whether a box will be drawn/filled corresponding to the legend box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.LockBorderOff">
            <summary>
                <para>Set/Get the flag that controls whether the border and legend placement is locked into the rectangle defined by (Position,Position2). If off, then the legend box will adjust its size so that the border fits nicely around the text and symbols. (The ivar is off by default.) Note: the legend box is guaranteed to lie within the original border definition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.LockBorderOn">
            <summary>
                <para>Set/Get the flag that controls whether the border and legend placement is locked into the rectangle defined by (Position,Position2). If off, then the legend box will adjust its size so that the border fits nicely around the text and symbols. (The ivar is off by default.) Note: the legend box is guaranteed to lie within the original border definition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetLockBorder">
            <summary>
                <para>Set/Get the flag that controls whether the border and legend placement is locked into the rectangle defined by (Position,Position2). If off, then the legend box will adjust its size so that the border fits nicely around the text and symbols. (The ivar is off by default.) Note: the legend box is guaranteed to lie within the original border definition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetLockBorder(System.Int32)">
            <summary>
                <para>Set/Get the flag that controls whether the border and legend placement is locked into the rectangle defined by (Position,Position2). If off, then the legend box will adjust its size so that the border fits nicely around the text and symbols. (The ivar is off by default.) Note: the legend box is guaranteed to lie within the original border definition.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.BorderOff">
            <summary>
                <para>Set/Get the flag that controls whether a border will be drawn around the legend box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.BorderOn">
            <summary>
                <para>Set/Get the flag that controls whether a border will be drawn around the legend box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetBorder">
            <summary>
                <para>Set/Get the flag that controls whether a border will be drawn around the legend box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetBorder(System.Int32)">
            <summary>
                <para>Set/Get the flag that controls whether a border will be drawn around the legend box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetEntryTextProperty">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetEntryTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetEntryColor(System.Int32)">
            <summary>
                <para>Add an entry to the legend box. You must supply a vtkPolyData to be used as a symbol (it can be NULL) and a text string (which also can be NULL). The vtkPolyData is assumed to be defined in the x-y plane, and the text is assumed to be a single line in height. Note that when this method is invoked previous entries are deleted. Also supply a text string and optionally a color. (If a color is not specified, then the entry color is the same as this actor's color.) (Note: use the set methods when you use SetNumberOfEntries().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetEntryString(System.Int32)">
            <summary>
                <para>Add an entry to the legend box. You must supply a vtkPolyData to be used as a symbol (it can be NULL) and a text string (which also can be NULL). The vtkPolyData is assumed to be defined in the x-y plane, and the text is assumed to be a single line in height. Note that when this method is invoked previous entries are deleted. Also supply a text string and optionally a color. (If a color is not specified, then the entry color is the same as this actor's color.) (Note: use the set methods when you use SetNumberOfEntries().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetEntrySymbol(System.Int32)">
            <summary>
                <para>Add an entry to the legend box. You must supply a vtkPolyData to be used as a symbol (it can be NULL) and a text string (which also can be NULL). The vtkPolyData is assumed to be defined in the x-y plane, and the text is assumed to be a single line in height. Note that when this method is invoked previous entries are deleted. Also supply a text string and optionally a color. (If a color is not specified, then the entry color is the same as this actor's color.) (Note: use the set methods when you use SetNumberOfEntries().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetEntryColor(System.Int32,System.Double,System.Double,System.Double)">
            <summary>
                <para>Add an entry to the legend box. You must supply a vtkPolyData to be used as a symbol (it can be NULL) and a text string (which also can be NULL). The vtkPolyData is assumed to be defined in the x-y plane, and the text is assumed to be a single line in height. Note that when this method is invoked previous entries are deleted. Also supply a text string and optionally a color. (If a color is not specified, then the entry color is the same as this actor's color.) (Note: use the set methods when you use SetNumberOfEntries().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetEntryColor(System.Int32,System.Double[])">
            <summary>
                <para>Add an entry to the legend box. You must supply a vtkPolyData to be used as a symbol (it can be NULL) and a text string (which also can be NULL). The vtkPolyData is assumed to be defined in the x-y plane, and the text is assumed to be a single line in height. Note that when this method is invoked previous entries are deleted. Also supply a text string and optionally a color. (If a color is not specified, then the entry color is the same as this actor's color.) (Note: use the set methods when you use SetNumberOfEntries().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetEntryString(System.Int32,System.String)">
            <summary>
                <para>Add an entry to the legend box. You must supply a vtkPolyData to be used as a symbol (it can be NULL) and a text string (which also can be NULL). The vtkPolyData is assumed to be defined in the x-y plane, and the text is assumed to be a single line in height. Note that when this method is invoked previous entries are deleted. Also supply a text string and optionally a color. (If a color is not specified, then the entry color is the same as this actor's color.) (Note: use the set methods when you use SetNumberOfEntries().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetEntrySymbol(System.Int32,vtk.vtkPolyData)">
            <summary>
                <para>Add an entry to the legend box. You must supply a vtkPolyData to be used as a symbol (it can be NULL) and a text string (which also can be NULL). The vtkPolyData is assumed to be defined in the x-y plane, and the text is assumed to be a single line in height. Note that when this method is invoked previous entries are deleted. Also supply a text string and optionally a color. (If a color is not specified, then the entry color is the same as this actor's color.) (Note: use the set methods when you use SetNumberOfEntries().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetEntry(System.Int32,vtk.vtkPolyData,System.String,System.Double[])">
            <summary>
                <para>Add an entry to the legend box. You must supply a vtkPolyData to be used as a symbol (it can be NULL) and a text string (which also can be NULL). The vtkPolyData is assumed to be defined in the x-y plane, and the text is assumed to be a single line in height. Note that when this method is invoked previous entries are deleted. Also supply a text string and optionally a color. (If a color is not specified, then the entry color is the same as this actor's color.) (Note: use the set methods when you use SetNumberOfEntries().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.GetNumberOfEntries">
            <summary>
                <para>Add an entry to the legend box. You must supply a vtkPolyData to be used as a symbol (it can be NULL) and a text string (which also can be NULL). The vtkPolyData is assumed to be defined in the x-y plane, and the text is assumed to be a single line in height. Note that when this method is invoked previous entries are deleted. Also supply a text string and optionally a color. (If a color is not specified, then the entry color is the same as this actor's color.) (Note: use the set methods when you use SetNumberOfEntries().)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLegendBoxActor.SetNumberOfEntries(System.Int32)">
            <summary>
                <para>Specify the number of entries in the legend box.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.GetAddInputValues">
            <summary>
                <para>If AddInputValues is true, the output values of this filter will be offset from the input values.  The effect is exactly equivalent to having an identity transform of weight 1 added into each output point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.SetAddInputValues(System.Int32)">
            <summary>
                <para>If AddInputValues is true, the output values of this filter will be offset from the input values.  The effect is exactly equivalent to having an identity transform of weight 1 added into each output point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.AddInputValuesOff">
            <summary>
                <para>If AddInputValues is true, the output values of this filter will be offset from the input values.  The effect is exactly equivalent to having an identity transform of weight 1 added into each output point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.AddInputValuesOn">
            <summary>
                <para>If AddInputValues is true, the output values of this filter will be offset from the input values.  The effect is exactly equivalent to having an identity transform of weight 1 added into each output point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.GetNumberOfTransforms">
            <summary>
                <para>Set the number of transforms for the filter.  References to non-existent filter numbers in the data array is equivalent to a weight of zero (i.e., no contribution of that filter or weight).  The maximum number of  transforms is limited to 65536 if transform index arrays are used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.SetNumberOfTransforms(System.Int32)">
            <summary>
                <para>Set the number of transforms for the filter.  References to non-existent filter numbers in the data array is equivalent to a weight of zero (i.e., no contribution of that filter or weight).  The maximum number of  transforms is limited to 65536 if transform index arrays are used.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.GetTransform(System.Int32)">
            <summary>
                <para>Set or Get one of the filter's transforms. The transform number must be less than the number of transforms allocated for the object.  Setting a transform slot to NULL is equivalent to assigning an overriding weight of zero to that filter slot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.SetTransform(vtk.vtkAbstractTransform,System.Int32)">
            <summary>
                <para>Set or Get one of the filter's transforms. The transform number must be less than the number of transforms allocated for the object.  Setting a transform slot to NULL is equivalent to assigning an overriding weight of zero to that filter slot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.GetCellDataWeightArray">
            <summary>
                <para>The CellDataWeightArray is analogous to the WeightArray, except for CellData.  The array is searched for first in the CellData  FieldData, then in the input's FieldData.  The data array must have a tuple for each cell.  This array is used to transform only normals and vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.SetCellDataWeightArray(System.String)">
            <summary>
                <para>The CellDataWeightArray is analogous to the WeightArray, except for CellData.  The array is searched for first in the CellData  FieldData, then in the input's FieldData.  The data array must have a tuple for each cell.  This array is used to transform only normals and vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.GetTransformIndexArray">
            <summary>
                <para>TransformIndexArray is the string name of the DataArray in the input's FieldData that holds the indices for the transforms for each point. These indices are used to select which transforms each weight of the DataArray refers.  If the TransformIndexArray is not specified, the weights of each point are assumed to map directly to a transform. This DataArray must be of type UnsignedShort, which effectively limits the number of transforms to 65536 if a transform index  array is used.</para>
                <para>The filter will first look for the array in the input's PointData FieldData.  If the array isn't there, the filter looks in the input's FieldData.  The TransformIndexArray can have tuples of any  length, but must have a tuple for every point in the input data set. This array transforms points, normals, and vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.SetTransformIndexArray(System.String)">
            <summary>
                <para>TransformIndexArray is the string name of the DataArray in the input's FieldData that holds the indices for the transforms for each point. These indices are used to select which transforms each weight of the DataArray refers.  If the TransformIndexArray is not specified, the weights of each point are assumed to map directly to a transform. This DataArray must be of type UnsignedShort, which effectively limits the number of transforms to 65536 if a transform index  array is used.</para>
                <para>The filter will first look for the array in the input's PointData FieldData.  If the array isn't there, the filter looks in the input's FieldData.  The TransformIndexArray can have tuples of any  length, but must have a tuple for every point in the input data set. This array transforms points, normals, and vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.GetWeightArray">
            <summary>
                <para>WeightArray is the string name of the DataArray in the input's FieldData that holds the weighting coefficients for each point. The filter will first look for the array in the input's PointData FieldData.  If the array isn't there, the filter looks in the input's FieldData.  The WeightArray can have tuples of any length, but must have a tuple for every point in the input data set. This array transforms points, normals, and vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.SetWeightArray(System.String)">
            <summary>
                <para>WeightArray is the string name of the DataArray in the input's FieldData that holds the weighting coefficients for each point. The filter will first look for the array in the input's PointData FieldData.  If the array isn't there, the filter looks in the input's FieldData.  The WeightArray can have tuples of any length, but must have a tuple for every point in the input data set. This array transforms points, normals, and vectors.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWeightedTransformFilter.GetMTime">
            <summary>
                <para>Return the MTime also considering the filter's transforms.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetShowSliceAndImage">
            <summary>
                <para>Even if there is an image actor, should &lt;slice&gt; and &lt;image&gt; be displayed?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetShowSliceAndImage(System.Int32)">
            <summary>
                <para>Even if there is an image actor, should &lt;slice&gt; and &lt;image&gt; be displayed?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.ShowSliceAndImageOff">
            <summary>
                <para>Even if there is an image actor, should &lt;slice&gt; and &lt;image&gt; be displayed?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.ShowSliceAndImageOn">
            <summary>
                <para>Even if there is an image actor, should &lt;slice&gt; and &lt;image&gt; be displayed?</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetTextProperty">
            <summary>
                <para>Set/Get the text property of all corners.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the text property of all corners.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetLevelScale">
            <summary>
                <para>Set the value to scale the level by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetLevelScale(System.Double)">
            <summary>
                <para>Set the value to scale the level by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetLevelShift">
            <summary>
                <para>Set the value to shift the level by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetLevelShift(System.Double)">
            <summary>
                <para>Set the value to shift the level by.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetWindowLevel">
            <summary>
                <para>Set an instance of vtkImageMapToWindowLevelColors to use for looking at window level changes</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetWindowLevel(vtk.vtkImageMapToWindowLevelColors)">
            <summary>
                <para>Set an instance of vtkImageMapToWindowLevelColors to use for looking at window level changes</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetImageActor">
            <summary>
                <para>Set an image actor to look at for slice information</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetImageActor(vtk.vtkImageActor)">
            <summary>
                <para>Set an image actor to look at for slice information</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.CopyAllTextsFrom(vtk.vtkCornerAnnotation)">
            <summary>
                <para>Set/Get the text to be displayed for each corner</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.ClearAllTexts">
            <summary>
                <para>Set/Get the text to be displayed for each corner</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetText(System.Int32)">
            <summary>
                <para>Set/Get the text to be displayed for each corner</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetText(System.Int32,System.String)">
            <summary>
                <para>Set/Get the text to be displayed for each corner</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetNonlinearFontScaleFactor">
            <summary>
                <para>Set/Get font scaling factors The font size, f, is calculated as the largest possible value such that the annotations for the given viewport do not overlap.  This font size is scaled non-linearly with the viewport size, to maintain an acceptable readable size at larger viewport sizes,  without being too big. f' = linearScale * pow(f,nonlinearScale)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetNonlinearFontScaleFactor(System.Double)">
            <summary>
                <para>Set/Get font scaling factors The font size, f, is calculated as the largest possible value such that the annotations for the given viewport do not overlap.  This font size is scaled non-linearly with the viewport size, to maintain an acceptable readable size at larger viewport sizes,  without being too big. f' = linearScale * pow(f,nonlinearScale)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetLinearFontScaleFactor">
            <summary>
                <para>Set/Get font scaling factors The font size, f, is calculated as the largest possible value such that the annotations for the given viewport do not overlap.  This font size is scaled non-linearly with the viewport size, to maintain an acceptable readable size at larger viewport sizes,  without being too big. f' = linearScale * pow(f,nonlinearScale)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetLinearFontScaleFactor(System.Double)">
            <summary>
                <para>Set/Get font scaling factors The font size, f, is calculated as the largest possible value such that the annotations for the given viewport do not overlap.  This font size is scaled non-linearly with the viewport size, to maintain an acceptable readable size at larger viewport sizes,  without being too big. f' = linearScale * pow(f,nonlinearScale)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetMaximumFontSize">
            <summary>
                <para>Set/Get the minimum/maximum size font that will be shown. If the font drops below the minimum size it will not be rendered.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetMaximumFontSize(System.Int32)">
            <summary>
                <para>Set/Get the minimum/maximum size font that will be shown. If the font drops below the minimum size it will not be rendered.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetMinimumFontSize">
            <summary>
                <para>Set/Get the minimum/maximum size font that will be shown. If the font drops below the minimum size it will not be rendered.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetMinimumFontSize(System.Int32)">
            <summary>
                <para>Set/Get the minimum/maximum size font that will be shown. If the font drops below the minimum size it will not be rendered.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.GetMaximumLineHeight">
            <summary>
                <para>Set/Get the maximum height of a line of text as a  percentage of the vertical area allocated to this scaled text actor. Defaults to 1.0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.SetMaximumLineHeight(System.Double)">
            <summary>
                <para>Set/Get the maximum height of a line of text as a  percentage of the vertical area allocated to this scaled text actor. Defaults to 1.0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.RenderOverlay(vtk.vtkViewport)">
            <summary>
                <para>Draw the scalar bar and annotation text to the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Draw the scalar bar and annotation text to the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCornerAnnotation.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Draw the scalar bar and annotation text to the screen.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBLight.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRIBLight.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRIBLight.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRIBLight.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRIBLight.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRIBLight.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDSPFilterDefinition.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkDSPFilterDefinition.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAxesActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAxesActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAxesActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAxesActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAxesActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAxesActor.AxisLabelsOff">
            <summary>
                <para>Enable/disable drawing the axis labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.AxisLabelsOn">
            <summary>
                <para>Enable/disable drawing the axis labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetAxisLabels">
            <summary>
                <para>Enable/disable drawing the axis labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetAxisLabels(System.Int32)">
            <summary>
                <para>Enable/disable drawing the axis labels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetZAxisLabelText">
            <summary>
                <para>Set/get the label text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetZAxisLabelText(System.String)">
            <summary>
                <para>Set/get the label text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetYAxisLabelText">
            <summary>
                <para>Set/get the label text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetYAxisLabelText(System.String)">
            <summary>
                <para>Set/get the label text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetXAxisLabelText">
            <summary>
                <para>Set/get the label text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetXAxisLabelText(System.String)">
            <summary>
                <para>Set/get the label text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetZAxisCaptionActor2D">
            <summary>
                <para>Set/get the label text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetYAxisCaptionActor2D">
            <summary>
                <para>Retrieve handles to the X, Y and Z axis (so that you can set their text properties for example)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetXAxisCaptionActor2D">
            <summary>
                <para>Retrieve handles to the X, Y and Z axis (so that you can set their text properties for example)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetZAxisShaftProperty">
            <summary>
                <para>Get the shaft properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetYAxisShaftProperty">
            <summary>
                <para>Get the shaft properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetXAxisShaftProperty">
            <summary>
                <para>Get the shaft properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetZAxisTipProperty">
            <summary>
                <para>Get the tip properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetYAxisTipProperty">
            <summary>
                <para>Get the tip properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetXAxisTipProperty">
            <summary>
                <para>Get the tip properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetUserDefinedShaft">
            <summary>
                <para>Set the user defined shaft polydata.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetUserDefinedShaft(vtk.vtkPolyData)">
            <summary>
                <para>Set the user defined shaft polydata.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetUserDefinedTip">
            <summary>
                <para>Set the user defined tip polydata.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetUserDefinedTip(vtk.vtkPolyData)">
            <summary>
                <para>Set the user defined tip polydata.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetTipType">
            <summary>
                <para>Set the type of the tip to a cone, sphere, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetTipTypeToUserDefined">
            <summary>
                <para>Set the type of the tip to a cone, sphere, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetTipTypeToSphere">
            <summary>
                <para>Set the type of the tip to a cone, sphere, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetTipTypeToCone">
            <summary>
                <para>Set the type of the tip to a cone, sphere, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetTipType(System.Int32)">
            <summary>
                <para>Set the type of the tip to a cone, sphere, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetShaftType">
            <summary>
                <para>Set the type of the shaft to a cylinder, line, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetShaftTypeToUserDefined">
            <summary>
                <para>Set the type of the shaft to a cylinder, line, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetShaftTypeToLine">
            <summary>
                <para>Set the type of the shaft to a cylinder, line, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetShaftTypeToCylinder">
            <summary>
                <para>Set the type of the shaft to a cylinder, line, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetShaftType(System.Int32)">
            <summary>
                <para>Set the type of the shaft to a cylinder, line, or user defined geometry.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetCylinderRadius">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetCylinderRadiusMaxValue">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetCylinderRadiusMinValue">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetCylinderRadius(System.Double)">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetSphereRadius">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetSphereRadiusMaxValue">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetSphereRadiusMinValue">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetSphereRadius(System.Double)">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetConeRadius">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetConeRadiusMaxValue">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetConeRadiusMinValue">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetConeRadius(System.Double)">
            <summary>
                <para>Set/get the radius of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetCylinderResolution">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetCylinderResolutionMaxValue">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetCylinderResolutionMinValue">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetCylinderResolution(System.Int32)">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetSphereResolution">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetSphereResolutionMaxValue">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetSphereResolutionMinValue">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetSphereResolution(System.Int32)">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetConeResolution">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetConeResolutionMaxValue">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetConeResolutionMinValue">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetConeResolution(System.Int32)">
            <summary>
                <para>Set/get the resolution of the pieces of the axes actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetNormalizedLabelPosition">
            <summary>
                <para>Set the normalized (0-1) position of the label along the length of the shaft.  A value &gt; 1 is permissible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetNormalizedLabelPosition(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the normalized (0-1) position of the label along the length of the shaft.  A value &gt; 1 is permissible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetNormalizedLabelPosition(System.Double[])">
            <summary>
                <para>Set the normalized (0-1) position of the label along the length of the shaft.  A value &gt; 1 is permissible.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetNormalizedTipLength">
            <summary>
                <para>Set the normalized (0-1) length of the tip.  Normally, this would be 1 - the normalized length of the shaft.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetNormalizedTipLength(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the normalized (0-1) length of the tip.  Normally, this would be 1 - the normalized length of the shaft.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetNormalizedTipLength(System.Double[])">
            <summary>
                <para>Set the normalized (0-1) length of the tip.  Normally, this would be 1 - the normalized length of the shaft.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetNormalizedShaftLength">
            <summary>
                <para>Set the normalized (0-1) length of the shaft.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetNormalizedShaftLength(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the normalized (0-1) length of the shaft.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetNormalizedShaftLength(System.Double[])">
            <summary>
                <para>Set the normalized (0-1) length of the shaft.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetTotalLength">
            <summary>
                <para>Set the total length of the axes in 3 dimensions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetTotalLength(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set the total length of the axes in 3 dimensions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.SetTotalLength(System.Double[])">
            <summary>
                <para>Set the total length of the axes in 3 dimensions.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetRedrawMTime">
            <summary>
                <para>Return the mtime of anything that would cause the rendered image to  appear differently. Usually this involves checking the mtime of the  prop plus anything else it depends on such as properties, textures etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetMTime">
            <summary>
                <para>Get the actors mtime plus consider its properties and texture if set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetBounds">
            <summary>
                <para>Get the bounds for this Actor as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax). (The method GetBounds(double bounds[6]) is available from the superclass.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetBounds(System.Double[])">
            <summary>
                <para>Get the bounds for this Actor as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax). (The method GetBounds(double bounds[6]) is available from the superclass.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of an axes actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.RenderOverlay(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAxesActor.GetActors(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of this scaled text actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetCaptionTextProperty">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetCaptionTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the text property.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetTextActor">
            <summary>
                <para>Get the text actor used by the caption. This is useful if you want to control justification and other characteristics of the text actor.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetPadding">
            <summary>
                <para>Set/Get the padding between the caption and the border. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetPaddingMaxValue">
            <summary>
                <para>Set/Get the padding between the caption and the border. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetPaddingMinValue">
            <summary>
                <para>Set/Get the padding between the caption and the border. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetPadding(System.Int32)">
            <summary>
                <para>Set/Get the padding between the caption and the border. The value is specified in pixels.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetMaximumLeaderGlyphSize">
            <summary>
                <para>Specify the maximum size of the leader head (if any) in pixels. This  is used in conjunction with LeaderGlyphSize to cap the maximum size of the LeaderGlyph.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetMaximumLeaderGlyphSizeMaxValue">
            <summary>
                <para>Specify the maximum size of the leader head (if any) in pixels. This  is used in conjunction with LeaderGlyphSize to cap the maximum size of the LeaderGlyph.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetMaximumLeaderGlyphSizeMinValue">
            <summary>
                <para>Specify the maximum size of the leader head (if any) in pixels. This  is used in conjunction with LeaderGlyphSize to cap the maximum size of the LeaderGlyph.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetMaximumLeaderGlyphSize(System.Int32)">
            <summary>
                <para>Specify the maximum size of the leader head (if any) in pixels. This  is used in conjunction with LeaderGlyphSize to cap the maximum size of the LeaderGlyph.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetLeaderGlyphSize">
            <summary>
                <para>Specify the relative size of the leader head. This is expressed as a fraction of the size (diagonal length) of the renderer. The leader head is automatically scaled so that window resize, zooming or other  camera motion results in proportional changes in size to the leader glyph.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetLeaderGlyphSizeMaxValue">
            <summary>
                <para>Specify the relative size of the leader head. This is expressed as a fraction of the size (diagonal length) of the renderer. The leader head is automatically scaled so that window resize, zooming or other  camera motion results in proportional changes in size to the leader glyph.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetLeaderGlyphSizeMinValue">
            <summary>
                <para>Specify the relative size of the leader head. This is expressed as a fraction of the size (diagonal length) of the renderer. The leader head is automatically scaled so that window resize, zooming or other  camera motion results in proportional changes in size to the leader glyph.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetLeaderGlyphSize(System.Double)">
            <summary>
                <para>Specify the relative size of the leader head. This is expressed as a fraction of the size (diagonal length) of the renderer. The leader head is automatically scaled so that window resize, zooming or other  camera motion results in proportional changes in size to the leader glyph.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetLeaderGlyph">
            <summary>
                <para>Specify a glyph to be used as the leader "head". This could be something like an arrow or sphere. If not specified, no glyph is drawn. Note that the glyph is assumed to be aligned along the x-axis and is rotated about the origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetLeaderGlyph(vtk.vtkPolyData)">
            <summary>
                <para>Specify a glyph to be used as the leader "head". This could be something like an arrow or sphere. If not specified, no glyph is drawn. Note that the glyph is assumed to be aligned along the x-axis and is rotated about the origin.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.ThreeDimensionalLeaderOff">
            <summary>
                <para>Indicate whether the leader is 2D (no hidden line) or 3D (z-buffered).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.ThreeDimensionalLeaderOn">
            <summary>
                <para>Indicate whether the leader is 2D (no hidden line) or 3D (z-buffered).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetThreeDimensionalLeader">
            <summary>
                <para>Indicate whether the leader is 2D (no hidden line) or 3D (z-buffered).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetThreeDimensionalLeader(System.Int32)">
            <summary>
                <para>Indicate whether the leader is 2D (no hidden line) or 3D (z-buffered).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.LeaderOff">
            <summary>
                <para>Enable/disable drawing a "line" from the caption to the  attachment point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.LeaderOn">
            <summary>
                <para>Enable/disable drawing a "line" from the caption to the  attachment point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetLeader">
            <summary>
                <para>Enable/disable drawing a "line" from the caption to the  attachment point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetLeader(System.Int32)">
            <summary>
                <para>Enable/disable drawing a "line" from the caption to the  attachment point.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.BorderOff">
            <summary>
                <para>Enable/disable the placement of a border around the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.BorderOn">
            <summary>
                <para>Enable/disable the placement of a border around the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetBorder">
            <summary>
                <para>Enable/disable the placement of a border around the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetBorder(System.Int32)">
            <summary>
                <para>Enable/disable the placement of a border around the text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetAttachmentPoint">
            <summary>
                <para>Set/Get the attachment point for the caption. By default, the attachment point is defined in world coordinates, but this can be changed using vtkCoordinate methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetAttachmentPoint(System.Double[])">
            <summary>
                <para>Set/Get the attachment point for the caption. By default, the attachment point is defined in world coordinates, but this can be changed using vtkCoordinate methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetAttachmentPoint(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the attachment point for the caption. By default, the attachment point is defined in world coordinates, but this can be changed using vtkCoordinate methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetAttachmentPointCoordinate">
            <summary>
                <para>Set/Get the attachment point for the caption. By default, the attachment point is defined in world coordinates, but this can be changed using vtkCoordinate methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.GetCaption">
            <summary>
                <para>Define the text to be placed in the caption. The text can be multiple lines (separated by "\n").</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCaptionActor2D.SetCaption(System.String)">
            <summary>
                <para>Define the text to be placed in the caption. The text can be multiple lines (separated by "\n").</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkTransformToGrid.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.GetOutput">
            <summary>
                <para>Get the output data object for a port on this algorithm.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.GetDisplacementShift">
            <summary>
                <para>Get the scale and shift to convert integer grid elements into real values:  dx = scale*di + shift.  If the grid is of double type, then scale = 1 and shift = 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.GetDisplacementScale">
            <summary>
                <para>Get the scale and shift to convert integer grid elements into real values:  dx = scale*di + shift.  If the grid is of double type, then scale = 1 and shift = 0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridScalarTypeToChar">
            <summary>
                <para>Get/Set the scalar type of the grid.  The default is double.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridScalarTypeToUnsignedChar">
            <summary>
                <para>Get/Set the scalar type of the grid.  The default is double.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridScalarTypeToUnsignedShort">
            <summary>
                <para>Get/Set the scalar type of the grid.  The default is double.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridScalarTypeToShort">
            <summary>
                <para>Get/Set the scalar type of the grid.  The default is double.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridScalarTypeToFloat">
            <summary>
                <para>Get/Set the scalar type of the grid.  The default is double.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.GetGridScalarType">
            <summary>
                <para>Get/Set the scalar type of the grid.  The default is double.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridScalarType(System.Int32)">
            <summary>
                <para>Get/Set the scalar type of the grid.  The default is double.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.GetGridSpacing">
            <summary>
                <para>Get/Set the spacing between samples in the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridSpacing(System.Double[])">
            <summary>
                <para>Get/Set the spacing between samples in the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridSpacing(System.Double,System.Double,System.Double)">
            <summary>
                <para>Get/Set the spacing between samples in the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.GetGridOrigin">
            <summary>
                <para>Get/Set the origin of the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridOrigin(System.Double[])">
            <summary>
                <para>Get/Set the origin of the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Get/Set the origin of the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.GetGridExtent">
            <summary>
                <para>Get/Set the extent of the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridExtent(System.Int32[])">
            <summary>
                <para>Get/Set the extent of the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetGridExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Get/Set the extent of the grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.GetInput">
            <summary>
                <para>Set/Get the transform which will be converted into a grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkTransformToGrid.SetInput(vtk.vtkAbstractTransform)">
            <summary>
                <para>Set/Get the transform which will be converted into a grid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.ComputeNormalsOff">
            <summary>
                <para>Compute normals based on the input image. Off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.ComputeNormalsOn">
            <summary>
                <para>Compute normals based on the input image. Off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetComputeNormals">
            <summary>
                <para>Compute normals based on the input image. Off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetComputeNormals(System.Int32)">
            <summary>
                <para>Compute normals based on the input image. Off by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.BoundaryVertexDeletionOff">
            <summary>
                <para>Turn on/off the deletion of vertices on the boundary of a mesh. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.BoundaryVertexDeletionOn">
            <summary>
                <para>Turn on/off the deletion of vertices on the boundary of a mesh. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetBoundaryVertexDeletion">
            <summary>
                <para>Turn on/off the deletion of vertices on the boundary of a mesh. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetBoundaryVertexDeletion(System.Int32)">
            <summary>
                <para>Turn on/off the deletion of vertices on the boundary of a mesh. This may limit the maximum reduction that may be achieved.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetRelativeError">
            <summary>
                <para>Specify the relative error of the mesh; that is, the error in height between the decimated mesh and the original height field normalized by the diagonal of the image.  You need to set this value only when the error measure is set to RelativeError.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetRelativeErrorMaxValue">
            <summary>
                <para>Specify the relative error of the mesh; that is, the error in height between the decimated mesh and the original height field normalized by the diagonal of the image.  You need to set this value only when the error measure is set to RelativeError.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetRelativeErrorMinValue">
            <summary>
                <para>Specify the relative error of the mesh; that is, the error in height between the decimated mesh and the original height field normalized by the diagonal of the image.  You need to set this value only when the error measure is set to RelativeError.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetRelativeError(System.Double)">
            <summary>
                <para>Specify the relative error of the mesh; that is, the error in height between the decimated mesh and the original height field normalized by the diagonal of the image.  You need to set this value only when the error measure is set to RelativeError.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetAbsoluteError">
            <summary>
                <para>Specify the absolute error of the mesh; that is, the error in height between the decimated mesh and the original height field.  You need to set this value only when the error measure is set to AbsoluteError.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetAbsoluteErrorMaxValue">
            <summary>
                <para>Specify the absolute error of the mesh; that is, the error in height between the decimated mesh and the original height field.  You need to set this value only when the error measure is set to AbsoluteError.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetAbsoluteErrorMinValue">
            <summary>
                <para>Specify the absolute error of the mesh; that is, the error in height between the decimated mesh and the original height field.  You need to set this value only when the error measure is set to AbsoluteError.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetAbsoluteError(System.Double)">
            <summary>
                <para>Specify the absolute error of the mesh; that is, the error in height between the decimated mesh and the original height field.  You need to set this value only when the error measure is set to AbsoluteError.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetReduction">
            <summary>
                <para>Specify the reduction of the mesh (represented as a fraction).  Note that a value of 0.10 means a 10% reduction.  You need to set this value only when the error measure is set to SpecifiedReduction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetReductionMaxValue">
            <summary>
                <para>Specify the reduction of the mesh (represented as a fraction).  Note that a value of 0.10 means a 10% reduction.  You need to set this value only when the error measure is set to SpecifiedReduction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetReductionMinValue">
            <summary>
                <para>Specify the reduction of the mesh (represented as a fraction).  Note that a value of 0.10 means a 10% reduction.  You need to set this value only when the error measure is set to SpecifiedReduction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetReduction(System.Double)">
            <summary>
                <para>Specify the reduction of the mesh (represented as a fraction).  Note that a value of 0.10 means a 10% reduction.  You need to set this value only when the error measure is set to SpecifiedReduction.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetNumberOfTriangles">
            <summary>
                <para>Specify the number of triangles to produce on output. (It is a good idea to make sure this is less than a tessellated mesh at full resolution.) You need to set this value only when the error measure is set to NumberOfTriangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetNumberOfTrianglesMaxValue">
            <summary>
                <para>Specify the number of triangles to produce on output. (It is a good idea to make sure this is less than a tessellated mesh at full resolution.) You need to set this value only when the error measure is set to NumberOfTriangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetNumberOfTrianglesMinValue">
            <summary>
                <para>Specify the number of triangles to produce on output. (It is a good idea to make sure this is less than a tessellated mesh at full resolution.) You need to set this value only when the error measure is set to NumberOfTriangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetNumberOfTriangles(System.Int32)">
            <summary>
                <para>Specify the number of triangles to produce on output. (It is a good idea to make sure this is less than a tessellated mesh at full resolution.) You need to set this value only when the error measure is set to NumberOfTriangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetErrorMeasureToRelativeError">
            <summary>
                <para>Specify the number of triangles to produce on output. (It is a good idea to make sure this is less than a tessellated mesh at full resolution.) You need to set this value only when the error measure is set to NumberOfTriangles.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetErrorMeasureToAbsoluteError">
            <summary>
                <para>Specify how to terminate the algorithm: either as an absolute number of triangles, a relative number of triangles (normalized by the full resolution mesh), an absolute error (in the height field), or relative error (normalized by the length of the diagonal of the image).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetErrorMeasureToSpecifiedReduction">
            <summary>
                <para>Specify how to terminate the algorithm: either as an absolute number of triangles, a relative number of triangles (normalized by the full resolution mesh), an absolute error (in the height field), or relative error (normalized by the length of the diagonal of the image).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetErrorMeasureToNumberOfTriangles">
            <summary>
                <para>Specify how to terminate the algorithm: either as an absolute number of triangles, a relative number of triangles (normalized by the full resolution mesh), an absolute error (in the height field), or relative error (normalized by the length of the diagonal of the image).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetErrorMeasure">
            <summary>
                <para>Specify how to terminate the algorithm: either as an absolute number of triangles, a relative number of triangles (normalized by the full resolution mesh), an absolute error (in the height field), or relative error (normalized by the length of the diagonal of the image).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetErrorMeasureMaxValue">
            <summary>
                <para>Specify how to terminate the algorithm: either as an absolute number of triangles, a relative number of triangles (normalized by the full resolution mesh), an absolute error (in the height field), or relative error (normalized by the length of the diagonal of the image).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.GetErrorMeasureMinValue">
            <summary>
                <para>Specify how to terminate the algorithm: either as an absolute number of triangles, a relative number of triangles (normalized by the full resolution mesh), an absolute error (in the height field), or relative error (normalized by the length of the diagonal of the image).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGreedyTerrainDecimation.SetErrorMeasure(System.Int32)">
            <summary>
                <para>Specify how to terminate the algorithm: either as an absolute number of triangles, a relative number of triangles (normalized by the full resolution mesh), an absolute error (in the height field), or relative error (normalized by the length of the diagonal of the image).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.MakeTransform">
            <summary>
                <para>Make another transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.Inverse">
            <summary>
                <para>Invert the transformation.  This is done by switching the source and target.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetLandmarkTransform">
            <summary>
                <para>Get the internal landmark transform. Use it to constrain the number of degrees of freedom of the solution (i.e. rigid body, similarity, etc.).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.StartByMatchingCentroidsOff">
            <summary>
                <para>Starts the process by translating source centroid to target centroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.StartByMatchingCentroidsOn">
            <summary>
                <para>Starts the process by translating source centroid to target centroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetStartByMatchingCentroids">
            <summary>
                <para>Starts the process by translating source centroid to target centroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetStartByMatchingCentroids(System.Int32)">
            <summary>
                <para>Starts the process by translating source centroid to target centroid.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetMaximumNumberOfLandmarks">
            <summary>
                <para>Set/Get the maximum number of landmarks sampled in your dataset. If your dataset is dense, then you will typically not need all the  points to compute the ICP transform. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetMaximumNumberOfLandmarks(System.Int32)">
            <summary>
                <para>Set/Get the maximum number of landmarks sampled in your dataset. If your dataset is dense, then you will typically not need all the  points to compute the ICP transform. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetMeanDistance">
            <summary>
                <para>Get the mean distance between the last two iterations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetMaximumMeanDistance">
            <summary>
                <para>Set/Get the maximum mean distance between two iteration. If the mean distance is lower than this, the convergence stops.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetMaximumMeanDistance(System.Double)">
            <summary>
                <para>Set/Get the maximum mean distance between two iteration. If the mean distance is lower than this, the convergence stops.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetMeanDistanceModeAsString">
            <summary>
                <para>Specify the mean distance mode. This mode expresses how the mean  distance is computed. The RMS mode is the square root of the average of the sum of squares of the closest point distances. The Absolute Value mode is the mean of the sum of absolute values of the closest point distances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetMeanDistanceModeToAbsoluteValue">
            <summary>
                <para>Specify the mean distance mode. This mode expresses how the mean  distance is computed. The RMS mode is the square root of the average of the sum of squares of the closest point distances. The Absolute Value mode is the mean of the sum of absolute values of the closest point distances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetMeanDistanceModeToRMS">
            <summary>
                <para>Specify the mean distance mode. This mode expresses how the mean  distance is computed. The RMS mode is the square root of the average of the sum of squares of the closest point distances. The Absolute Value mode is the mean of the sum of absolute values of the closest point distances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetMeanDistanceMode">
            <summary>
                <para>Specify the mean distance mode. This mode expresses how the mean  distance is computed. The RMS mode is the square root of the average of the sum of squares of the closest point distances. The Absolute Value mode is the mean of the sum of absolute values of the closest point distances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetMeanDistanceModeMaxValue">
            <summary>
                <para>Specify the mean distance mode. This mode expresses how the mean  distance is computed. The RMS mode is the square root of the average of the sum of squares of the closest point distances. The Absolute Value mode is the mean of the sum of absolute values of the closest point distances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetMeanDistanceModeMinValue">
            <summary>
                <para>Specify the mean distance mode. This mode expresses how the mean  distance is computed. The RMS mode is the square root of the average of the sum of squares of the closest point distances. The Absolute Value mode is the mean of the sum of absolute values of the closest point distances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetMeanDistanceMode(System.Int32)">
            <summary>
                <para>Specify the mean distance mode. This mode expresses how the mean  distance is computed. The RMS mode is the square root of the average of the sum of squares of the closest point distances. The Absolute Value mode is the mean of the sum of absolute values of the closest point distances.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.CheckMeanDistanceOff">
            <summary>
                <para>Force the algorithm to check the mean distance between two iteration.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.CheckMeanDistanceOn">
            <summary>
                <para>Force the algorithm to check the mean distance between two iteration.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetCheckMeanDistance">
            <summary>
                <para>Force the algorithm to check the mean distance between two iteration.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetCheckMeanDistance(System.Int32)">
            <summary>
                <para>Force the algorithm to check the mean distance between two iteration.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetNumberOfIterations">
            <summary>
                <para>Get the number of iterations since the last update</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetMaximumNumberOfIterations">
            <summary>
                <para>Set/Get the  maximum number of iterations</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetMaximumNumberOfIterations(System.Int32)">
            <summary>
                <para>Set/Get the  maximum number of iterations</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetLocator">
            <summary>
                <para>Set/Get a spatial locator for speeding up the search process.  An instance of vtkCellLocator is used by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetLocator(vtk.vtkCellLocator)">
            <summary>
                <para>Set/Get a spatial locator for speeding up the search process.  An instance of vtkCellLocator is used by default.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetTarget">
            <summary>
                <para>Specify the source and target data sets.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.GetSource">
            <summary>
                <para>Specify the source and target data sets.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetTarget(vtk.vtkDataSet)">
            <summary>
                <para>Specify the source and target data sets.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkIterativeClosestPointTransform.SetSource(vtk.vtkDataSet)">
            <summary>
                <para>Specify the source and target data sets.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkArcPlotter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetMTime">
            <summary>
                <para>New GetMTime because of camera dependency.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetFieldDataArray">
            <summary>
                <para>Set/Get the field data array to plot. This instance variable is only applicable if field data is plotted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetFieldDataArrayMaxValue">
            <summary>
                <para>Set/Get the field data array to plot. This instance variable is only applicable if field data is plotted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetFieldDataArrayMinValue">
            <summary>
                <para>Set/Get the field data array to plot. This instance variable is only applicable if field data is plotted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetFieldDataArray(System.Int32)">
            <summary>
                <para>Set/Get the field data array to plot. This instance variable is only applicable if field data is plotted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetDefaultNormal">
            <summary>
                <para>Set the default normal to use if you do not wish automatic normal calculation. The arc plot will be generated using this normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetDefaultNormal(System.Single[])">
            <summary>
                <para>Set the default normal to use if you do not wish automatic normal calculation. The arc plot will be generated using this normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetDefaultNormal(System.Single,System.Single,System.Single)">
            <summary>
                <para>Set the default normal to use if you do not wish automatic normal calculation. The arc plot will be generated using this normal.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.UseDefaultNormalOff">
            <summary>
                <para>Set a boolean to control whether to use default normals. By default, normals are automatically computed from the generating polyline and camera.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.UseDefaultNormalOn">
            <summary>
                <para>Set a boolean to control whether to use default normals. By default, normals are automatically computed from the generating polyline and camera.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetUseDefaultNormal">
            <summary>
                <para>Set a boolean to control whether to use default normals. By default, normals are automatically computed from the generating polyline and camera.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetUseDefaultNormal(System.Int32)">
            <summary>
                <para>Set a boolean to control whether to use default normals. By default, normals are automatically computed from the generating polyline and camera.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetOffset">
            <summary>
                <para>Specify an offset that translates each subsequent plot (if there is more than one component plotted) from the defining arc (i.e., polyline).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetOffsetMaxValue">
            <summary>
                <para>Specify an offset that translates each subsequent plot (if there is more than one component plotted) from the defining arc (i.e., polyline).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetOffsetMinValue">
            <summary>
                <para>Specify an offset that translates each subsequent plot (if there is more than one component plotted) from the defining arc (i.e., polyline).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetOffset(System.Double)">
            <summary>
                <para>Specify an offset that translates each subsequent plot (if there is more than one component plotted) from the defining arc (i.e., polyline).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetHeight">
            <summary>
                <para>Set the height of the plot. (The radius combined with the height define the location of the plot relative to the generating polyline.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetHeightMaxValue">
            <summary>
                <para>Set the height of the plot. (The radius combined with the height define the location of the plot relative to the generating polyline.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetHeightMinValue">
            <summary>
                <para>Set the height of the plot. (The radius combined with the height define the location of the plot relative to the generating polyline.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetHeight(System.Double)">
            <summary>
                <para>Set the height of the plot. (The radius combined with the height define the location of the plot relative to the generating polyline.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetRadius">
            <summary>
                <para>Set the radius of the "median" value of the first plotted component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetRadiusMaxValue">
            <summary>
                <para>Set the radius of the "median" value of the first plotted component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetRadiusMinValue">
            <summary>
                <para>Set the radius of the "median" value of the first plotted component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetRadius(System.Double)">
            <summary>
                <para>Set the radius of the "median" value of the first plotted component.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetPlotComponent">
            <summary>
                <para>Set/Get the component number to plot if the data has more than one  component. If the value of the plot component is == (-1), then all the components will be plotted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetPlotComponent(System.Int32)">
            <summary>
                <para>Set/Get the component number to plot if the data has more than one  component. If the value of the plot component is == (-1), then all the components will be plotted.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetPlotModeToPlotFieldData">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetPlotComponent to control which component to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetPlotModeToPlotTensors">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetPlotComponent to control which component to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetPlotModeToPlotTCoords">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetPlotComponent to control which component to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetPlotModeToPlotNormals">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetPlotComponent to control which component to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetPlotModeToPlotVectors">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetPlotComponent to control which component to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetPlotModeToPlotScalars">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetPlotComponent to control which component to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetPlotMode">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetPlotComponent to control which component to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetPlotMode(System.Int32)">
            <summary>
                <para>Specify which data to plot: scalars, vectors, normals, texture coords, tensors, or field data. If the data has more than one component, use the method SetPlotComponent to control which component to plot.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.GetCamera">
            <summary>
                <para>Specify a camera used to orient the plot along the arc. If no camera is specified, then the orientation of the plot is arbitrary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkArcPlotter.SetCamera(vtk.vtkCamera)">
            <summary>
                <para>Specify a camera used to orient the plot along the arc. If no camera is specified, then the orientation of the plot is arbitrary.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorText.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkVectorText.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkVectorText.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVectorText.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVectorText.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVectorText.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVectorText.GetText">
            <summary>
                <para>Set/Get the text to be drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVectorText.SetText(System.String)">
            <summary>
                <para>Set/Get the text to be drawn.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetZFaceTextRotation">
            <summary>
                <para>Augment individual face text orientations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetZFaceTextRotation(System.Double)">
            <summary>
                <para>Augment individual face text orientations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetYFaceTextRotation">
            <summary>
                <para>Augment individual face text orientations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetYFaceTextRotation(System.Double)">
            <summary>
                <para>Augment individual face text orientations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetXFaceTextRotation">
            <summary>
                <para>Augment individual face text orientations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetXFaceTextRotation(System.Double)">
            <summary>
                <para>Augment individual face text orientations.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.FaceTextOff">
            <summary>
                <para>Enable/disable drawing the vector text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.FaceTextOn">
            <summary>
                <para>Enable/disable drawing the vector text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetFaceText">
            <summary>
                <para>Enable/disable drawing the vector text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetFaceText(System.Int32)">
            <summary>
                <para>Enable/disable drawing the vector text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.CubeOff">
            <summary>
                <para>Enable/disable drawing the cube.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.CubeOn">
            <summary>
                <para>Enable/disable drawing the cube.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetCube">
            <summary>
                <para>Enable/disable drawing the cube.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetCube(System.Int32)">
            <summary>
                <para>Enable/disable drawing the cube.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.TextEdgesOff">
            <summary>
                <para>Enable/disable drawing the vector text edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.TextEdgesOn">
            <summary>
                <para>Enable/disable drawing the vector text edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetTextEdges">
            <summary>
                <para>Enable/disable drawing the vector text edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetTextEdges(System.Int32)">
            <summary>
                <para>Enable/disable drawing the vector text edges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetZMinusFaceText">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetZMinusFaceText(System.String)">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetZPlusFaceText">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetZPlusFaceText(System.String)">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetYMinusFaceText">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetYMinusFaceText(System.String)">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetYPlusFaceText">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetYPlusFaceText(System.String)">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetXMinusFaceText">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetXMinusFaceText(System.String)">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetXPlusFaceText">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetXPlusFaceText(System.String)">
            <summary>
                <para>Set/get the face text.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetTextEdgesProperty">
            <summary>
                <para>Get the text edges properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetCubeProperty">
            <summary>
                <para>Get the cube properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetZMinusFaceProperty">
            <summary>
                <para>Get the individual face text properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetZPlusFaceProperty">
            <summary>
                <para>Get the individual face text properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetYMinusFaceProperty">
            <summary>
                <para>Get the individual face text properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetYPlusFaceProperty">
            <summary>
                <para>Get the individual face text properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetXMinusFaceProperty">
            <summary>
                <para>Get the individual face text properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetXPlusFaceProperty">
            <summary>
                <para>Get the individual face text properties.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetFaceTextScale">
            <summary>
                <para>Set/Get the scale factor for the face text</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.SetFaceTextScale(System.Double)">
            <summary>
                <para>Set/Get the scale factor for the face text</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetRedrawMTime">
            <summary>
                <para>Return the mtime of anything that would cause the rendered image to appear differently. Usually this involves checking the mtime of the prop plus anything else it depends on such as properties, textures etc.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetMTime">
            <summary>
                <para>Get the actors mtime plus consider its properties and texture if set.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetBounds(System.Double[])">
            <summary>
                <para>Get the bounds for this Actor as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax). (The method GetBounds(double bounds[6]) is available from the superclass.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.ShallowCopy(vtk.vtkProp)">
            <summary>
                <para>Shallow copy of an axes actor. Overloads the virtual vtkProp method.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Support the standard render methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkAnnotatedCubeActor.GetActors(vtk.vtkPropCollection)">
            <summary>
                <para>For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetSubImageSize">
            <summary>
                <para>Specify the size (n by n pixels) of the largest region to  polygonalize. When the OutputStyle is set to VTK_STYLE_POLYGONALIZE, large amounts of memory are used. In order to process large images, the image is broken into pieces that are at most Size pixels in width and height.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetSubImageSizeMaxValue">
            <summary>
                <para>Specify the size (n by n pixels) of the largest region to  polygonalize. When the OutputStyle is set to VTK_STYLE_POLYGONALIZE, large amounts of memory are used. In order to process large images, the image is broken into pieces that are at most Size pixels in width and height.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetSubImageSizeMinValue">
            <summary>
                <para>Specify the size (n by n pixels) of the largest region to  polygonalize. When the OutputStyle is set to VTK_STYLE_POLYGONALIZE, large amounts of memory are used. In order to process large images, the image is broken into pieces that are at most Size pixels in width and height.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetSubImageSize(System.Int32)">
            <summary>
                <para>Specify the size (n by n pixels) of the largest region to  polygonalize. When the OutputStyle is set to VTK_STYLE_POLYGONALIZE, large amounts of memory are used. In order to process large images, the image is broken into pieces that are at most Size pixels in width and height.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetError">
            <summary>
                <para>Specify the error value between two colors where the colors are  considered the same. Only use this if the color mode uses the default 256 table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetErrorMaxValue">
            <summary>
                <para>Specify the error value between two colors where the colors are  considered the same. Only use this if the color mode uses the default 256 table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetErrorMinValue">
            <summary>
                <para>Specify the error value between two colors where the colors are  considered the same. Only use this if the color mode uses the default 256 table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetError(System.Int32)">
            <summary>
                <para>Specify the error value between two colors where the colors are  considered the same. Only use this if the color mode uses the default 256 table.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetDecimationError">
            <summary>
                <para>Specify the error to use for decimation (if decimation is on). The error is an absolute number--the image spacing and dimensions are used to create points so the error should be consistent with the image size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetDecimationErrorMaxValue">
            <summary>
                <para>Specify the error to use for decimation (if decimation is on). The error is an absolute number--the image spacing and dimensions are used to create points so the error should be consistent with the image size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetDecimationErrorMinValue">
            <summary>
                <para>Specify the error to use for decimation (if decimation is on). The error is an absolute number--the image spacing and dimensions are used to create points so the error should be consistent with the image size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetDecimationError(System.Double)">
            <summary>
                <para>Specify the error to use for decimation (if decimation is on). The error is an absolute number--the image spacing and dimensions are used to create points so the error should be consistent with the image size.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.DecimationOff">
            <summary>
                <para>Turn on/off whether the final polygons should be decimated. whether to smooth boundaries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.DecimationOn">
            <summary>
                <para>Turn on/off whether the final polygons should be decimated. whether to smooth boundaries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetDecimation">
            <summary>
                <para>Turn on/off whether the final polygons should be decimated. whether to smooth boundaries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetDecimation(System.Int32)">
            <summary>
                <para>Turn on/off whether the final polygons should be decimated. whether to smooth boundaries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetNumberOfSmoothingIterations">
            <summary>
                <para>Specify the number of smoothing iterations to smooth polygons. (Only in effect if output style is Polygonalize and smoothing is on.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetNumberOfSmoothingIterationsMaxValue">
            <summary>
                <para>Specify the number of smoothing iterations to smooth polygons. (Only in effect if output style is Polygonalize and smoothing is on.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetNumberOfSmoothingIterationsMinValue">
            <summary>
                <para>Specify the number of smoothing iterations to smooth polygons. (Only in effect if output style is Polygonalize and smoothing is on.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetNumberOfSmoothingIterations(System.Int32)">
            <summary>
                <para>Specify the number of smoothing iterations to smooth polygons. (Only in effect if output style is Polygonalize and smoothing is on.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SmoothingOff">
            <summary>
                <para>If the output style is set to polygonalize, then you can control whether to smooth boundaries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SmoothingOn">
            <summary>
                <para>If the output style is set to polygonalize, then you can control whether to smooth boundaries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetSmoothing">
            <summary>
                <para>If the output style is set to polygonalize, then you can control whether to smooth boundaries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetSmoothing(System.Int32)">
            <summary>
                <para>If the output style is set to polygonalize, then you can control whether to smooth boundaries.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetLookupTable">
            <summary>
                <para>Set/Get the vtkLookupTable to use. The lookup table is used when the color mode is set to LUT and a single component scalar is input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetLookupTable(vtk.vtkScalarsToColors)">
            <summary>
                <para>Set/Get the vtkLookupTable to use. The lookup table is used when the color mode is set to LUT and a single component scalar is input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetColorModeToLinear256">
            <summary>
                <para>Specify how to quantize color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetColorModeToLUT">
            <summary>
                <para>Specify how to quantize color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetColorMode">
            <summary>
                <para>Specify how to quantize color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetColorModeMaxValue">
            <summary>
                <para>Specify how to quantize color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetColorModeMinValue">
            <summary>
                <para>Specify how to quantize color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetColorMode(System.Int32)">
            <summary>
                <para>Specify how to quantize color.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetOutputStyleToRunLength">
            <summary>
                <para>Specify how to create the output. Pixelize means converting the image to quad polygons with a constant color per quad. Polygonalize means merging colors together into polygonal regions, and then smoothing the regions (if smoothing is turned on). RunLength means creating quad polygons that may encompass several pixels on a scan line. The default behavior is Polygonalize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetOutputStyleToPolygonalize">
            <summary>
                <para>Specify how to create the output. Pixelize means converting the image to quad polygons with a constant color per quad. Polygonalize means merging colors together into polygonal regions, and then smoothing the regions (if smoothing is turned on). RunLength means creating quad polygons that may encompass several pixels on a scan line. The default behavior is Polygonalize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetOutputStyleToPixelize">
            <summary>
                <para>Specify how to create the output. Pixelize means converting the image to quad polygons with a constant color per quad. Polygonalize means merging colors together into polygonal regions, and then smoothing the regions (if smoothing is turned on). RunLength means creating quad polygons that may encompass several pixels on a scan line. The default behavior is Polygonalize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetOutputStyle">
            <summary>
                <para>Specify how to create the output. Pixelize means converting the image to quad polygons with a constant color per quad. Polygonalize means merging colors together into polygonal regions, and then smoothing the regions (if smoothing is turned on). RunLength means creating quad polygons that may encompass several pixels on a scan line. The default behavior is Polygonalize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetOutputStyleMaxValue">
            <summary>
                <para>Specify how to create the output. Pixelize means converting the image to quad polygons with a constant color per quad. Polygonalize means merging colors together into polygonal regions, and then smoothing the regions (if smoothing is turned on). RunLength means creating quad polygons that may encompass several pixels on a scan line. The default behavior is Polygonalize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.GetOutputStyleMinValue">
            <summary>
                <para>Specify how to create the output. Pixelize means converting the image to quad polygons with a constant color per quad. Polygonalize means merging colors together into polygonal regions, and then smoothing the regions (if smoothing is turned on). RunLength means creating quad polygons that may encompass several pixels on a scan line. The default behavior is Polygonalize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkImageToPolyDataFilter.SetOutputStyle(System.Int32)">
            <summary>
                <para>Specify how to create the output. Pixelize means converting the image to quad polygons with a constant color per quad. Polygonalize means merging colors together into polygonal regions, and then smoothing the regions (if smoothing is turned on). RunLength means creating quad polygons that may encompass several pixels on a scan line. The default behavior is Polygonalize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusModel.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExodusModel.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkEarthSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkEarthSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkEarthSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkEarthSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkEarthSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkEarthSource.OutlineOff">
            <summary>
                <para>Turn on/off drawing continents as filled polygons or as wireframe outlines. Warning: some graphics systems will have trouble with the very large, concave  filled polygons. Recommend you use OutlienOn (i.e., disable filled polygons)  for now.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.OutlineOn">
            <summary>
                <para>Turn on/off drawing continents as filled polygons or as wireframe outlines. Warning: some graphics systems will have trouble with the very large, concave  filled polygons. Recommend you use OutlienOn (i.e., disable filled polygons)  for now.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.GetOutline">
            <summary>
                <para>Turn on/off drawing continents as filled polygons or as wireframe outlines. Warning: some graphics systems will have trouble with the very large, concave  filled polygons. Recommend you use OutlienOn (i.e., disable filled polygons)  for now.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.SetOutline(System.Int32)">
            <summary>
                <para>Turn on/off drawing continents as filled polygons or as wireframe outlines. Warning: some graphics systems will have trouble with the very large, concave  filled polygons. Recommend you use OutlienOn (i.e., disable filled polygons)  for now.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.GetOnRatio">
            <summary>
                <para>Turn on every nth entity. This controls how much detail the model will have. The maximum ratio is sixteen. (The smaller OnRatio, the more detail there is.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.GetOnRatioMaxValue">
            <summary>
                <para>Turn on every nth entity. This controls how much detail the model will have. The maximum ratio is sixteen. (The smaller OnRatio, the more detail there is.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.GetOnRatioMinValue">
            <summary>
                <para>Turn on every nth entity. This controls how much detail the model will have. The maximum ratio is sixteen. (The smaller OnRatio, the more detail there is.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.SetOnRatio(System.Int32)">
            <summary>
                <para>Turn on every nth entity. This controls how much detail the model will have. The maximum ratio is sixteen. (The smaller OnRatio, the more detail there is.)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.GetRadius">
            <summary>
                <para>Set radius of earth.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.GetRadiusMaxValue">
            <summary>
                <para>Set radius of earth.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.GetRadiusMinValue">
            <summary>
                <para>Set radius of earth.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkEarthSource.SetRadius(System.Double)">
            <summary>
                <para>Set radius of earth.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.MakeTransform">
            <summary>
                <para>Make another transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.GetMTime">
            <summary>
                <para>Get the MTime.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.Inverse">
            <summary>
                <para>Invert the transformation.  This is done by switching the source and target landmarks.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.GetModeAsString">
            <summary>
                <para>Set the number of degrees of freedom to constrain the solution to. Rigidbody: rotation and translation only.   Similarity: rotation, translation and isotropic scaling. The default is similarity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.GetMode">
            <summary>
                <para>Set the number of degrees of freedom to constrain the solution to. Rigidbody: rotation and translation only.   Similarity: rotation, translation and isotropic scaling. The default is similarity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.SetModeToAffine">
            <summary>
                <para>Set the number of degrees of freedom to constrain the solution to. Rigidbody: rotation and translation only.   Similarity: rotation, translation and isotropic scaling. The default is similarity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.SetModeToSimilarity">
            <summary>
                <para>Set the number of degrees of freedom to constrain the solution to. Rigidbody: rotation and translation only.   Similarity: rotation, translation and isotropic scaling. The default is similarity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.SetModeToRigidBody">
            <summary>
                <para>Set the number of degrees of freedom to constrain the solution to. Rigidbody: rotation and translation only.   Similarity: rotation, translation and isotropic scaling. The default is similarity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.SetMode(System.Int32)">
            <summary>
                <para>Set the number of degrees of freedom to constrain the solution to. Rigidbody: rotation and translation only.   Similarity: rotation, translation and isotropic scaling. The default is similarity.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.GetTargetLandmarks">
            <summary>
                <para>Specify the source and target landmark sets. The two sets must have  the same number of points.  If you add or change points in these objects, you must call Modified() on them or the transformation might not update.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.GetSourceLandmarks">
            <summary>
                <para>Specify the source and target landmark sets. The two sets must have  the same number of points.  If you add or change points in these objects, you must call Modified() on them or the transformation might not update.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.SetTargetLandmarks(vtk.vtkPoints)">
            <summary>
                <para>Specify the source and target landmark sets. The two sets must have  the same number of points.  If you add or change points in these objects, you must call Modified() on them or the transformation might not update.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkLandmarkTransform.SetSourceLandmarks(vtk.vtkPoints)">
            <summary>
                <para>Specify the source and target landmark sets. The two sets must have  the same number of points.  If you add or change points in these objects, you must call Modified() on them or the transformation might not update.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.GetInput(System.Int32)">
            <summary>
                <para>Retrieve the input point set with index idx (usually only for pipeline tracing).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.SetInput(System.Int32,vtk.vtkPointSet)">
            <summary>
                <para>Specify the input pointset with index idx. Call SetNumberOfInputs before calling this function.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.SetNumberOfInputs(System.Int32)">
            <summary>
                <para>Specify how many pointsets are going to be given as input.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.GetMeanPoints">
            <summary>
                <para>Get the estimated mean point cloud</para>
            </summary>
        </member>
        <member name="M:vtk.vtkProcrustesAlignmentFilter.GetLandmarkTransform">
            <summary>
                <para>Get the internal landmark transform. Use it to constrain the number of degrees of freedom of the alignment (i.e. rigid body, similarity, etc.). The default is a similarity alignment.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.OnParentWndDestroy">
            <summary>
                <para>For internal use only</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.LocalInternalGrab(System.IntPtr)">
            <summary>
                <para>For internal use only</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.ReleaseSystemResources">
            <summary>
                <para>Free the driver (this is called automatically inside the destructor).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.Initialize">
            <summary>
                <para>Initialize the driver (this is called automatically when the first grab is done).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.VideoSourceDialog">
            <summary>
                <para>Bring up a modal dialog box for video input selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.VideoFormatDialog">
            <summary>
                <para>Bring up a modal dialog box for video format selection.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.GetPreview">
            <summary>
                <para>Turn on/off the preview (overlay) window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.PreviewOff">
            <summary>
                <para>Turn on/off the preview (overlay) window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.PreviewOn">
            <summary>
                <para>Turn on/off the preview (overlay) window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.SetPreview(System.Int32)">
            <summary>
                <para>Turn on/off the preview (overlay) window.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.SetOutputFormat(System.Int32)">
            <summary>
                <para>Request a particular output format (default: VTK_RGB).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.SetFrameRate(System.Single)">
            <summary>
                <para>Request a particular frame rate (default 30 frames per second).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.SetFrameSize(System.Int32[])">
            <summary>
                <para>Request a particular frame size (set the third value to 1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.SetFrameSize(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Request a particular frame size (set the third value to 1).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.Grab">
            <summary>
                <para>Grab a single video frame.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.Stop">
            <summary>
                <para>Standard VCR functionality: Stop recording or playing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.Play">
            <summary>
                <para>Standard VCR functionality: Play recorded video.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkWin32VideoSource.Record">
            <summary>
                <para>Standard VCR functionality: Record incoming video.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkVideoSource.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkVideoSource.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetStartTimeStamp">
            <summary>
                <para>And internal variable which marks the beginning of a Record session. These methods are for internal use only.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetStartTimeStamp(System.Double)">
            <summary>
                <para>And internal variable which marks the beginning of a Record session. These methods are for internal use only.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.InternalGrab">
            <summary>
                <para>The internal function which actually does the grab.  You will definitely want to override this if you develop a vtkVideoSource subclass. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.ReleaseSystemResources">
            <summary>
                <para>Release the video driver.  This method must be called before application exit, or else the application might hang during exit.  </para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetInitialized">
            <summary>
                <para>Initialize the hardware.  This is called automatically on the first Update or Grab.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.Initialize">
            <summary>
                <para>Initialize the hardware.  This is called automatically on the first Update or Grab.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetFrameTimeStamp">
            <summary>
                <para>Get a time stamp in seconds (resolution of milliseconds) for the Output.  Time began on Jan 1, 1970.  This timestamp is only valid after the Output has been Updated.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetFrameTimeStamp(System.Int32)">
            <summary>
                <para>Get a time stamp in seconds (resolution of milliseconds) for a video frame.   Time began on Jan 1, 1970.  You can specify a number (negative or positive) to specify the position of the video frame relative to the current frame.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetFrameIndex">
            <summary>
                <para>Get the frame index relative to the 'beginning of the tape'.  This value wraps back to zero if it increases past the FrameBufferSize.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetFrameCount(System.Int32)">
            <summary>
                <para>This value is incremented each time a frame is grabbed. reset it to zero (or any other value) at any time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetFrameCount">
            <summary>
                <para>This value is incremented each time a frame is grabbed. reset it to zero (or any other value) at any time.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetOpacity">
            <summary>
                <para>For RGBA output only (4 scalar components), set the opacity.  This will not modify the existing contents of the framebuffer, only subsequently grabbed frames.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetOpacity(System.Single)">
            <summary>
                <para>For RGBA output only (4 scalar components), set the opacity.  This will not modify the existing contents of the framebuffer, only subsequently grabbed frames.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetDataOrigin">
            <summary>
                <para>Set/Get the coordinates of the lower, left corner of the frame.  Default: (0.0,0.0,0.0)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetDataOrigin(System.Double[])">
            <summary>
                <para>Set/Get the coordinates of the lower, left corner of the frame.  Default: (0.0,0.0,0.0)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetDataOrigin(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the coordinates of the lower, left corner of the frame.  Default: (0.0,0.0,0.0)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetDataSpacing">
            <summary>
                <para>Set/Get the pixel spacing.  Default: (1.0,1.0,1.0)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetDataSpacing(System.Double[])">
            <summary>
                <para>Set/Get the pixel spacing.  Default: (1.0,1.0,1.0)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetDataSpacing(System.Double,System.Double,System.Double)">
            <summary>
                <para>Set/Get the pixel spacing.  Default: (1.0,1.0,1.0)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetOutputWholeExtent">
            <summary>
                <para>Get/Set the WholeExtent of the output.  This can be used to either clip or pad the video frame.  This clipping/padding is done when the frame is copied to the output, and does not change the contents of the framebuffer.  This is useful e.g. for expanding  the output size to a power of two for texture mapping.  The default is (0,-1,0,-1,0,-1) which causes the entire frame to be copied to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetOutputWholeExtent(System.Int32[])">
            <summary>
                <para>Get/Set the WholeExtent of the output.  This can be used to either clip or pad the video frame.  This clipping/padding is done when the frame is copied to the output, and does not change the contents of the framebuffer.  This is useful e.g. for expanding  the output size to a power of two for texture mapping.  The default is (0,-1,0,-1,0,-1) which causes the entire frame to be copied to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetOutputWholeExtent(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Get/Set the WholeExtent of the output.  This can be used to either clip or pad the video frame.  This clipping/padding is done when the frame is copied to the output, and does not change the contents of the framebuffer.  This is useful e.g. for expanding  the output size to a power of two for texture mapping.  The default is (0,-1,0,-1,0,-1) which causes the entire frame to be copied to the output.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetClipRegion">
            <summary>
                <para>Set the clip rectangle for the frames.  The video will be clipped  before it is copied into the framebuffer.  Changing the ClipRegion will destroy the current contents of the framebuffer. The default ClipRegion is (0,VTK_INT_MAX,0,VTK_INT_MAX,0,VTK_INT_MAX).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetClipRegion(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the clip rectangle for the frames.  The video will be clipped  before it is copied into the framebuffer.  Changing the ClipRegion will destroy the current contents of the framebuffer. The default ClipRegion is (0,VTK_INT_MAX,0,VTK_INT_MAX,0,VTK_INT_MAX).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetClipRegion(System.Int32[])">
            <summary>
                <para>Set the clip rectangle for the frames.  The video will be clipped  before it is copied into the framebuffer.  Changing the ClipRegion will destroy the current contents of the framebuffer. The default ClipRegion is (0,VTK_INT_MAX,0,VTK_INT_MAX,0,VTK_INT_MAX).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetAutoAdvance">
            <summary>
                <para>Set whether to automatically advance the buffer before each grab.  Default: on</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetAutoAdvance(System.Int32)">
            <summary>
                <para>Set whether to automatically advance the buffer before each grab.  Default: on</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.AutoAdvanceOff">
            <summary>
                <para>Set whether to automatically advance the buffer before each grab.  Default: on</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.AutoAdvanceOn">
            <summary>
                <para>Set whether to automatically advance the buffer before each grab.  Default: on</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetNumberOfOutputFrames">
            <summary>
                <para>Set the number of frames to copy to the output on each execute. The frames will be concatenated along the Z dimension, with the  most recent frame first. Default: 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetNumberOfOutputFrames(System.Int32)">
            <summary>
                <para>Set the number of frames to copy to the output on each execute. The frames will be concatenated along the Z dimension, with the  most recent frame first. Default: 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetFrameBufferSize">
            <summary>
                <para>Set size of the frame buffer, i.e. the number of frames that the 'tape' can store.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetFrameBufferSize(System.Int32)">
            <summary>
                <para>Set size of the frame buffer, i.e. the number of frames that the 'tape' can store.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetOutputFormat">
            <summary>
                <para>Set the output format.  This must be appropriate for device, usually only VTK_LUMINANCE, VTK_RGB, and VTK_RGBA are supported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetOutputFormatToRGBA">
            <summary>
                <para>Set the output format.  This must be appropriate for device, usually only VTK_LUMINANCE, VTK_RGB, and VTK_RGBA are supported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetOutputFormatToRGB">
            <summary>
                <para>Set the output format.  This must be appropriate for device, usually only VTK_LUMINANCE, VTK_RGB, and VTK_RGBA are supported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetOutputFormatToLuminance">
            <summary>
                <para>Set the output format.  This must be appropriate for device, usually only VTK_LUMINANCE, VTK_RGB, and VTK_RGBA are supported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetOutputFormat(System.Int32)">
            <summary>
                <para>Set the output format.  This must be appropriate for device, usually only VTK_LUMINANCE, VTK_RGB, and VTK_RGBA are supported.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetFrameRate">
            <summary>
                <para>Request a particular frame rate (default 30 frames per second).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetFrameRate(System.Single)">
            <summary>
                <para>Request a particular frame rate (default 30 frames per second).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetFrameSize">
            <summary>
                <para>Set the full-frame size.  This must be an allowed size for the device, the device may either refuse a request for an illegal frame size or automatically choose a new frame size. The default is usually 320x240x1, but can be device specific.   The 'depth' should always be 1 (unless you have a device that can handle 3D acquisition).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetFrameSize(System.Int32[])">
            <summary>
                <para>Set the full-frame size.  This must be an allowed size for the device, the device may either refuse a request for an illegal frame size or automatically choose a new frame size. The default is usually 320x240x1, but can be device specific.   The 'depth' should always be 1 (unless you have a device that can handle 3D acquisition).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.SetFrameSize(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Set the full-frame size.  This must be an allowed size for the device, the device may either refuse a request for an illegal frame size or automatically choose a new frame size. The default is usually 320x240x1, but can be device specific.   The 'depth' should always be 1 (unless you have a device that can handle 3D acquisition).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetPlaying">
            <summary>
                <para>Are we in play mode? (record mode and play mode are mutually exclusive).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.GetRecording">
            <summary>
                <para>Are we in record mode? (record mode and play mode are mutually exclusive).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.Grab">
            <summary>
                <para>Grab a single video frame.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.Seek(System.Int32)">
            <summary>
                <para>Seek forwards or backwards by the specified number of frames (positive is forward, negative is backward).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.FastForward">
            <summary>
                <para>FastForward to the last frame that was recorded (i.e. to the frame that has the most recent timestamp).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.Rewind">
            <summary>
                <para>Rewind to the frame with the earliest timestamp.  Record operations will start on the following frame, therefore if you want to re-record over this frame you must call Seek(-1) before calling Grab() or Record().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.Stop">
            <summary>
                <para>Stop recording or playing.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.Play">
            <summary>
                <para>Play through the 'tape' sequentially at the specified frame rate. If you have just finished Recoding, you should call Rewind() first.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkVideoSource.Record">
            <summary>
                <para>Record incoming video at the specified FrameRate.  The recording continues indefinitely until Stop() is called. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetProp">
            <summary>
                <para>@deprecated Replaced by vtkCubeAxesActor2D::GetViewProp() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetProp(vtk.vtkProp)">
            <summary>
                <para>@deprecated Replaced by vtkCubeAxesActor2D::SetViewProp() as of VTK 5.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.ShallowCopy(vtk.vtkCubeAxesActor2D)">
            <summary>
                <para>Shallow copy of a CubeAxesActor2D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.ZAxisVisibilityOff">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.ZAxisVisibilityOn">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetZAxisVisibility">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetZAxisVisibility(System.Int32)">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.YAxisVisibilityOff">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.YAxisVisibilityOn">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetYAxisVisibility">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetYAxisVisibility(System.Int32)">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.XAxisVisibilityOff">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.XAxisVisibilityOn">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetXAxisVisibility">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetXAxisVisibility(System.Int32)">
            <summary>
                <para>Turn on and off the visibility of each axis.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.ReleaseGraphicsResources(vtk.vtkWindow)">
            <summary>
                <para>Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetCornerOffset">
            <summary>
                <para>Specify an offset value to "pull back" the axes from the corner at which they are joined to avoid overlap of axes labels. The  "CornerOffset" is the fraction of the axis length to pull back.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetCornerOffset(System.Double)">
            <summary>
                <para>Specify an offset value to "pull back" the axes from the corner at which they are joined to avoid overlap of axes labels. The  "CornerOffset" is the fraction of the axis length to pull back.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetShowActualBounds">
            <summary>
                <para>Set/Get the variable that controls whether the actual bounds of the dataset are always shown. Setting this variable to 1 means that clipping is disabled and that the actual value of the bounds is displayed even with corner offsets Setting this variable to 0 means these axis will clip themselves and show variable bounds (legacy mode)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetShowActualBoundsMaxValue">
            <summary>
                <para>Set/Get the variable that controls whether the actual bounds of the dataset are always shown. Setting this variable to 1 means that clipping is disabled and that the actual value of the bounds is displayed even with corner offsets Setting this variable to 0 means these axis will clip themselves and show variable bounds (legacy mode)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetShowActualBoundsMinValue">
            <summary>
                <para>Set/Get the variable that controls whether the actual bounds of the dataset are always shown. Setting this variable to 1 means that clipping is disabled and that the actual value of the bounds is displayed even with corner offsets Setting this variable to 0 means these axis will clip themselves and show variable bounds (legacy mode)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetShowActualBounds(System.Int32)">
            <summary>
                <para>Set/Get the variable that controls whether the actual bounds of the dataset are always shown. Setting this variable to 1 means that clipping is disabled and that the actual value of the bounds is displayed even with corner offsets Setting this variable to 0 means these axis will clip themselves and show variable bounds (legacy mode)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetInertia">
            <summary>
                <para>Set/Get the inertial factor that controls how often (i.e, how many renders) the axes can switch position (jump from one axes  to another).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetInertiaMaxValue">
            <summary>
                <para>Set/Get the inertial factor that controls how often (i.e, how many renders) the axes can switch position (jump from one axes  to another).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetInertiaMinValue">
            <summary>
                <para>Set/Get the inertial factor that controls how often (i.e, how many renders) the axes can switch position (jump from one axes  to another).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetInertia(System.Int32)">
            <summary>
                <para>Set/Get the inertial factor that controls how often (i.e, how many renders) the axes can switch position (jump from one axes  to another).</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetFontFactor">
            <summary>
                <para>Set/Get the factor that controls the overall size of the fonts used to label and title the axes. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetFontFactorMaxValue">
            <summary>
                <para>Set/Get the factor that controls the overall size of the fonts used to label and title the axes. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetFontFactorMinValue">
            <summary>
                <para>Set/Get the factor that controls the overall size of the fonts used to label and title the axes. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetFontFactor(System.Double)">
            <summary>
                <para>Set/Get the factor that controls the overall size of the fonts used to label and title the axes. </para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetLabelFormat">
            <summary>
                <para>Set/Get the format with which to print the labels on each of the x-y-z axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetLabelFormat(System.String)">
            <summary>
                <para>Set/Get the format with which to print the labels on each of the x-y-z axes.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetAxisLabelTextProperty">
            <summary>
                <para>Set/Get the labels text property of all axes. Note that each axis can be controlled individually through the GetX/Y/ZAxisActor2D() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetAxisLabelTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the labels text property of all axes. Note that each axis can be controlled individually through the GetX/Y/ZAxisActor2D() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetAxisTitleTextProperty">
            <summary>
                <para>Set/Get the title text property of all axes. Note that each axis can be controlled individually through the GetX/Y/ZAxisActor2D() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetAxisTitleTextProperty(vtk.vtkTextProperty)">
            <summary>
                <para>Set/Get the title text property of all axes. Note that each axis can be controlled individually through the GetX/Y/ZAxisActor2D() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetZAxisActor2D">
            <summary>
                <para>Set/Get the title text property of all axes. Note that each axis can be controlled individually through the GetX/Y/ZAxisActor2D() methods.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetYAxisActor2D">
            <summary>
                <para>Retrieve handles to the X, Y and Z axis (so that you can set their text properties for example)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetXAxisActor2D">
            <summary>
                <para>Retrieve handles to the X, Y and Z axis (so that you can set their text properties for example)</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetZLabel">
            <summary>
                <para>Set/Get the labels for the x, y, and z axes. By default,  use "X", "Y" and "Z".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetZLabel(System.String)">
            <summary>
                <para>Set/Get the labels for the x, y, and z axes. By default,  use "X", "Y" and "Z".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetYLabel">
            <summary>
                <para>Set/Get the labels for the x, y, and z axes. By default,  use "X", "Y" and "Z".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetYLabel(System.String)">
            <summary>
                <para>Set/Get the labels for the x, y, and z axes. By default,  use "X", "Y" and "Z".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetXLabel">
            <summary>
                <para>Set/Get the labels for the x, y, and z axes. By default,  use "X", "Y" and "Z".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetXLabel(System.String)">
            <summary>
                <para>Set/Get the labels for the x, y, and z axes. By default,  use "X", "Y" and "Z".</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetNumberOfLabels">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x, y, and  z axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetNumberOfLabelsMaxValue">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x, y, and  z axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetNumberOfLabelsMinValue">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x, y, and  z axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetNumberOfLabels(System.Int32)">
            <summary>
                <para>Set/Get the number of annotation labels to show along the x, y, and  z axes. This values is a suggestion: the number of labels may vary depending on the particulars of the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.ScalingOff">
            <summary>
                <para>Set/Get a flag that controls whether the axes are scaled to fit in the viewport. If off, the axes size remains constant (i.e., stay the size of the bounding box). By default scaling is on so the axes are scaled to fit inside the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.ScalingOn">
            <summary>
                <para>Set/Get a flag that controls whether the axes are scaled to fit in the viewport. If off, the axes size remains constant (i.e., stay the size of the bounding box). By default scaling is on so the axes are scaled to fit inside the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetScaling">
            <summary>
                <para>Set/Get a flag that controls whether the axes are scaled to fit in the viewport. If off, the axes size remains constant (i.e., stay the size of the bounding box). By default scaling is on so the axes are scaled to fit inside the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetScaling(System.Int32)">
            <summary>
                <para>Set/Get a flag that controls whether the axes are scaled to fit in the viewport. If off, the axes size remains constant (i.e., stay the size of the bounding box). By default scaling is on so the axes are scaled to fit inside the viewport.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetFlyModeToClosestTriad">
            <summary>
                <para>Specify a mode to control how the axes are drawn: either outer edges or closest triad to the camera position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetFlyModeToOuterEdges">
            <summary>
                <para>Specify a mode to control how the axes are drawn: either outer edges or closest triad to the camera position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetFlyMode">
            <summary>
                <para>Specify a mode to control how the axes are drawn: either outer edges or closest triad to the camera position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetFlyModeMaxValue">
            <summary>
                <para>Specify a mode to control how the axes are drawn: either outer edges or closest triad to the camera position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetFlyModeMinValue">
            <summary>
                <para>Specify a mode to control how the axes are drawn: either outer edges or closest triad to the camera position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetFlyMode(System.Int32)">
            <summary>
                <para>Specify a mode to control how the axes are drawn: either outer edges or closest triad to the camera position.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetCamera">
            <summary>
                <para>Set/Get the camera to perform scaling and translation of the  vtkCubeAxesActor2D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetCamera(vtk.vtkCamera)">
            <summary>
                <para>Set/Get the camera to perform scaling and translation of the  vtkCubeAxesActor2D.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.UseRangesOff">
            <summary>
                <para>Set/Get a flag that controls whether the axes use the data ranges or the ranges set by SetRanges. By default the axes use the data ranges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.UseRangesOn">
            <summary>
                <para>Set/Get a flag that controls whether the axes use the data ranges or the ranges set by SetRanges. By default the axes use the data ranges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetUseRanges">
            <summary>
                <para>Set/Get a flag that controls whether the axes use the data ranges or the ranges set by SetRanges. By default the axes use the data ranges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetUseRanges(System.Int32)">
            <summary>
                <para>Set/Get a flag that controls whether the axes use the data ranges or the ranges set by SetRanges. By default the axes use the data ranges.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetRanges(System.Double[])">
            <summary>
                <para>Explicitly specify the range of values used on the bounds. The ranges are specified according to (xmin,xmax, ymin,ymax, zmin,zmax),  making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetRanges(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>Explicitly specify the range of values used on the bounds. The ranges are specified according to (xmin,xmax, ymin,ymax, zmin,zmax),  making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetRanges">
            <summary>
                <para>Explicitly specify the range of values used on the bounds. The ranges are specified according to (xmin,xmax, ymin,ymax, zmin,zmax),  making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetRanges(System.Double[])">
            <summary>
                <para>Explicitly specify the range of values used on the bounds. The ranges are specified according to (xmin,xmax, ymin,ymax, zmin,zmax),  making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetRanges(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Explicitly specify the range of values used on the bounds. The ranges are specified according to (xmin,xmax, ymin,ymax, zmin,zmax),  making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetBounds(System.Double[])">
            <summary>
                <para>Explicitly specify the region in space around which to draw the bounds. The bounds is used only when no Input or Prop is specified. The bounds are specified according to (xmin,xmax, ymin,ymax, zmin,zmax), making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetBounds(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
                <para>Explicitly specify the region in space around which to draw the bounds. The bounds is used only when no Input or Prop is specified. The bounds are specified according to (xmin,xmax, ymin,ymax, zmin,zmax), making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetBounds">
            <summary>
                <para>Explicitly specify the region in space around which to draw the bounds. The bounds is used only when no Input or Prop is specified. The bounds are specified according to (xmin,xmax, ymin,ymax, zmin,zmax), making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetBounds(System.Double[])">
            <summary>
                <para>Explicitly specify the region in space around which to draw the bounds. The bounds is used only when no Input or Prop is specified. The bounds are specified according to (xmin,xmax, ymin,ymax, zmin,zmax), making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetBounds(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
                <para>Explicitly specify the region in space around which to draw the bounds. The bounds is used only when no Input or Prop is specified. The bounds are specified according to (xmin,xmax, ymin,ymax, zmin,zmax), making sure that the min's are less than the max's.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetViewProp">
            <summary>
                <para>Use the bounding box of this prop to draw the cube axes. The ViewProp is used to determine the bounds only if the Input is not defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetViewProp(vtk.vtkProp)">
            <summary>
                <para>Use the bounding box of this prop to draw the cube axes. The ViewProp is used to determine the bounds only if the Input is not defined.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.GetInput">
            <summary>
                <para>Use the bounding box of this input dataset to draw the cube axes. If this is not specified, then the class will attempt to determine the bounds from the defined Prop or Bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.SetInput(vtk.vtkDataSet)">
            <summary>
                <para>Use the bounding box of this input dataset to draw the cube axes. If this is not specified, then the class will attempt to determine the bounds from the defined Prop or Bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.RenderTranslucentGeometry(vtk.vtkViewport)">
            <summary>
                <para>Use the bounding box of this input dataset to draw the cube axes. If this is not specified, then the class will attempt to determine the bounds from the defined Prop or Bounds.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.RenderOpaqueGeometry(vtk.vtkViewport)">
            <summary>
                <para>Draw the axes as per the vtkProp superclass' API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkCubeAxesActor2D.RenderOverlay(vtk.vtkViewport)">
            <summary>
                <para>Draw the axes as per the vtkProp superclass' API.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkGridTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkGridTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkGridTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkGridTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkGridTransform.GetMTime">
            <summary>
                <para>Get the MTime.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.MakeTransform">
            <summary>
                <para>Make another transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.GetInterpolationModeAsString">
            <summary>
                <para>Set interpolation mode for sampling the grid.  Higher-order interpolation allows you to use a sparser grid. Default: Linear.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.SetInterpolationModeToCubic">
            <summary>
                <para>Set interpolation mode for sampling the grid.  Higher-order interpolation allows you to use a sparser grid. Default: Linear.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.SetInterpolationModeToLinear">
            <summary>
                <para>Set interpolation mode for sampling the grid.  Higher-order interpolation allows you to use a sparser grid. Default: Linear.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.SetInterpolationModeToNearestNeighbor">
            <summary>
                <para>Set interpolation mode for sampling the grid.  Higher-order interpolation allows you to use a sparser grid. Default: Linear.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.GetInterpolationMode">
            <summary>
                <para>Set interpolation mode for sampling the grid.  Higher-order interpolation allows you to use a sparser grid. Default: Linear.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.SetInterpolationMode(System.Int32)">
            <summary>
                <para>Set interpolation mode for sampling the grid.  Higher-order interpolation allows you to use a sparser grid. Default: Linear.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.GetDisplacementShift">
            <summary>
                <para>Set a shift to be applied to the displacements.  The shift is applied after the scale, i.e. x = scale*y + shift. Default: 0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.SetDisplacementShift(System.Double)">
            <summary>
                <para>Set a shift to be applied to the displacements.  The shift is applied after the scale, i.e. x = scale*y + shift. Default: 0</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.GetDisplacementScale">
            <summary>
                <para>Set scale factor to be applied to the displacements. This is used primarily for grids which contain integer data types.  Default: 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.SetDisplacementScale(System.Double)">
            <summary>
                <para>Set scale factor to be applied to the displacements. This is used primarily for grids which contain integer data types.  Default: 1</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.GetDisplacementGrid">
            <summary>
                <para>Set/Get the grid transform (the grid transform must have three  components for displacement in x, y, and z respectively). The vtkGridTransform class will never modify the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkGridTransform.SetDisplacementGrid(vtk.vtkImageData)">
            <summary>
                <para>Set/Get the grid transform (the grid transform must have three  components for displacement in x, y, and z respectively). The vtkGridTransform class will never modify the data.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.MakeTransform">
            <summary>
                <para>Make another transform of the same type.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.GetMTime">
            <summary>
                <para>Get the MTime.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.GetTargetLandmarks">
            <summary>
                <para>Set the target landmarks for the warp.  If you add or change the vtkPoints object, you must call Modified() on it or the transformation might not update.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.SetTargetLandmarks(vtk.vtkPoints)">
            <summary>
                <para>Set the target landmarks for the warp.  If you add or change the vtkPoints object, you must call Modified() on it or the transformation might not update.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.GetSourceLandmarks">
            <summary>
                <para>Set the source landmarks for the warp.  If you add or change the vtkPoints object, you must call Modified() on it or the transformation might not update.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.SetSourceLandmarks(vtk.vtkPoints)">
            <summary>
                <para>Set the source landmarks for the warp.  If you add or change the vtkPoints object, you must call Modified() on it or the transformation might not update.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.GetBasisAsString">
            <summary>
                <para>Specify the radial basis function to use.  The default is R2LogR which is appropriate for 2D. Use |R| (SetBasisToR)  if your data is 3D. Alternatively specify your own basis function,  however this will mean that the transform will no longer be a true  thin-plate spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.SetBasisToR2LogR">
            <summary>
                <para>Specify the radial basis function to use.  The default is R2LogR which is appropriate for 2D. Use |R| (SetBasisToR)  if your data is 3D. Alternatively specify your own basis function,  however this will mean that the transform will no longer be a true  thin-plate spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.SetBasisToR">
            <summary>
                <para>Specify the radial basis function to use.  The default is R2LogR which is appropriate for 2D. Use |R| (SetBasisToR)  if your data is 3D. Alternatively specify your own basis function,  however this will mean that the transform will no longer be a true  thin-plate spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.GetBasis">
            <summary>
                <para>Specify the radial basis function to use.  The default is R2LogR which is appropriate for 2D. Use |R| (SetBasisToR)  if your data is 3D. Alternatively specify your own basis function,  however this will mean that the transform will no longer be a true  thin-plate spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.SetBasis(System.Int32)">
            <summary>
                <para>Specify the radial basis function to use.  The default is R2LogR which is appropriate for 2D. Use |R| (SetBasisToR)  if your data is 3D. Alternatively specify your own basis function,  however this will mean that the transform will no longer be a true  thin-plate spline.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.SetSigma(System.Double)">
            <summary>
                <para>Specify the 'stiffness' of the spline. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkThinPlateSplineTransform.GetSigma">
            <summary>
                <para>Specify the 'stiffness' of the spline. The default is 1.0.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.GetTolerance">
            <summary>
                <para>Set the tolerance for doing spatial searches of the polydata.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.SetTolerance(System.Double)">
            <summary>
                <para>Set the tolerance for doing spatial searches of the polydata.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.GetInput">
            <summary>
                <para>Specify the polydata to convert into a stencil.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkPolyDataToImageStencil.SetInput(vtk.vtkPolyData)">
            <summary>
                <para>Specify the polydata to convert into a stencil.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkExodusReader.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkExodusModel.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExodusModel.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExodusModel.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExodusModel.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkDSPFilterDefinition.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkDSPFilterDefinition.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkDSPFilterDefinition.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkDSPFilterDefinition.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExodusReader.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkExodusReader.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkExodusReader.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNodeSetArrayName(System.Int32)">
            <summary>
                <para>By default Node/Side sets are not loaded, These methods allow the user to select which Node/Side sets they want to load. NumberOfNodeSets and NumberOfSideSets (set by vtk macros) are stored in vtkExodusReader  but other Node/Side set metadata are stored in vtkExodusMetaData Note: GetNumberOfNodeSetArrays and GetNumberOfSideSetArrays are just syntatic sugar for paraview server xml</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetNodeSetArrayStatus(System.String,System.Int32)">
            <summary>
                <para>By default Node/Side sets are not loaded, These methods allow the user to select which Node/Side sets they want to load. NumberOfNodeSets and NumberOfSideSets (set by vtk macros) are stored in vtkExodusReader  but other Node/Side set metadata are stored in vtkExodusMetaData Note: GetNumberOfNodeSetArrays and GetNumberOfSideSetArrays are just syntatic sugar for paraview server xml</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetNodeSetArrayStatus(System.Int32,System.Int32)">
            <summary>
                <para>By default Node/Side sets are not loaded, These methods allow the user to select which Node/Side sets they want to load. NumberOfNodeSets and NumberOfSideSets (set by vtk macros) are stored in vtkExodusReader  but other Node/Side set metadata are stored in vtkExodusMetaData Note: GetNumberOfNodeSetArrays and GetNumberOfSideSetArrays are just syntatic sugar for paraview server xml</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNodeSetArrayStatus(System.String)">
            <summary>
                <para>By default Node/Side sets are not loaded, These methods allow the user to select which Node/Side sets they want to load. NumberOfNodeSets and NumberOfSideSets (set by vtk macros) are stored in vtkExodusReader  but other Node/Side set metadata are stored in vtkExodusMetaData Note: GetNumberOfNodeSetArrays and GetNumberOfSideSetArrays are just syntatic sugar for paraview server xml</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNodeSetArrayStatus(System.Int32)">
            <summary>
                <para>By default Node/Side sets are not loaded, These methods allow the user to select which Node/Side sets they want to load. NumberOfNodeSets and NumberOfSideSets (set by vtk macros) are stored in vtkExodusReader  but other Node/Side set metadata are stored in vtkExodusMetaData Note: GetNumberOfNodeSetArrays and GetNumberOfSideSetArrays are just syntatic sugar for paraview server xml</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNumberOfNodeSetArrays">
            <summary>
                <para>By default Node/Side sets are not loaded, These methods allow the user to select which Node/Side sets they want to load. NumberOfNodeSets and NumberOfSideSets (set by vtk macros) are stored in vtkExodusReader  but other Node/Side set metadata are stored in vtkExodusMetaData Note: GetNumberOfNodeSetArrays and GetNumberOfSideSetArrays are just syntatic sugar for paraview server xml</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetBlockId(System.Int32)">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNumberOfElementsInBlock(System.Int32)">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNumberOfNodes">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetTimeStepRange(System.Int32[])">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetTimeStepRange(System.Int32,System.Int32)">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetTimeStepRange">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNumberOfBlocks">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNumberOfSideSets">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNumberOfNodeSets">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNumberOfElements">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetNumberOfTimeSteps">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetDimensionality">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetTitle">
            <summary>
                <para>Access to meta data generated by UpdateInformation.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetDisplacementMagnitude">
            <summary>
                <para>Geometric locations can include displacements.  By default,  this is ON.  The nodal positions are 'displaced' by the standard exodus displacment vector. If displacements are turned 'off', the user can explicitly add them by applying a warp filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetDisplacementMagnitude(System.Single)">
            <summary>
                <para>Geometric locations can include displacements.  By default,  this is ON.  The nodal positions are 'displaced' by the standard exodus displacment vector. If displacements are turned 'off', the user can explicitly add them by applying a warp filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.ApplyDisplacementsOff">
            <summary>
                <para>Geometric locations can include displacements.  By default,  this is ON.  The nodal positions are 'displaced' by the standard exodus displacment vector. If displacements are turned 'off', the user can explicitly add them by applying a warp filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.ApplyDisplacementsOn">
            <summary>
                <para>Geometric locations can include displacements.  By default,  this is ON.  The nodal positions are 'displaced' by the standard exodus displacment vector. If displacements are turned 'off', the user can explicitly add them by applying a warp filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetApplyDisplacements">
            <summary>
                <para>Geometric locations can include displacements.  By default,  this is ON.  The nodal positions are 'displaced' by the standard exodus displacment vector. If displacements are turned 'off', the user can explicitly add them by applying a warp filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetApplyDisplacements(System.Int32)">
            <summary>
                <para>Geometric locations can include displacements.  By default,  this is ON.  The nodal positions are 'displaced' by the standard exodus displacment vector. If displacements are turned 'off', the user can explicitly add them by applying a warp filter.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetGlobalNodeID(vtk.vtkDataSet,System.Int32,System.Int32)">
            <summary>
                <para>Extra point data array that can be generated.  By default, this array is ON.  The value of the array is the integer id of the node. The id is relative to the entire data set. The name of the array is returned by GlobalNodeIdArrayName().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetGlobalNodeID(vtk.vtkDataSet,System.Int32)">
            <summary>
                <para>Extra point data array that can be generated.  By default, this array is ON.  The value of the array is the integer id of the node. The id is relative to the entire data set. The name of the array is returned by GlobalNodeIdArrayName().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetGlobalNodeIdArrayName">
            <summary>
                <para>Extra point data array that can be generated.  By default, this array is ON.  The value of the array is the integer id of the node. The id is relative to the entire data set. The name of the array is returned by GlobalNodeIdArrayName().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GenerateGlobalNodeIdArrayOff">
            <summary>
                <para>Extra point data array that can be generated.  By default, this array is ON.  The value of the array is the integer id of the node. The id is relative to the entire data set. The name of the array is returned by GlobalNodeIdArrayName().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GenerateGlobalNodeIdArrayOn">
            <summary>
                <para>Extra point data array that can be generated.  By default, this array is ON.  The value of the array is the integer id of the node. The id is relative to the entire data set. The name of the array is returned by GlobalNodeIdArrayName().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetGenerateGlobalNodeIdArray">
            <summary>
                <para>Extra point data array that can be generated.  By default, this array is ON.  The value of the array is the integer id of the node. The id is relative to the entire data set. The name of the array is returned by GlobalNodeIdArrayName().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetGenerateGlobalNodeIdArray(System.Int32)">
            <summary>
                <para>Extra point data array that can be generated.  By default, this array is ON.  The value of the array is the integer id of the node. The id is relative to the entire data set. The name of the array is returned by GlobalNodeIdArrayName().</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetGlobalElementID(vtk.vtkDataSet,System.Int32,System.Int32)">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is off.  The value of the array is the integer global id of the cell. The name of the array is returned by GetGlobalElementIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetGlobalElementID(vtk.vtkDataSet,System.Int32)">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is off.  The value of the array is the integer global id of the cell. The name of the array is returned by GetGlobalElementIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetGlobalElementIdArrayName">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is off.  The value of the array is the integer global id of the cell. The name of the array is returned by GetGlobalElementIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GenerateGlobalElementIdArrayOff">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is off.  The value of the array is the integer global id of the cell. The name of the array is returned by GetGlobalElementIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GenerateGlobalElementIdArrayOn">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is off.  The value of the array is the integer global id of the cell. The name of the array is returned by GetGlobalElementIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetGenerateGlobalElementIdArray">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is off.  The value of the array is the integer global id of the cell. The name of the array is returned by GetGlobalElementIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetGenerateGlobalElementIdArray(System.Int32)">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is off.  The value of the array is the integer global id of the cell. The name of the array is returned by GetGlobalElementIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetBlockIdArrayName">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is off.  The value of the array is the integer global id of the cell. The name of the array is returned by GetGlobalElementIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GenerateBlockIdCellArrayOff">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is ON.  The value of the array is the integer id found in the exodus file. The name of the array is returned by  GetBlockIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GenerateBlockIdCellArrayOn">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is ON.  The value of the array is the integer id found in the exodus file. The name of the array is returned by  GetBlockIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetGenerateBlockIdCellArray">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is ON.  The value of the array is the integer id found in the exodus file. The name of the array is returned by  GetBlockIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetGenerateBlockIdCellArray(System.Int32)">
            <summary>
                <para>Extra cell data array that can be generated.  By default, this array is ON.  The value of the array is the integer id found in the exodus file. The name of the array is returned by  GetBlockIdArrayName()</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetTimeStep">
            <summary>
                <para>Which TimeStep to read.    </para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetTimeStep(System.Int32)">
            <summary>
                <para>Which TimeStep to read.    </para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetXMLFileName">
            <summary>
                <para>Specify file name of the xml file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetXMLFileName(System.String)">
            <summary>
                <para>Specify file name of the xml file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.GetFileName">
            <summary>
                <para>Specify file name of the Exodus file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkExodusReader.SetFileName(System.String)">
            <summary>
                <para>Specify file name of the Exodus file.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFacetReader.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkFacetReader.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkFacetReader.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkFacetReader.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkFacetReader.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkFacetReader.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkFacetReader.GetFileName">
            <summary>
                <para>Specify file name of Facet datafile to read</para>
            </summary>
        </member>
        <member name="M:vtk.vtkFacetReader.SetFileName(System.String)">
            <summary>
                <para>Specify file name of Facet datafile to read</para>
            </summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtk3DSImporter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.ComputeNormalsOff">
            <summary>
                <para>Set/Get the computation of normals. If on, imported geometry will be run through vtkPolyDataNormals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.ComputeNormalsOn">
            <summary>
                <para>Set/Get the computation of normals. If on, imported geometry will be run through vtkPolyDataNormals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.GetComputeNormals">
            <summary>
                <para>Set/Get the computation of normals. If on, imported geometry will be run through vtkPolyDataNormals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.SetComputeNormals(System.Int32)">
            <summary>
                <para>Set/Get the computation of normals. If on, imported geometry will be run through vtkPolyDataNormals.</para>
            </summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.GetFileName">
            <summary>
                <para>Specify the name of the file to read.</para>
            </summary>
        </member>
        <member name="M:vtk.vtk3DSImporter.SetFileName(System.String)">
            <summary>
                <para>Specify the name of the file to read.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.ToString">
            <summary>
This returns the state of this object as a string. It is equivalent to PrintSelf.
</summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.PrintSelf(System.IO.TextWriter,System.Int32)">
            <summary>
PrintSelf writes the state of this object to a TextWriter.
</summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.Dispose">
            <summary>
This method calls Delete() on the native instance.
Use it to release resources in a timely fashion.
</summary>
            <remarks>
If this method is not called, then the finalizer will 
call Delete on this instance.
</remarks>
        </member>
        <member name="M:vtk.vtkRIBExporter.#ctor">
            <summary>
This constructor creates a wrapper class. It is the one to call.  /// </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.#ctor(System.Boolean)">
            <summary>
This constructor is called only by derived classes. It asks base classes not allocate a native instance.
</summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.#ctor(System.IntPtr,System.Boolean)">
            <summary>
This constructor is used to convert native pointers into managed wrapper classes.
</summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.GetExportArrays">
            <summary>
                <para>Set or get the ExportArrays. If ExportArrays is set, then all point data, field data, and cell data arrays will get  exported together with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.ExportArraysOff">
            <summary>
                <para>Set or get the ExportArrays. If ExportArrays is set, then all point data, field data, and cell data arrays will get  exported together with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.ExportArraysOn">
            <summary>
                <para>Set or get the ExportArrays. If ExportArrays is set, then all point data, field data, and cell data arrays will get  exported together with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.GetExportArraysMaxValue">
            <summary>
                <para>Set or get the ExportArrays. If ExportArrays is set, then all point data, field data, and cell data arrays will get  exported together with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.GetExportArraysMinValue">
            <summary>
                <para>Set or get the ExportArrays. If ExportArrays is set, then all point data, field data, and cell data arrays will get  exported together with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.SetExportArrays(System.Int32)">
            <summary>
                <para>Set or get the ExportArrays. If ExportArrays is set, then all point data, field data, and cell data arrays will get  exported together with polygons.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.BackgroundOff">
            <summary>
                <para>Set/Get the background flag. Default is 0 (off). If set, the rib file will contain an image shader that will use the renderer window's background color. Normally, RenderMan does generate backgrounds. Backgrounds are composited into the scene with the tiffcomp program that comes with Pixar's RenderMan Toolkit.  In fact, Pixar's Renderman will accept an image shader but only sets the alpha of the background. Images created this way will still have a black background but contain an alpha of 1 at all pixels and CANNOT be subsequently composited with other images using tiffcomp.  However, other RenderMan compliant renderers like Blue Moon Ray Tracing (BMRT) do allow image shaders and properly set the background color. If this sounds too confusing, use the following rules: If you are using Pixar's Renderman, leave the Background off. Otherwise, try setting BackGroundOn and see if you get the desired results.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.BackgroundOn">
            <summary>
                <para>Set/Get the background flag. Default is 0 (off). If set, the rib file will contain an image shader that will use the renderer window's background color. Normally, RenderMan does generate backgrounds. Backgrounds are composited into the scene with the tiffcomp program that comes with Pixar's RenderMan Toolkit.  In fact, Pixar's Renderman will accept an image shader but only sets the alpha of the background. Images created this way will still have a black background but contain an alpha of 1 at all pixels and CANNOT be subsequently composited with other images using tiffcomp.  However, other RenderMan compliant renderers like Blue Moon Ray Tracing (BMRT) do allow image shaders and properly set the background color. If this sounds too confusing, use the following rules: If you are using Pixar's Renderman, leave the Background off. Otherwise, try setting BackGroundOn and see if you get the desired results.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.GetBackground">
            <summary>
                <para>Set/Get the background flag. Default is 0 (off). If set, the rib file will contain an image shader that will use the renderer window's background color. Normally, RenderMan does generate backgrounds. Backgrounds are composited into the scene with the tiffcomp program that comes with Pixar's RenderMan Toolkit.  In fact, Pixar's Renderman will accept an image shader but only sets the alpha of the background. Images created this way will still have a black background but contain an alpha of 1 at all pixels and CANNOT be subsequently composited with other images using tiffcomp.  However, other RenderMan compliant renderers like Blue Moon Ray Tracing (BMRT) do allow image shaders and properly set the background color. If this sounds too confusing, use the following rules: If you are using Pixar's Renderman, leave the Background off. Otherwise, try setting BackGroundOn and see if you get the desired results.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.SetBackground(System.Int32)">
            <summary>
                <para>Set/Get the background flag. Default is 0 (off). If set, the rib file will contain an image shader that will use the renderer window's background color. Normally, RenderMan does generate backgrounds. Backgrounds are composited into the scene with the tiffcomp program that comes with Pixar's RenderMan Toolkit.  In fact, Pixar's Renderman will accept an image shader but only sets the alpha of the background. Images created this way will still have a black background but contain an alpha of 1 at all pixels and CANNOT be subsequently composited with other images using tiffcomp.  However, other RenderMan compliant renderers like Blue Moon Ray Tracing (BMRT) do allow image shaders and properly set the background color. If this sounds too confusing, use the following rules: If you are using Pixar's Renderman, leave the Background off. Otherwise, try setting BackGroundOn and see if you get the desired results.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.GetTexturePrefix">
            <summary>
                <para>Specify the prefix of any generated texture files.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.SetTexturePrefix(System.String)">
            <summary>
                <para>Specify the prefix of any generated texture files.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.GetFilePrefix">
            <summary>
                <para>Specify the prefix of the files to write out. The resulting file names will have .RIB appended to them.</para>
            </summary>
        </member>
        <member name="M:vtk.vtkRIBExporter.SetFilePrefix(System.String)">
            <summary>
                <para>Specify the prefix of the files to write out. The resulting file names will have .RIB appended to them.</para>
            </summary>
        </member>
    </members>
</doc>